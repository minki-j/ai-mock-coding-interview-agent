{
  "content": "<p>Given a positive integer <code>n</code>, generate an <code>n x n</code> <code>matrix</code> filled with elements from <code>1</code> to <code>n<sup>2</sup></code> in spiral order.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg\" style=\"width: 242px; height: 242px;\" />\n<pre>\n<strong>Input:</strong> n = 3\n<strong>Output:</strong> [[1,2,3],[8,9,4],[7,6,5]]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1\n<strong>Output:</strong> [[1]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 20</code></li>\n</ul>\n",
  "difficulty": "Medium",
  "title": "Spiral Matrix II",
  "topicTags": [
    {
      "name": "Array"
    },
    {
      "name": "Matrix"
    },
    {
      "name": "Simulation"
    }
  ],
  "solution": {
    "content": "[TOC]\n\n## Solution\n\n---\n### Overview\n\nThere are various problems in spiral matrix series with some variations like [Spiral Matrix](https://leetcode.com/problems/spiral-matrix/) and [Spiral Matrix III](https://leetcode.com/problems/spiral-matrix-iii/).\n\nIn order to solve such questions, the core idea is to decode the underlying pattern. This can be done by simulating the pattern and finding a generic representation that would work for any given $$n$$.\nLet's discuss a few approaches.\n\n---\n### Approach 1: Traverse Layer by Layer in Spiral Form\n\n**Intuition**\n\nIf we try to build a pattern for a given $$n$$, we observe that the pattern repeats after completing one circular traversal around the matrix. Let's call this one circular traversal as  _layer_. We start traversing from the outer layer and move towards inner layers on every iteration.\n\n![img](../Figures/59/spiral_layers.png)\n\n**Algorithm**\n\nLet's devise an algorithm for the spiral traversal:\n\n-  We can observe that, for any given $$n$$, the total number of layers is given by :\n$$\\lfloor \\frac{n+1}{2} \\rfloor$$\nThis works for both even and odd $$n$$.\n\n_Example_\n\nFor $$n = 3$$, $$layers = 2$$\n\nFor $$n = 6$$, total $$layers = 3$$\n\n- Also, for each layer, we traverse in _at most_ 4 directions :\n\n\n![img](../Figures/59/spiral_traverse.png)\n\n\nIn every direction, either row or column remains constant and other parameter changes (increments/decrements).\n\n_Direction 1: From top left corner to top right corner._\n\nThe row remains constant as $$\\text{layer}$$ and column increments from $$\\text{layer}$$ to  $$n-\\text{layer}-1$$\n\n_Direction 2: From top right corner to the bottom right corner._\n\nThe column remains constant as $$n-layer-1$$ and row increments from\n$$\\text{layer}+1$$ to $$n-\\text{layer}$$.\n\n_Direction 3: From bottom right corner to bottom left corner._\n\nThe row remains constant as $$n-\\text{layer}-1$$ and column decrements from $$n-\\text{layer}-2$$ to $$\\text{layer}$$.\n\n_Direction 4: From bottom left corner to top left corner._\n\nThe column remains constant as $$\\text{layer}$$ and column decrements from $$n-\\text{layer}-2$$ to $$\\text{layer}+1$$.\n\nThis process repeats $$(n+1)/2$$ times until all layers are traversed.\n\n![img](../Figures/59/spiral_detailed.png)\n\n\n<iframe src=\"\n```python3\nclass Solution:\n    def generateMatrix(self, n: int) -> list[list[int]]:\n        result = [[0] * n for _ in range(n)]\n        cnt = 1\n        for layer in range((n + 1) // 2):\n            # direction 1 - traverse from left to right\n            for ptr in range(layer, n - layer):\n                result[layer][ptr] = cnt\n                cnt += 1\n            # direction 2 - traverse from top to bottom\n            for ptr in range(layer + 1, n - layer):\n                result[ptr][n - layer - 1] = cnt\n                cnt += 1\n            # direction 3 - traverse from right to left\n            for ptr in range(n - layer - 2, layer - 1, -1):\n                result[n - layer - 1][ptr] = cnt\n                cnt += 1\n            # direction 4 - traverse from bottom to top\n            for ptr in range(n - layer - 2, layer, -1):\n                result[ptr][layer] = cnt\n                cnt += 1\n        return result\n```\n\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"6UNnc6fM\"></iframe>\n\n**Complexity Analysis**\n\n* Time Complexity: $$\\mathcal{O}(n^2)$$. Here, $$n$$ is given input and we are iterating over $$n\\cdot n$$ matrix in spiral form.\n* Space Complexity: $$\\mathcal{O}(1)$$  We use constant extra space for storing $$cnt$$.\n\n---\n### Approach 2: Optimized spiral traversal\n\n**Intuition**\n\nOur main aim is to walk in a spiral form and fill the array in a particular pattern. In the previous approach, we used a separate loop for each direction. Here, we discuss another optimized to achieve the same result.\n\n**Algorithm**\n\n- We have to walk in 4 directions forming a layer. We use an array $$dir$$ that stores the changes in $$x$$ and $$y$$ co-ordinates in each direction.\n\n_Example_\n\nIn left to right walk ( _direction #1_ ), $$x$$ co-ordinates remains same and $$y$$ increments ($$x = 0$$, $$y = 1$$).\n\nIn right to left walk ( _direction #3_ ), $$x$$ remains same and $$y$$ decrements ($$x = 0$$, $$y = -1$$).\n\nUsing this intuition, we pre-define an array $$dir$$ having $$x$$ and $$y$$ co-ordinate changes for each direction. There are a total of 4 directions as discussed in the previous approach.\n\n- The $$\\text{row}$$ and $$col$$ variables represent the current $$x$$ and $$y$$ co-ordinates respectively. It updates based on the direction in which we are moving.\n\n_How do we know when we have to change the direction?_\n\nWhen we find the next row or column in a particular direction has a non-zero value, we are sure it is already traversed and we change the direction.\n\nLet $$d$$ be the current direction index. We go to next direction in array $$dir$$ using $$(d+ 1) \\% 4$$. Using this we could go back to direction 1 after completing one circular traversal from direction 1 to direction 4 .\n\n> It must be noted that we use `floorMod` in Java instead of modulo $$\\%$$ to handle mod of negative numbers. This is required because row and column values might go negative and using $$\\%$$ won't give desired results in such cases.  \n\n<iframe src=\"\n```python3\nclass Solution:\n    def generateMatrix(self, n: int) -> List[List[int]]:\n        # Converting 2D space to 1D vector\n        def idx_convert_1D_2D(idx):\n            return idx // n, idx % n\n\n        # Checking for out of bound condition\n        def is_out_of_bound(row, col):\n            return row < 0 or row >= n or col < 0 or col >= n\n\n        dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        result = [[0] * n for _ in range(n)]\n        cur_dir_idx = 0\n        row, col = 0, 0\n        for i in range(1, n * n + 1):\n            result[row][col] = i\n            dx, dy = dirs[cur_dir_idx]\n            if (\n                is_out_of_bound(row + dx, col + dy)\n                or result[row + dx][col + dy] > 0\n            ):\n                cur_dir_idx = (cur_dir_idx + 1) % 4  # change directions\n            dx, dy = dirs[cur_dir_idx]\n            row, col = row + dx, col + dy\n        return result\n```\n\" frameBorder=\"0\" width=\"100%\" height=\"480\" name=\"QYtw7GFR\"></iframe>\n\n**Complexity Analysis**\n\n* Time Complexity: $$\\mathcal{O}(n^2)$$. Here, $$n$$ is given input and we are iterating over $$n\\cdot n$$ matrix in spiral form.\n* Space Complexity: $$\\mathcal{O}(1)$$  We use constant extra space for storing $$cnt$$."
  },
  "code_snippets": [
    {
      "url": "https://leetcode.com/playground/6UNnc6fM/shared",
      "code": "class Solution:\n    def generateMatrix(self, n: int) -> list[list[int]]:\n        result = [[0] * n for _ in range(n)]\n        cnt = 1\n        for layer in range((n + 1) // 2):\n            # direction 1 - traverse from left to right\n            for ptr in range(layer, n - layer):\n                result[layer][ptr] = cnt\n                cnt += 1\n            # direction 2 - traverse from top to bottom\n            for ptr in range(layer + 1, n - layer):\n                result[ptr][n - layer - 1] = cnt\n                cnt += 1\n            # direction 3 - traverse from right to left\n            for ptr in range(n - layer - 2, layer - 1, -1):\n                result[n - layer - 1][ptr] = cnt\n                cnt += 1\n            # direction 4 - traverse from bottom to top\n            for ptr in range(n - layer - 2, layer, -1):\n                result[ptr][layer] = cnt\n                cnt += 1\n        return result",
      "langSlug": "python3"
    },
    {
      "url": "https://leetcode.com/playground/QYtw7GFR/shared",
      "code": "class Solution:\n    def generateMatrix(self, n: int) -> List[List[int]]:\n        # Converting 2D space to 1D vector\n        def idx_convert_1D_2D(idx):\n            return idx // n, idx % n\n\n        # Checking for out of bound condition\n        def is_out_of_bound(row, col):\n            return row < 0 or row >= n or col < 0 or col >= n\n\n        dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        result = [[0] * n for _ in range(n)]\n        cur_dir_idx = 0\n        row, col = 0, 0\n        for i in range(1, n * n + 1):\n            result[row][col] = i\n            dx, dy = dirs[cur_dir_idx]\n            if (\n                is_out_of_bound(row + dx, col + dy)\n                or result[row + dx][col + dy] > 0\n            ):\n                cur_dir_idx = (cur_dir_idx + 1) % 4  # change directions\n            dx, dy = dirs[cur_dir_idx]\n            row, col = row + dx, col + dy\n        return result",
      "langSlug": "python3"
    }
  ],
  "content_md": "Given a positive integer `n`, generate an `n x n` `matrix` filled with elements from `1` to `n2` in spiral order.\n\n\n \n\n\n**Example 1:**\n\n\n![](https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg)\n\n```\n\nInput: n = 3\nOutput: [[1,2,3],[8,9,4],[7,6,5]]\n\n```\n\n**Example 2:**\n\n\n\n```\n\nInput: n = 1\nOutput: [[1]]\n\n```\n\n \n\n\n**Constraints:**\n\n\n* `1 <= n <= 20`\n\n\n",
  "solution_md": "\\[TOC]\n\n\\#\\# Solution\n\n\\-\\-\\-\n\\#\\#\\# Overview\n\nThere are various problems in spiral matrix series with some variations like \\[Spiral Matrix](https://leetcode.com/problems/spiral\\-matrix/) and \\[Spiral Matrix III](https://leetcode.com/problems/spiral\\-matrix\\-iii/).\n\nIn order to solve such questions, the core idea is to decode the underlying pattern. This can be done by simulating the pattern and finding a generic representation that would work for any given $$n$$.\nLet's discuss a few approaches.\n\n\\-\\-\\-\n\\#\\#\\# Approach 1: Traverse Layer by Layer in Spiral Form\n\n\\*\\*Intuition\\*\\*\n\nIf we try to build a pattern for a given $$n$$, we observe that the pattern repeats after completing one circular traversal around the matrix. Let's call this one circular traversal as \\_layer\\_. We start traversing from the outer layer and move towards inner layers on every iteration.\n\n!\\[img](../Figures/59/spiral\\_layers.png)\n\n\\*\\*Algorithm\\*\\*\n\nLet's devise an algorithm for the spiral traversal:\n\n\\- We can observe that, for any given $$n$$, the total number of layers is given by :\n$$\\\\lfloor \\\\frac{n\\+1}{2} \\\\rfloor$$\nThis works for both even and odd $$n$$.\n\n\\_Example\\_\n\nFor $$n \\= 3$$, $$layers \\= 2$$\n\nFor $$n \\= 6$$, total $$layers \\= 3$$\n\n\\- Also, for each layer, we traverse in \\_at most\\_ 4 directions :\n\n\n!\\[img](../Figures/59/spiral\\_traverse.png)\n\n\nIn every direction, either row or column remains constant and other parameter changes (increments/decrements).\n\n\\_Direction 1: From top left corner to top right corner.\\_\n\nThe row remains constant as $$\\\\text{layer}$$ and column increments from $$\\\\text{layer}$$ to $$n\\-\\\\text{layer}\\-1$$\n\n\\_Direction 2: From top right corner to the bottom right corner.\\_\n\nThe column remains constant as $$n\\-layer\\-1$$ and row increments from\n$$\\\\text{layer}\\+1$$ to $$n\\-\\\\text{layer}$$.\n\n\\_Direction 3: From bottom right corner to bottom left corner.\\_\n\nThe row remains constant as $$n\\-\\\\text{layer}\\-1$$ and column decrements from $$n\\-\\\\text{layer}\\-2$$ to $$\\\\text{layer}$$.\n\n\\_Direction 4: From bottom left corner to top left corner.\\_\n\nThe column remains constant as $$\\\\text{layer}$$ and column decrements from $$n\\-\\\\text{layer}\\-2$$ to $$\\\\text{layer}\\+1$$.\n\nThis process repeats $$(n\\+1\\)/2$$ times until all layers are traversed.\n\n!\\[img](../Figures/59/spiral\\_detailed.png)\n\n\n\n\n\\*\\*Complexity Analysis\\*\\*\n\n\\* Time Complexity: $$\\\\mathcal{O}(n^2\\)$$. Here, $$n$$ is given input and we are iterating over $$n\\\\cdot n$$ matrix in spiral form.\n\\* Space Complexity: $$\\\\mathcal{O}(1\\)$$ We use constant extra space for storing $$cnt$$.\n\n\\-\\-\\-\n\\#\\#\\# Approach 2: Optimized spiral traversal\n\n\\*\\*Intuition\\*\\*\n\nOur main aim is to walk in a spiral form and fill the array in a particular pattern. In the previous approach, we used a separate loop for each direction. Here, we discuss another optimized to achieve the same result.\n\n\\*\\*Algorithm\\*\\*\n\n\\- We have to walk in 4 directions forming a layer. We use an array $$dir$$ that stores the changes in $$x$$ and $$y$$ co\\-ordinates in each direction.\n\n\\_Example\\_\n\nIn left to right walk ( \\_direction \\#1\\_ ), $$x$$ co\\-ordinates remains same and $$y$$ increments ($$x \\= 0$$, $$y \\= 1$$).\n\nIn right to left walk ( \\_direction \\#3\\_ ), $$x$$ remains same and $$y$$ decrements ($$x \\= 0$$, $$y \\= \\-1$$).\n\nUsing this intuition, we pre\\-define an array $$dir$$ having $$x$$ and $$y$$ co\\-ordinate changes for each direction. There are a total of 4 directions as discussed in the previous approach.\n\n\\- The $$\\\\text{row}$$ and $$col$$ variables represent the current $$x$$ and $$y$$ co\\-ordinates respectively. It updates based on the direction in which we are moving.\n\n\\_How do we know when we have to change the direction?\\_\n\nWhen we find the next row or column in a particular direction has a non\\-zero value, we are sure it is already traversed and we change the direction.\n\nLet $$d$$ be the current direction index. We go to next direction in array $$dir$$ using $$(d\\+ 1\\) \\\\% 4$$. Using this we could go back to direction 1 after completing one circular traversal from direction 1 to direction 4 .\n\n\\> It must be noted that we use \\`floorMod\\` in Java instead of modulo $$\\\\%$$ to handle mod of negative numbers. This is required because row and column values might go negative and using $$\\\\%$$ won't give desired results in such cases. \n\n\n\n\\*\\*Complexity Analysis\\*\\*\n\n\\* Time Complexity: $$\\\\mathcal{O}(n^2\\)$$. Here, $$n$$ is given input and we are iterating over $$n\\\\cdot n$$ matrix in spiral form.\n\\* Space Complexity: $$\\\\mathcal{O}(1\\)$$ We use constant extra space for storing $$cnt$$.",
  "approaches": [
    {
      "title": "Traverse Layer by Layer in Spiral Form",
      "approach": "If we try to build a pattern for a given n, we observe that the pattern repeats after completing one circular traversal around the matrix. Let's call this one circular traversal as layer. We start traversing from the outer layer and move towards inner layers on every iteration. For any given n, the total number of layers is given by floor((n+1)/2). For each layer, we traverse in at most 4 directions: 1) From top left corner to top right corner. 2) From top right corner to the bottom right corner. 3) From bottom right corner to bottom left corner. 4) From bottom left corner to top left corner. This process repeats (n+1)/2 times until all layers are traversed.",
      "analysis": "Time Complexity: O(n^2). Here, n is given input and we are iterating over n x n matrix in spiral form. Space Complexity: O(1). We use constant extra space for storing cnt."
    },
    {
      "title": "Optimized spiral traversal",
      "approach": "Our main aim is to walk in a spiral form and fill the array in a particular pattern. In the previous approach, we used a separate loop for each direction. Here, we discuss another optimized way to achieve the same result. We have to walk in 4 directions forming a layer. We use an array 'dir' that stores the changes in x and y coordinates in each direction. The row and col variables represent the current x and y coordinates respectively. It updates based on the direction in which we are moving. When we find the next row or column in a particular direction has a non-zero value, we are sure it is already traversed and we change the direction. Let d be the current direction index. We go to the next direction in array 'dir' using (d + 1) % 4.",
      "analysis": "Time Complexity: O(n^2). Here, n is given input and we are iterating over n x n matrix in spiral form. Space Complexity: O(1). We use constant extra space for storing cnt."
    }
  ]
}