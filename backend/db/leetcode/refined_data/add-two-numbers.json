{
  "content": "<p>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers. The digits are stored in <strong>reverse order</strong>, and each of their nodes contains a single digit. Add the two numbers and return the sum&nbsp;as a linked list.</p>\n\n<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/02/addtwonumber1.jpg\" style=\"width: 483px; height: 342px;\" />\n<pre>\n<strong>Input:</strong> l1 = [2,4,3], l2 = [5,6,4]\n<strong>Output:</strong> [7,0,8]\n<strong>Explanation:</strong> 342 + 465 = 807.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> l1 = [0], l2 = [0]\n<strong>Output:</strong> [0]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\n<strong>Output:</strong> [8,9,9,9,0,0,0,1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in each linked list is in the range <code>[1, 100]</code>.</li>\n\t<li><code>0 &lt;= Node.val &lt;= 9</code></li>\n\t<li>It is guaranteed that the list represents a number that does not have leading zeros.</li>\n</ul>\n",
  "difficulty": "Medium",
  "title": "Add Two Numbers",
  "topicTags": [
    {
      "name": "Linked List"
    },
    {
      "name": "Math"
    },
    {
      "name": "Recursion"
    }
  ],
  "solution": {
    "content": "## Video Solution\n---\n\n<div class='video-preview'></div>\n\n<div>&nbsp;\n</div>\n\n## Solution Article\n\n---\n\n### Approach 1: Elementary Math\n\n**Intuition**\n\nKeep track of the carry using a variable and simulate digits-by-digits sum starting from the head of list, which contains the least-significant digit.\n\n![Illustration of Adding two numbers](../Figures/2_add_two_numbers.svg){:width=\"539px\"}\n\n\n*Figure 1. Visualization of the addition of two numbers: $$342 + 465 = 807$$.  \nEach node contains a single digit and the digits are stored in reverse order.*\n\n\n**Algorithm**\n\nJust like how you would sum two numbers on a piece of paper, we begin by summing the least-significant digits, which is the head of $$l1$$ and $$l2$$. Since each digit is in the range of $$0 \\ldots 9$$, summing two digits may \"overflow\". For example $$5 + 7 = 12$$. In this case, we set the current digit to $$2$$ and bring over the $$carry = 1$$ to the next iteration. $$carry$$ must be either $$0$$ or $$1$$ because the largest possible sum of two digits (including the carry) is $$9 + 9 + 1 = 19$$.\n\nThe pseudocode is as following:\n\n* Initialize current node to dummy head of the returning list.\n* Initialize carry to $$0$$.\n* Loop through lists $$l1$$ and $$l2$$ until you reach both ends and carry is $$0$$.\n    * Set $$x$$ to node $$l1$$'s value. If $$l1$$ has reached the end of $$l1$$, set to $$0$$.\n    * Set $$y$$ to node $$l2$$'s value. If $$l2$$ has reached the end of $$l2$$, set to $$0$$.\n    * Set $$sum = x + y + carry$$.\n    * Update $$carry = sum / 10$$.\n    * Create a new node with the digit value of $$(sum \\bmod 10)$$ and set it to current node's next, then advance current node to next.\n    * Advance both $$l1$$ and $$l2$$.\n* Return dummy head's next node.\n\nNote that we use a dummy head to simplify the code. Without a dummy head, you would have to write extra conditional statements to initialize the head's value.\n\nTake extra caution of the following cases:\n\n| Test case | Explanation |\n| ------------- | ---------------- |\n| $$l1=[0,1]$$<br>$$l2=[0,1,2]$$ | When one list is longer than the other. |\n| $$l1=[]$$<br>$$l2=[0,1]$$ | When one list is null, which means an empty list. |\n| $$l1=[9,9]$$<br>$$l2=[1]$$ | The sum could have an extra carry of one at the end, which is easy to forget. |\n\n**Implementation**\n\n<iframe src=\"\n```python3\nclass Solution:\n    def addTwoNumbers(\n        self, l1: Optional[ListNode], l2: Optional[ListNode]\n    ) -> Optional[ListNode]:\n        dummyHead = ListNode(0)\n        curr = dummyHead\n        carry = 0\n        while l1 != None or l2 != None or carry != 0:\n            l1Val = l1.val if l1 else 0\n            l2Val = l2.val if l2 else 0\n            columnSum = l1Val + l2Val + carry\n            carry = columnSum // 10\n            newNode = ListNode(columnSum % 10)\n            curr.next = newNode\n            curr = newNode\n            l1 = l1.next if l1 else None\n            l2 = l2.next if l2 else None\n        return dummyHead.next\n```\n\" frameBorder=\"0\" width=\"100%\" height=\"497\" name=\"XsLdm2AA\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity : $$O(\\max(m, n))$$. Assume that $$m$$ and $$n$$ represents the length of $$l1$$ and $$l2$$ respectively, the algorithm above iterates at most $$\\max(m, n)$$ times.\n\n* Space complexity : $$O(1)$$. The length of the new list is at most $$\\max(m,n) + 1$$ However, we don't count the answer as part of the space complexity.\n\n**Follow up**\n\nWhat if the the digits in the linked list are stored in non-reversed order? For example:\n\n$$\n(3 \\to 4 \\to 2) + (4 \\to 6 \\to 5) = 8 \\to 0 \\to 7\n$$"
  },
  "code_snippets": [
    {
      "url": "https://leetcode.com/playground/XsLdm2AA/shared",
      "code": "class Solution:\n    def addTwoNumbers(\n        self, l1: Optional[ListNode], l2: Optional[ListNode]\n    ) -> Optional[ListNode]:\n        dummyHead = ListNode(0)\n        curr = dummyHead\n        carry = 0\n        while l1 != None or l2 != None or carry != 0:\n            l1Val = l1.val if l1 else 0\n            l2Val = l2.val if l2 else 0\n            columnSum = l1Val + l2Val + carry\n            carry = columnSum // 10\n            newNode = ListNode(columnSum % 10)\n            curr.next = newNode\n            curr = newNode\n            l1 = l1.next if l1 else None\n            l2 = l2.next if l2 else None\n        return dummyHead.next",
      "langSlug": "python3"
    }
  ],
  "content_md": "You are given two **non\\-empty** linked lists representing two non\\-negative integers. The digits are stored in **reverse order**, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\n\n\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n\n\n \n\n\n**Example 1:**\n\n\n![](https://assets.leetcode.com/uploads/2020/10/02/addtwonumber1.jpg)\n\n```\n\nInput: l1 = [2,4,3], l2 = [5,6,4]\nOutput: [7,0,8]\nExplanation: 342 + 465 = 807.\n\n```\n\n**Example 2:**\n\n\n\n```\n\nInput: l1 = [0], l2 = [0]\nOutput: [0]\n\n```\n\n**Example 3:**\n\n\n\n```\n\nInput: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\nOutput: [8,9,9,9,0,0,0,1]\n\n```\n\n \n\n\n**Constraints:**\n\n\n* The number of nodes in each linked list is in the range `[1, 100]`.\n* `0 <= Node.val <= 9`\n* It is guaranteed that the list represents a number that does not have leading zeros.\n\n\n",
  "solution_md": "\\#\\# Video Solution\n\\-\\-\\-\n\n\n \n\n\n\\#\\# Solution Article\n\n\\-\\-\\-\n\n\\#\\#\\# Approach 1: Elementary Math\n\n\\*\\*Intuition\\*\\*\n\nKeep track of the carry using a variable and simulate digits\\-by\\-digits sum starting from the head of list, which contains the least\\-significant digit.\n\n!\\[Illustration of Adding two numbers](../Figures/2\\_add\\_two\\_numbers.svg){:width\\=\"539px\"}\n\n\n\\*Figure 1\\. Visualization of the addition of two numbers: $$342 \\+ 465 \\= 807$$. \nEach node contains a single digit and the digits are stored in reverse order.\\*\n\n\n\\*\\*Algorithm\\*\\*\n\nJust like how you would sum two numbers on a piece of paper, we begin by summing the least\\-significant digits, which is the head of $$l1$$ and $$l2$$. Since each digit is in the range of $$0 \\\\ldots 9$$, summing two digits may \"overflow\". For example $$5 \\+ 7 \\= 12$$. In this case, we set the current digit to $$2$$ and bring over the $$carry \\= 1$$ to the next iteration. $$carry$$ must be either $$0$$ or $$1$$ because the largest possible sum of two digits (including the carry) is $$9 \\+ 9 \\+ 1 \\= 19$$.\n\nThe pseudocode is as following:\n\n\\* Initialize current node to dummy head of the returning list.\n\\* Initialize carry to $$0$$.\n\\* Loop through lists $$l1$$ and $$l2$$ until you reach both ends and carry is $$0$$.\n \\* Set $$x$$ to node $$l1$$'s value. If $$l1$$ has reached the end of $$l1$$, set to $$0$$.\n \\* Set $$y$$ to node $$l2$$'s value. If $$l2$$ has reached the end of $$l2$$, set to $$0$$.\n \\* Set $$sum \\= x \\+ y \\+ carry$$.\n \\* Update $$carry \\= sum / 10$$.\n \\* Create a new node with the digit value of $$(sum \\\\bmod 10\\)$$ and set it to current node's next, then advance current node to next.\n \\* Advance both $$l1$$ and $$l2$$.\n\\* Return dummy head's next node.\n\nNote that we use a dummy head to simplify the code. Without a dummy head, you would have to write extra conditional statements to initialize the head's value.\n\nTake extra caution of the following cases:\n\n\\| Test case \\| Explanation \\|\n\\| \\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\- \\| \\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\- \\|\n\\| $$l1\\=\\[0,1]$$  \n$$l2\\=\\[0,1,2]$$ \\| When one list is longer than the other. \\|\n\\| $$l1\\=\\[]$$  \n$$l2\\=\\[0,1]$$ \\| When one list is null, which means an empty list. \\|\n\\| $$l1\\=\\[9,9]$$  \n$$l2\\=\\[1]$$ \\| The sum could have an extra carry of one at the end, which is easy to forget. \\|\n\n\\*\\*Implementation\\*\\*\n\n\n\n\\*\\*Complexity Analysis\\*\\*\n\n\\* Time complexity : $$O(\\\\max(m, n))$$. Assume that $$m$$ and $$n$$ represents the length of $$l1$$ and $$l2$$ respectively, the algorithm above iterates at most $$\\\\max(m, n)$$ times.\n\n\\* Space complexity : $$O(1\\)$$. The length of the new list is at most $$\\\\max(m,n) \\+ 1$$ However, we don't count the answer as part of the space complexity.\n\n\\*\\*Follow up\\*\\*\n\nWhat if the the digits in the linked list are stored in non\\-reversed order? For example:\n\n$$\n(3 \\\\to 4 \\\\to 2\\) \\+ (4 \\\\to 6 \\\\to 5\\) \\= 8 \\\\to 0 \\\\to 7\n$$",
  "approaches": [
    {
      "title": "Elementary Math",
      "approach": "Keep track of the carry using a variable and simulate digits-by-digits sum starting from the head of the list, which contains the least-significant digit. Initialize the current node to a dummy head of the returning list. Loop through lists l1 and l2 until you reach both ends and carry is 0. Update the carry by dividing the sum by 10. Create a new node with the digit value of (sum mod 10) and set it to the current node's next, then advance the current node to next. Advance both l1 and l2. Return dummy head's next node.",
      "analysis": "Time complexity: O(max(m, n)). Assume that m and n represent the lengths of l1 and l2 respectively, the algorithm iterates at most max(m, n) times. Space complexity: O(1). The length of the new list is at most max(m,n) + 1. However, we don't count the answer as part of the space complexity."
    }
  ]
}