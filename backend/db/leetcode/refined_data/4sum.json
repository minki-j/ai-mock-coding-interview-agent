{
  "content": "<p>Given an array <code>nums</code> of <code>n</code> integers, return <em>an array of all the <strong>unique</strong> quadruplets</em> <code>[nums[a], nums[b], nums[c], nums[d]]</code> such that:</p>\n\n<ul>\n\t<li><code>0 &lt;= a, b, c, d&nbsp;&lt; n</code></li>\n\t<li><code>a</code>, <code>b</code>, <code>c</code>, and <code>d</code> are <strong>distinct</strong>.</li>\n\t<li><code>nums[a] + nums[b] + nums[c] + nums[d] == target</code></li>\n</ul>\n\n<p>You may return the answer in <strong>any order</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,0,-1,0,-2,2], target = 0\n<strong>Output:</strong> [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,2,2,2,2], target = 8\n<strong>Output:</strong> [[2,2,2,2]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 200</code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= target &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
  "difficulty": "Medium",
  "title": "4Sum",
  "topicTags": [
    {
      "name": "Array"
    },
    {
      "name": "Two Pointers"
    },
    {
      "name": "Sorting"
    }
  ],
  "solution": {
    "content": "[TOC]\n\n## Solution\n\nThis problem is a follow-up of [3Sum](https://leetcode.com/articles/3sum/), so take a look at that problem first if you haven't. 4Sum and 3Sum are very similar; the difference is that we are looking for unique quadruplets instead of triplets.\n\nAs you see, 3Sum just wraps Two Sum in an outer loop. As it iterates through each value `v`, it finds all pairs whose sum is equal to `target - v` using one of these approaches:\n\n1. [Two Sum](https://leetcode.com/articles/two-sum/) uses a hash set to check for a matching value.\n2. [Two Sum II](https://leetcode.com/articles/two-sum-ii-input-array-is-sorted/) uses the two pointers pattern in a sorted array.\n\nFollowing a similar logic, we can implement 4Sum by wrapping 3Sum in another loop. But wait - there is a catch. If an interviewer asks you to solve 4Sum, they can follow-up with 5Sum, 6Sum, and so on. What they are really expecting at this point is a kSum solution. Therefore, we will focus on a generalized implementation here.\n\n---\n\n### Approach 1: Two Pointers\n\n**Intuition**\n\nThe two pointers pattern requires the array to be sorted, so we do that first.  Also, it's easier to deal with duplicates if the array is sorted: repeated values are next to each other and easy to skip.\n\nFor 3Sum, we enumerate each value in a single loop, and use the two pointers pattern for the rest of the array. For kSum, we will have `k - 2` nested loops to enumerate all combinations of `k - 2` values.\n\n!?!../Documents/18_4Sum.json:1200,440!?!\n\n**Algorithm**\n\nWe can implement `k - 2` loops using a recursion. We will pass the starting point and `k` as the parameters. When `k == 2`, we will call `twoSum`, terminating the recursion.\n\n1. For the main function:\n    - Sort the input array `nums`.\n    - Call `kSum` with `start = 0`, `k = 4`, and `target`, and return the result.\n\n2. For `kSum` function:\n    - At the start of the `kSum` function, we will check three conditions:\n      1. Have we run out of numbers to choose from?\n      2. Is the smallest number remaining greater than `target / k`? <br>If so, then any `k` numbers we choose will be too large.\n      3. Is the largest number remaining smaller than `target / k`? <br>If so, then any `k` numbers we choose will be too small.\n      - If any of these conditions is true, there is no need to continue as no combination of the remaining elements can sum to `target`.\n    - If `k` equals `2`, call `twoSum` and return the result.\n    - Iterate `i` through the array from `start`:\n        - If the current value is the same as the one before, skip it.\n        - Recursively call `kSum` with `start = i + 1`, `k = k - 1`, and `target - nums[i]`.\n        - For each returned `subset` of values:\n            - Include the current value `nums[i]` into `subset`.\n            - Add `subset` to the result `res`.\n    - Return the result `res`.\n\n3. For `twoSum` function:\n    - Set the low pointer `lo` to `start`, and high pointer `hi` to the last index.\n    - While low pointer is smaller than high:\n        - If the sum of `nums[lo]` and `nums[hi]` is less than `target`, increment `lo`.\n            - Also increment `lo` if the value is the same as for `lo - 1`.\n        - If the sum is greater than `target`, decrement `hi`.\n            - Also decrement `hi` if the value is the same as for `hi + 1`.\n        - Otherwise, we found a pair:\n            - Add it to the result `res`.\n            - Decrement `hi` and increment `lo`.\n    - Return the result `res`.\n\n**Implementation**\n\n<iframe src=\"\n```python3\nclass Solution:\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\n\n        def kSum(nums: List[int], target: int, k: int) -> List[List[int]]:\n            res = []\n\n            # If we have run out of numbers to add, return res.\n            if not nums:\n                return res\n\n            # There are k remaining values to add to the sum. The\n            # average of these values is at least target // k.\n            average_value = target // k\n\n            # We cannot obtain a sum of target if the smallest value\n            # in nums is greater than target // k or if the largest\n            # value in nums is smaller than target // k.\n            if average_value < nums[0] or nums[-1] < average_value:\n                return res\n\n            if k == 2:\n                return twoSum(nums, target)\n\n            for i in range(len(nums)):\n                if i == 0 or nums[i - 1] != nums[i]:\n                    for subset in kSum(nums[i + 1 :], target - nums[i], k - 1):\n                        res.append([nums[i]] + subset)\n\n            return res\n\n        def twoSum(nums: List[int], target: int) -> List[List[int]]:\n            res = []\n            lo, hi = 0, len(nums) - 1\n\n            while lo < hi:\n                curr_sum = nums[lo] + nums[hi]\n                if curr_sum < target or (lo > 0 and nums[lo] == nums[lo - 1]):\n                    lo += 1\n                elif curr_sum > target or (\n                    hi < len(nums) - 1 and nums[hi] == nums[hi + 1]\n                ):\n                    hi -= 1\n                else:\n                    res.append([nums[lo], nums[hi]])\n                    lo += 1\n                    hi -= 1\n\n            return res\n\n        nums.sort()\n        return kSum(nums, target, 4)\n```\n\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"mQdTCUXD\"></iframe>\n\n**Complexity Analysis**\n\n- Time Complexity: $$O(n^{k - 1})$$, or $$O(n^3)$$ for 4Sum. We have $$k - 2$$ loops, and `twoSum` is $$O(n)$$.\n\n    Note that for $$k > 2$$, sorting the array does not change the overall time complexity.\n\n- Space Complexity: $$O(n)$$. We need $$O(k)$$ space for the recursion. $$k$$ can be the same as $$n$$ in the worst case for the generalized algorithm.\n\n    Note that, for the purpose of complexity analysis, we ignore the memory required for the output.\n\n---\n\n### Approach 2: Hash Set\n    \n**Intuition**\n\nSince elements must sum up to the exact target value, we can also use the [Two Sum: One-pass Hash Table](https://leetcode.com/articles/two-sum/#approach-3-one-pass-hash-table) approach.\n\nIn [3Sum: Hash Set](https://leetcode.com/articles/3sum/#approach-2-hash-set), we solved the problem without sorting the array. To do that, we needed to sort values within triplets, and track them in a hash set. Doing the same for k values could be impractical.\n\nSo, for this approach, we will also sort the array and skip duplicates the same way as in the Two Pointers approach above. Thus, the code will only differ in the `twoSum` implementation.\n\n**Algorithm**\n\n`twoSum` implementation here is almost the same as in [Two Sum: One-pass Hash Table](https://leetcode.com/articles/two-sum/#approach-3-one-pass-hash-table). The only difference is the check to avoid duplicates. Since the array is sorted, we can just compare the found pair with the last one in the result `res`.\n    \n**Implementation**\n\n<iframe src=\"\n```python3\nclass Solution:\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\n\n        def kSum(nums: List[int], target: int, k: int) -> List[List[int]]:\n            res = []\n\n            # If we have run out of numbers to add, return res.\n            if not nums:\n                return res\n\n            # There are k remaining values to add to the sum. The\n            # average of these values is at least target // k.\n            average_value = target // k\n\n            # We cannot obtain a sum of target if the smallest value\n            # in nums is greater than target // k or if the largest\n            # value in nums is smaller than target // k.\n            if average_value < nums[0] or nums[-1] < average_value:\n                return res\n\n            if k == 2:\n                return twoSum(nums, target)\n\n            for i in range(len(nums)):\n                if i == 0 or nums[i - 1] != nums[i]:\n                    for subset in kSum(nums[i + 1 :], target - nums[i], k - 1):\n                        res.append([nums[i]] + subset)\n\n            return res\n\n        def twoSum(nums: List[int], target: int) -> List[List[int]]:\n            res = []\n            s = set()\n\n            for i in range(len(nums)):\n                if len(res) == 0 or res[-1][1] != nums[i]:\n                    if target - nums[i] in s:\n                        res.append([target - nums[i], nums[i]])\n                s.add(nums[i])\n\n            return res\n\n        nums.sort()\n        return kSum(nums, target, 4)\n```\n\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"oAq3g56d\"></iframe>\n\n**Complexity Analysis**\n\n- Time Complexity: $$O(n^{k - 1})$$, or $$O(n^3)$$ for 4Sum. We have $$k - 2$$ loops iterating over $$n$$ elements, and `twoSum` is $$O(n)$$.\n\n    Note that for $$k > 2$$, sorting the array does not change the overall time complexity.\n\n- Space Complexity: $$O(n)$$ for the hash set. The space needed for the recursion will not exceed $$O(n)$$."
  },
  "code_snippets": [
    {
      "url": "https://leetcode.com/playground/mQdTCUXD/shared",
      "code": "class Solution:\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\n\n        def kSum(nums: List[int], target: int, k: int) -> List[List[int]]:\n            res = []\n\n            # If we have run out of numbers to add, return res.\n            if not nums:\n                return res\n\n            # There are k remaining values to add to the sum. The\n            # average of these values is at least target // k.\n            average_value = target // k\n\n            # We cannot obtain a sum of target if the smallest value\n            # in nums is greater than target // k or if the largest\n            # value in nums is smaller than target // k.\n            if average_value < nums[0] or nums[-1] < average_value:\n                return res\n\n            if k == 2:\n                return twoSum(nums, target)\n\n            for i in range(len(nums)):\n                if i == 0 or nums[i - 1] != nums[i]:\n                    for subset in kSum(nums[i + 1 :], target - nums[i], k - 1):\n                        res.append([nums[i]] + subset)\n\n            return res\n\n        def twoSum(nums: List[int], target: int) -> List[List[int]]:\n            res = []\n            lo, hi = 0, len(nums) - 1\n\n            while lo < hi:\n                curr_sum = nums[lo] + nums[hi]\n                if curr_sum < target or (lo > 0 and nums[lo] == nums[lo - 1]):\n                    lo += 1\n                elif curr_sum > target or (\n                    hi < len(nums) - 1 and nums[hi] == nums[hi + 1]\n                ):\n                    hi -= 1\n                else:\n                    res.append([nums[lo], nums[hi]])\n                    lo += 1\n                    hi -= 1\n\n            return res\n\n        nums.sort()\n        return kSum(nums, target, 4)",
      "langSlug": "python3"
    },
    {
      "url": "https://leetcode.com/playground/oAq3g56d/shared",
      "code": "class Solution:\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\n\n        def kSum(nums: List[int], target: int, k: int) -> List[List[int]]:\n            res = []\n\n            # If we have run out of numbers to add, return res.\n            if not nums:\n                return res\n\n            # There are k remaining values to add to the sum. The\n            # average of these values is at least target // k.\n            average_value = target // k\n\n            # We cannot obtain a sum of target if the smallest value\n            # in nums is greater than target // k or if the largest\n            # value in nums is smaller than target // k.\n            if average_value < nums[0] or nums[-1] < average_value:\n                return res\n\n            if k == 2:\n                return twoSum(nums, target)\n\n            for i in range(len(nums)):\n                if i == 0 or nums[i - 1] != nums[i]:\n                    for subset in kSum(nums[i + 1 :], target - nums[i], k - 1):\n                        res.append([nums[i]] + subset)\n\n            return res\n\n        def twoSum(nums: List[int], target: int) -> List[List[int]]:\n            res = []\n            s = set()\n\n            for i in range(len(nums)):\n                if len(res) == 0 or res[-1][1] != nums[i]:\n                    if target - nums[i] in s:\n                        res.append([target - nums[i], nums[i]])\n                s.add(nums[i])\n\n            return res\n\n        nums.sort()\n        return kSum(nums, target, 4)",
      "langSlug": "python3"
    }
  ],
  "content_md": "Given an array `nums` of `n` integers, return *an array of all the **unique** quadruplets* `[nums[a], nums[b], nums[c], nums[d]]` such that:\n\n\n* `0 <= a, b, c, d < n`\n* `a`, `b`, `c`, and `d` are **distinct**.\n* `nums[a] + nums[b] + nums[c] + nums[d] == target`\n\n\nYou may return the answer in **any order**.\n\n\n \n\n\n**Example 1:**\n\n\n\n```\n\nInput: nums = [1,0,-1,0,-2,2], target = 0\nOutput: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\n\n```\n\n**Example 2:**\n\n\n\n```\n\nInput: nums = [2,2,2,2,2], target = 8\nOutput: [[2,2,2,2]]\n\n```\n\n \n\n\n**Constraints:**\n\n\n* `1 <= nums.length <= 200`\n* `-109 <= nums[i] <= 109`\n* `-109 <= target <= 109`\n\n\n",
  "solution_md": "\\[TOC]\n\n\\#\\# Solution\n\nThis problem is a follow\\-up of \\[3Sum](https://leetcode.com/articles/3sum/), so take a look at that problem first if you haven't. 4Sum and 3Sum are very similar; the difference is that we are looking for unique quadruplets instead of triplets.\n\nAs you see, 3Sum just wraps Two Sum in an outer loop. As it iterates through each value \\`v\\`, it finds all pairs whose sum is equal to \\`target \\- v\\` using one of these approaches:\n\n1\\. \\[Two Sum](https://leetcode.com/articles/two\\-sum/) uses a hash set to check for a matching value.\n2\\. \\[Two Sum II](https://leetcode.com/articles/two\\-sum\\-ii\\-input\\-array\\-is\\-sorted/) uses the two pointers pattern in a sorted array.\n\nFollowing a similar logic, we can implement 4Sum by wrapping 3Sum in another loop. But wait \\- there is a catch. If an interviewer asks you to solve 4Sum, they can follow\\-up with 5Sum, 6Sum, and so on. What they are really expecting at this point is a kSum solution. Therefore, we will focus on a generalized implementation here.\n\n\\-\\-\\-\n\n\\#\\#\\# Approach 1: Two Pointers\n\n\\*\\*Intuition\\*\\*\n\nThe two pointers pattern requires the array to be sorted, so we do that first. Also, it's easier to deal with duplicates if the array is sorted: repeated values are next to each other and easy to skip.\n\nFor 3Sum, we enumerate each value in a single loop, and use the two pointers pattern for the rest of the array. For kSum, we will have \\`k \\- 2\\` nested loops to enumerate all combinations of \\`k \\- 2\\` values.\n\n!?!../Documents/18\\_4Sum.json:1200,440!?!\n\n\\*\\*Algorithm\\*\\*\n\nWe can implement \\`k \\- 2\\` loops using a recursion. We will pass the starting point and \\`k\\` as the parameters. When \\`k \\=\\= 2\\`, we will call \\`twoSum\\`, terminating the recursion.\n\n1\\. For the main function:\n \\- Sort the input array \\`nums\\`.\n \\- Call \\`kSum\\` with \\`start \\= 0\\`, \\`k \\= 4\\`, and \\`target\\`, and return the result.\n\n2\\. For \\`kSum\\` function:\n \\- At the start of the \\`kSum\\` function, we will check three conditions:\n 1\\. Have we run out of numbers to choose from?\n 2\\. Is the smallest number remaining greater than \\`target / k\\`?   \nIf so, then any \\`k\\` numbers we choose will be too large.\n 3\\. Is the largest number remaining smaller than \\`target / k\\`?   \nIf so, then any \\`k\\` numbers we choose will be too small.\n \\- If any of these conditions is true, there is no need to continue as no combination of the remaining elements can sum to \\`target\\`.\n \\- If \\`k\\` equals \\`2\\`, call \\`twoSum\\` and return the result.\n \\- Iterate \\`i\\` through the array from \\`start\\`:\n \\- If the current value is the same as the one before, skip it.\n \\- Recursively call \\`kSum\\` with \\`start \\= i \\+ 1\\`, \\`k \\= k \\- 1\\`, and \\`target \\- nums\\[i]\\`.\n \\- For each returned \\`subset\\` of values:\n \\- Include the current value \\`nums\\[i]\\` into \\`subset\\`.\n \\- Add \\`subset\\` to the result \\`res\\`.\n \\- Return the result \\`res\\`.\n\n3\\. For \\`twoSum\\` function:\n \\- Set the low pointer \\`lo\\` to \\`start\\`, and high pointer \\`hi\\` to the last index.\n \\- While low pointer is smaller than high:\n \\- If the sum of \\`nums\\[lo]\\` and \\`nums\\[hi]\\` is less than \\`target\\`, increment \\`lo\\`.\n \\- Also increment \\`lo\\` if the value is the same as for \\`lo \\- 1\\`.\n \\- If the sum is greater than \\`target\\`, decrement \\`hi\\`.\n \\- Also decrement \\`hi\\` if the value is the same as for \\`hi \\+ 1\\`.\n \\- Otherwise, we found a pair:\n \\- Add it to the result \\`res\\`.\n \\- Decrement \\`hi\\` and increment \\`lo\\`.\n \\- Return the result \\`res\\`.\n\n\\*\\*Implementation\\*\\*\n\n\n\n\\*\\*Complexity Analysis\\*\\*\n\n\\- Time Complexity: $$O(n^{k \\- 1})$$, or $$O(n^3\\)$$ for 4Sum. We have $$k \\- 2$$ loops, and \\`twoSum\\` is $$O(n)$$.\n\n Note that for $$k \\> 2$$, sorting the array does not change the overall time complexity.\n\n\\- Space Complexity: $$O(n)$$. We need $$O(k)$$ space for the recursion. $$k$$ can be the same as $$n$$ in the worst case for the generalized algorithm.\n\n Note that, for the purpose of complexity analysis, we ignore the memory required for the output.\n\n\\-\\-\\-\n\n\\#\\#\\# Approach 2: Hash Set\n \n\\*\\*Intuition\\*\\*\n\nSince elements must sum up to the exact target value, we can also use the \\[Two Sum: One\\-pass Hash Table](https://leetcode.com/articles/two\\-sum/\\#approach\\-3\\-one\\-pass\\-hash\\-table) approach.\n\nIn \\[3Sum: Hash Set](https://leetcode.com/articles/3sum/\\#approach\\-2\\-hash\\-set), we solved the problem without sorting the array. To do that, we needed to sort values within triplets, and track them in a hash set. Doing the same for k values could be impractical.\n\nSo, for this approach, we will also sort the array and skip duplicates the same way as in the Two Pointers approach above. Thus, the code will only differ in the \\`twoSum\\` implementation.\n\n\\*\\*Algorithm\\*\\*\n\n\\`twoSum\\` implementation here is almost the same as in \\[Two Sum: One\\-pass Hash Table](https://leetcode.com/articles/two\\-sum/\\#approach\\-3\\-one\\-pass\\-hash\\-table). The only difference is the check to avoid duplicates. Since the array is sorted, we can just compare the found pair with the last one in the result \\`res\\`.\n \n\\*\\*Implementation\\*\\*\n\n\n\n\\*\\*Complexity Analysis\\*\\*\n\n\\- Time Complexity: $$O(n^{k \\- 1})$$, or $$O(n^3\\)$$ for 4Sum. We have $$k \\- 2$$ loops iterating over $$n$$ elements, and \\`twoSum\\` is $$O(n)$$.\n\n Note that for $$k \\> 2$$, sorting the array does not change the overall time complexity.\n\n\\- Space Complexity: $$O(n)$$ for the hash set. The space needed for the recursion will not exceed $$O(n)$$.",
  "approaches": [
    {
      "title": "Two Pointers",
      "approach": "The two pointers pattern requires the array to be sorted, so we do that first. Also, it's easier to deal with duplicates if the array is sorted: repeated values are next to each other and easy to skip. For 3Sum, we enumerate each value in a single loop, and use the two pointers pattern for the rest of the array. For kSum, we will have k - 2 nested loops to enumerate all combinations of k - 2 values. We can implement k - 2 loops using a recursion. We will pass the starting point and k as the parameters. When k == 2, we will call twoSum, terminating the recursion. For the main function, sort the input array nums. Call kSum with start = 0, k = 4, and target, and return the result. For kSum function, check three conditions: Have we run out of numbers to choose from? Is the smallest number remaining greater than target / k? If so, then any k numbers we choose will be too large. Is the largest number remaining smaller than target / k? If so, then any k numbers we choose will be too small. If any of these conditions is true, no combination of the remaining elements can sum to target. If k equals 2, call twoSum and return the result. Iterate i through the array from start: If the current value is the same as the one before, skip it. Recursively call kSum with start = i + 1, k = k - 1, and target - nums[i]. For each returned subset of values, include the current value nums[i] into subset. Add subset to the result res. Return the result res. For twoSum function, set the low pointer lo to start, and high pointer hi to the last index. While low pointer is smaller than high: If the sum of nums[lo] and nums[hi] is less than target, increment lo. Also increment lo if the value is the same as for lo - 1. If the sum is greater than target, decrement hi. Also decrement hi if the value is the same as for hi + 1. Otherwise, we found a pair: Add it to the result res. Decrement hi and increment lo. Return the result res.",
      "analysis": "Time Complexity: O(n^{k - 1}), or O(n^3) for 4Sum. We have k - 2 loops, and twoSum is O(n). Note that for k > 2, sorting the array does not change the overall time complexity. Space Complexity: O(n). We need O(k) space for the recursion. k can be the same as n in the worst case for the generalized algorithm. Note that, for the purpose of complexity analysis, we ignore the memory required for the output."
    },
    {
      "title": "Hash Set",
      "approach": "Since elements must sum up to the exact target value, we can also use the Two Sum: One-pass Hash Table approach. In 3Sum: Hash Set, we solved the problem without sorting the array. To do that, we needed to sort values within triplets, and track them in a hash set. Doing the same for k values could be impractical. So, for this approach, we will also sort the array and skip duplicates the same way as in the Two Pointers approach above. Thus, the code will only differ in the twoSum implementation. twoSum implementation here is almost the same as in Two Sum: One-pass Hash Table. The only difference is the check to avoid duplicates. Since the array is sorted, we can just compare the found pair with the last one in the result res.",
      "analysis": "Time Complexity: O(n^{k - 1}), or O(n^3) for 4Sum. We have k - 2 loops iterating over n elements, and twoSum is O(n). Note that for k > 2, sorting the array does not change the overall time complexity. Space Complexity: O(n) for the hash set. The space needed for the recursion will not exceed O(n)."
    }
  ]
}