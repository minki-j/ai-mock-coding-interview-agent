{
  "content": "<p>Given an integer array <code>nums</code> of <strong>unique</strong> elements, return <em>all possible</em> <span data-keyword=\"subset\"><em>subsets</em></span> <em>(the power set)</em>.</p>\n\n<p>The solution set <strong>must not</strong> contain duplicate subsets. Return the solution in <strong>any order</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3]\n<strong>Output:</strong> [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [0]\n<strong>Output:</strong> [[],[0]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10</code></li>\n\t<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>\n\t<li>All the numbers of&nbsp;<code>nums</code> are <strong>unique</strong>.</li>\n</ul>\n",
  "difficulty": "Medium",
  "title": "Subsets",
  "topicTags": [
    {
      "name": "Array"
    },
    {
      "name": "Backtracking"
    },
    {
      "name": "Bit Manipulation"
    }
  ],
  "solution": {
    "content": "[TOC]\n\n## Video Solution\n---\n\n<div class='video-preview'></div>\n\n<div>&nbsp;\n</div>\n\n## Solution Article\n\n---\n\n### Overview: Solution Pattern\n\nLet us first review the problems of Permutations / Combinations / Subsets, since they are quite similar to each other and there are some common strategies to solve them.\n\nFirst, their solution space is often quite large:\n\n- [Permutations](https://en.wikipedia.org/wiki/Permutation#k-permutations_of_n): $$N!$$. \n\n- [Combinations](https://en.wikipedia.org/wiki/Combination#Number_of_k-combinations): $$C_N^k = \\frac{N!}{(N - k)! k!}$$\n\n- Subsets: $$2^N$$, since each element could be absent or present. \n\nGiven their exponential solution space, it is tricky to ensure that the generated solutions are _**complete**_ and _**non-redundant**_. It is essential to have a clear and easy-to-reason strategy.\n\nThere are generally three strategies to do it:\n\n- Iterative\n\n- Recursion/Backtracking\n\n- Lexicographic generation based on the mapping between binary bitmasks and the corresponding permutations / combinations / subsets.\n\nAs one would see later, the third method could be a good candidate for the interview because it simplifies the problem to the generation of binary numbers, therefore it is easy to implement and verify that no solution is missing.\n\nBesides, as a bonus, it generates lexicographically sorted output for the sorted inputs.\n\n\n---\n### Approach 1: Cascading\n\n#### Intuition\n\nLet's start from an empty subset in the output list. At each step, one takes a new integer into consideration and generates new subsets from the existing ones. \n\n![diff](../Figures/78/recursion.png)\n\n#### Implementation\n\n<iframe src=\"\n```python3\nclass Solution:\n    def subsets(self, nums):\n        output = [[]]\n        for num in nums:\n            newSubsets = []\n            for curr in output:\n                temp = curr.copy()\n                temp.append(num)\n                newSubsets.append(temp)\n            for curr in newSubsets:\n                output.append(curr)\n        return output\n```\n\" frameBorder=\"0\" width=\"100%\" height=\"395\" name=\"6Rv86gDs\"></iframe>\n\n#### Complexity Analysis\n\n* Time complexity: $$\\mathcal{O}(N \\times 2^N)$$ to generate all subsets and then copy them into the output list. \n    \n* Space complexity: $$\\mathcal{O}(N \\times 2^N)$$. This is exactly the number of solutions for subsets multiplied by the number $$N$$ of elements to keep for each subset.  \n    - For a given number, it could be present or absent (_i.e._ binary choice) in a subset solution. As a result, for $$N$$ numbers, we would have in total $$2^N$$ choices (solutions). \n<br />\n<br />\n\n\n---\n### Approach 2: Backtracking\n\n#### Algorithm\n\n>Power set is all possible combinations of all possible _lengths_, from 0 to n.\n\nGiven the definition, the problem can also be interpreted as finding the _power set_ from a sequence.\n\nSo, this time let us loop over the length of combination, rather than the candidate numbers, and generate all combinations for a given length with the help of _backtracking_ technique.\n\n![diff](../Figures/78/combinations.png)\n\n>[Backtracking](https://leetcode.com/explore/learn/card/recursion-ii/472/backtracking/2654/) is an algorithm for finding all solutions by exploring all potential candidates. If the solution candidate turns out to be _not_ a solution (or at least not the _last_ one), the backtracking algorithm discards it by making some changes on the previous step, *i.e.* _backtracks_ and then tries again.\n\n![diff](../Figures/78/backtracking.png)\n\n#### Algorithm\n\nWe define a backtrack function named `backtrack(first, curr)` that takes the index of the first element to add and a current combination as arguments.\n\n- If the current combination is done, we add the combination to the final output.\n\n- Otherwise, we iterate over the indexes `i` from `first` to the length of the entire sequence `n`.\n\n    - Add integer `nums[i]` into the current combination `curr`.\n\n    - Proceed to add more integers into the combination: `backtrack(i + 1, curr)`.\n\n    - Backtrack by removing `nums[i]` from `curr`.\n\n#### Implementation\n\n<iframe src=\"\n```python3\nclass Solution:\n    def subsets(self, nums):\n        self.output = []\n        self.n, self.k = len(nums), None\n        for self.k in range(self.n + 1):\n            self.backtrack(0, [], nums)\n        return self.output\n\n    def backtrack(self, first, curr, nums):\n        if len(curr) == self.k:\n            self.output.append(curr[:])\n        for i in range(first, self.n):\n            curr.append(nums[i])\n            self.backtrack(i + 1, curr, nums)\n            curr.pop()\n```\n\" frameBorder=\"0\" width=\"100%\" height=\"480\" name=\"fys24GkD\"></iframe>\n\n#### Complexity Analysis\n\n* Time complexity: $$\\mathcal{O}(N \\times 2^N)$$ to generate all subsets and then copy them into the output list.\n \n* Space complexity: $$\\mathcal{O}(N)$$. We are using $$O(N)$$ space to maintain `curr`, and are modifying `curr` in-place with backtracking. Note that for space complexity analysis, we do not count space that is *only* used for the purpose of returning output, so the `output` array is ignored.\n\n\n---\n### Approach 3: Lexicographic (Binary Sorted) Subsets\n\n#### Intuition\n\nThe idea of this solution is originated from [Donald E. Knuth](https://www-cs-faculty.stanford.edu/~knuth/taocp.html).\n\n>The idea is that we map each subset to a bitmask of length n,\nwhere `1` on the i*th* position in bitmask means the presence of `nums[i]`\nin the subset, and `0` means its absence. \n\n![diff](../Figures/78/bitmask4.png)\n\nFor instance, the bitmask `0..00` (all zeros) corresponds to an empty subset, \nand the bitmask `1..11` (all ones) corresponds to the entire input array `nums`. \n\nHence to solve the initial problem, we just need to generate n bitmasks\nfrom `0..00` to `1..11`. \n\nIt might seem simple at first glance to generate binary numbers, but \nthe real problem here is how to deal with \n[zero left padding](https://en.wikipedia.org/wiki/Padding_(cryptography)#Zero_padding),\nbecause one has to generate bitmasks of fixed length, _i.e._ `001` and not just `1`.\nFor that one could use standard bit manipulation trick:\n\n<iframe src=\"\n```python3\nnth_bit = 1 << n\nfor i in range(2**n):\n    # generate bitmask, from 0..00 to 1..11\n    bitmask = bin(i | nth_bit)[3:]\n```\n\" frameBorder=\"0\" width=\"100%\" height=\"140\" name=\"G6w7LMJf\"></iframe>\n\nor keep it simple stupid and shift iteration limits:\n\n<iframe src=\"\n```python3\nfor i in range(2**n, 2 ** (n + 1)):\n    # generate bitmask, from 0..00 to 1..11\n    bitmask = bin(i)[3:]\n```\n\" frameBorder=\"0\" width=\"100%\" height=\"123\" name=\"o74vC4UT\"></iframe>\n\n#### Algorithm\n\n- Generate all possible binary bitmasks of length n.\n\n- Map a subset to each bitmask: \n`1` on the i*th* position in bitmask means the presence of `nums[i]`\nin the subset, and `0` means its absence. \n\n- Return output list.\n\n#### Implementation\n\n<iframe src=\"\n```python3\nclass Solution:\n    def subsets(self, nums: List[int]) -> List[List[int]]:\n        n = len(nums)\n        output = []\n\n        for i in range(2**n, 2 ** (n + 1)):\n            # generate bitmask, from 0..00 to 1..11\n            bitmask = bin(i)[3:]\n\n            # append subset corresponding to that bitmask\n            output.append([nums[j] for j in range(n) if bitmask[j] == \"1\"])\n\n        return output\n```\n\" frameBorder=\"0\" width=\"100%\" height=\"395\" name=\"WDbHETN6\"></iframe>\n\n#### Complexity Analysis\n\n* Time complexity: $$\\mathcal{O}(N \\times 2^N)$$ to generate all subsets \nand then copy them into output list.\n    \n* Space complexity: $$\\mathcal{O}(N)$$ to store the bitset\nof length $$N$$. Note that for space complexity analysis, we do not count space that is *only* used for the purpose of returning output, so the `output` array is ignored."
  },
  "code_snippets": [
    {
      "url": "https://leetcode.com/playground/6Rv86gDs/shared",
      "code": "class Solution:\n    def subsets(self, nums):\n        output = [[]]\n        for num in nums:\n            newSubsets = []\n            for curr in output:\n                temp = curr.copy()\n                temp.append(num)\n                newSubsets.append(temp)\n            for curr in newSubsets:\n                output.append(curr)\n        return output",
      "langSlug": "python3"
    },
    {
      "url": "https://leetcode.com/playground/fys24GkD/shared",
      "code": "class Solution:\n    def subsets(self, nums):\n        self.output = []\n        self.n, self.k = len(nums), None\n        for self.k in range(self.n + 1):\n            self.backtrack(0, [], nums)\n        return self.output\n\n    def backtrack(self, first, curr, nums):\n        if len(curr) == self.k:\n            self.output.append(curr[:])\n        for i in range(first, self.n):\n            curr.append(nums[i])\n            self.backtrack(i + 1, curr, nums)\n            curr.pop()",
      "langSlug": "python3"
    },
    {
      "url": "https://leetcode.com/playground/G6w7LMJf/shared",
      "code": "nth_bit = 1 << n\nfor i in range(2**n):\n    # generate bitmask, from 0..00 to 1..11\n    bitmask = bin(i | nth_bit)[3:]",
      "langSlug": "python3"
    },
    {
      "url": "https://leetcode.com/playground/o74vC4UT/shared",
      "code": "for i in range(2**n, 2 ** (n + 1)):\n    # generate bitmask, from 0..00 to 1..11\n    bitmask = bin(i)[3:]",
      "langSlug": "python3"
    },
    {
      "url": "https://leetcode.com/playground/WDbHETN6/shared",
      "code": "class Solution:\n    def subsets(self, nums: List[int]) -> List[List[int]]:\n        n = len(nums)\n        output = []\n\n        for i in range(2**n, 2 ** (n + 1)):\n            # generate bitmask, from 0..00 to 1..11\n            bitmask = bin(i)[3:]\n\n            # append subset corresponding to that bitmask\n            output.append([nums[j] for j in range(n) if bitmask[j] == \"1\"])\n\n        return output",
      "langSlug": "python3"
    }
  ],
  "content_md": "Given an integer array `nums` of **unique** elements, return *all possible* *subsets* *(the power set)*.\n\n\nThe solution set **must not** contain duplicate subsets. Return the solution in **any order**.\n\n\n \n\n\n**Example 1:**\n\n\n\n```\n\nInput: nums = [1,2,3]\nOutput: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\n\n```\n\n**Example 2:**\n\n\n\n```\n\nInput: nums = [0]\nOutput: [[],[0]]\n\n```\n\n \n\n\n**Constraints:**\n\n\n* `1 <= nums.length <= 10`\n* `-10 <= nums[i] <= 10`\n* All the numbers of `nums` are **unique**.\n\n\n",
  "solution_md": "\\[TOC]\n\n\\#\\# Video Solution\n\\-\\-\\-\n\n\n \n\n\n\\#\\# Solution Article\n\n\\-\\-\\-\n\n\\#\\#\\# Overview: Solution Pattern\n\nLet us first review the problems of Permutations / Combinations / Subsets, since they are quite similar to each other and there are some common strategies to solve them.\n\nFirst, their solution space is often quite large:\n\n\\- \\[Permutations](https://en.wikipedia.org/wiki/Permutation\\#k\\-permutations\\_of\\_n): $$N!$$. \n\n\\- \\[Combinations](https://en.wikipedia.org/wiki/Combination\\#Number\\_of\\_k\\-combinations): $$C\\_N^k \\= \\\\frac{N!}{(N \\- k)! k!}$$\n\n\\- Subsets: $$2^N$$, since each element could be absent or present. \n\nGiven their exponential solution space, it is tricky to ensure that the generated solutions are \\_\\*\\*complete\\*\\*\\_ and \\_\\*\\*non\\-redundant\\*\\*\\_. It is essential to have a clear and easy\\-to\\-reason strategy.\n\nThere are generally three strategies to do it:\n\n\\- Iterative\n\n\\- Recursion/Backtracking\n\n\\- Lexicographic generation based on the mapping between binary bitmasks and the corresponding permutations / combinations / subsets.\n\nAs one would see later, the third method could be a good candidate for the interview because it simplifies the problem to the generation of binary numbers, therefore it is easy to implement and verify that no solution is missing.\n\nBesides, as a bonus, it generates lexicographically sorted output for the sorted inputs.\n\n\n\\-\\-\\-\n\\#\\#\\# Approach 1: Cascading\n\n\\#\\#\\#\\# Intuition\n\nLet's start from an empty subset in the output list. At each step, one takes a new integer into consideration and generates new subsets from the existing ones. \n\n!\\[diff](../Figures/78/recursion.png)\n\n\\#\\#\\#\\# Implementation\n\n\n\n\\#\\#\\#\\# Complexity Analysis\n\n\\* Time complexity: $$\\\\mathcal{O}(N \\\\times 2^N)$$ to generate all subsets and then copy them into the output list. \n \n\\* Space complexity: $$\\\\mathcal{O}(N \\\\times 2^N)$$. This is exactly the number of solutions for subsets multiplied by the number $$N$$ of elements to keep for each subset. \n \\- For a given number, it could be present or absent (\\_i.e.\\_ binary choice) in a subset solution. As a result, for $$N$$ numbers, we would have in total $$2^N$$ choices (solutions). \n  \n\n  \n\n\n\n\\-\\-\\-\n\\#\\#\\# Approach 2: Backtracking\n\n\\#\\#\\#\\# Algorithm\n\n\\>Power set is all possible combinations of all possible \\_lengths\\_, from 0 to n.\n\nGiven the definition, the problem can also be interpreted as finding the \\_power set\\_ from a sequence.\n\nSo, this time let us loop over the length of combination, rather than the candidate numbers, and generate all combinations for a given length with the help of \\_backtracking\\_ technique.\n\n!\\[diff](../Figures/78/combinations.png)\n\n\\>\\[Backtracking](https://leetcode.com/explore/learn/card/recursion\\-ii/472/backtracking/2654/) is an algorithm for finding all solutions by exploring all potential candidates. If the solution candidate turns out to be \\_not\\_ a solution (or at least not the \\_last\\_ one), the backtracking algorithm discards it by making some changes on the previous step, \\*i.e.\\* \\_backtracks\\_ and then tries again.\n\n!\\[diff](../Figures/78/backtracking.png)\n\n\\#\\#\\#\\# Algorithm\n\nWe define a backtrack function named \\`backtrack(first, curr)\\` that takes the index of the first element to add and a current combination as arguments.\n\n\\- If the current combination is done, we add the combination to the final output.\n\n\\- Otherwise, we iterate over the indexes \\`i\\` from \\`first\\` to the length of the entire sequence \\`n\\`.\n\n \\- Add integer \\`nums\\[i]\\` into the current combination \\`curr\\`.\n\n \\- Proceed to add more integers into the combination: \\`backtrack(i \\+ 1, curr)\\`.\n\n \\- Backtrack by removing \\`nums\\[i]\\` from \\`curr\\`.\n\n\\#\\#\\#\\# Implementation\n\n\n\n\\#\\#\\#\\# Complexity Analysis\n\n\\* Time complexity: $$\\\\mathcal{O}(N \\\\times 2^N)$$ to generate all subsets and then copy them into the output list.\n \n\\* Space complexity: $$\\\\mathcal{O}(N)$$. We are using $$O(N)$$ space to maintain \\`curr\\`, and are modifying \\`curr\\` in\\-place with backtracking. Note that for space complexity analysis, we do not count space that is \\*only\\* used for the purpose of returning output, so the \\`output\\` array is ignored.\n\n\n\\-\\-\\-\n\\#\\#\\# Approach 3: Lexicographic (Binary Sorted) Subsets\n\n\\#\\#\\#\\# Intuition\n\nThe idea of this solution is originated from \\[Donald E. Knuth](https://www\\-cs\\-faculty.stanford.edu/\\~knuth/taocp.html).\n\n\\>The idea is that we map each subset to a bitmask of length n,\nwhere \\`1\\` on the i\\*th\\* position in bitmask means the presence of \\`nums\\[i]\\`\nin the subset, and \\`0\\` means its absence. \n\n!\\[diff](../Figures/78/bitmask4\\.png)\n\nFor instance, the bitmask \\`0\\..00\\` (all zeros) corresponds to an empty subset, \nand the bitmask \\`1\\..11\\` (all ones) corresponds to the entire input array \\`nums\\`. \n\nHence to solve the initial problem, we just need to generate n bitmasks\nfrom \\`0\\..00\\` to \\`1\\..11\\`. \n\nIt might seem simple at first glance to generate binary numbers, but \nthe real problem here is how to deal with \n\\[zero left padding](https://en.wikipedia.org/wiki/Padding\\_(cryptography)\\#Zero\\_padding),\nbecause one has to generate bitmasks of fixed length, \\_i.e.\\_ \\`001\\` and not just \\`1\\`.\nFor that one could use standard bit manipulation trick:\n\n\n\nor keep it simple stupid and shift iteration limits:\n\n\n\n\\#\\#\\#\\# Algorithm\n\n\\- Generate all possible binary bitmasks of length n.\n\n\\- Map a subset to each bitmask: \n\\`1\\` on the i\\*th\\* position in bitmask means the presence of \\`nums\\[i]\\`\nin the subset, and \\`0\\` means its absence. \n\n\\- Return output list.\n\n\\#\\#\\#\\# Implementation\n\n\n\n\\#\\#\\#\\# Complexity Analysis\n\n\\* Time complexity: $$\\\\mathcal{O}(N \\\\times 2^N)$$ to generate all subsets \nand then copy them into output list.\n \n\\* Space complexity: $$\\\\mathcal{O}(N)$$ to store the bitset\nof length $$N$$. Note that for space complexity analysis, we do not count space that is \\*only\\* used for the purpose of returning output, so the \\`output\\` array is ignored."
}