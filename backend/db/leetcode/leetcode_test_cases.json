{
  "two-sum": {
    "solution": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        num_map = {}  # Create a mapping from number to its index\n        for i, num in enumerate(nums):\n            complement = target - num  # Calculate the needed complement to reach the target\n            if complement in num_map:\n                return [num_map[complement], i]  # Found the two indices\n            num_map[num] = i  # Store the index of the current number in the map\n        return []  # If no solution is found",
    "unit_test": "import unittest\n\nclass TestSolution(unittest.TestCase):\n    def setUp(self):\n        self.solution = Solution()\n\n    def test_twoSum(self):\n        self.assertEqual(self.solution.twoSum([2, 7, 11, 15], 9), [0, 1])\n        self.assertEqual(self.solution.twoSum([3, 2, 4], 6), [1, 2])\n        self.assertEqual(self.solution.twoSum([3, 3], 6), [0, 1])\n        self.assertEqual(self.solution.twoSum([-1, -2, -3, -4, -5], -8), [2, 4])\n        self.assertEqual(self.solution.twoSum([1, 0, -1, 2, -2], 0), [0, 2])\n        self.assertEqual(self.solution.twoSum([1, 1, 2, 3], 4), [2, 3])\n        self.assertEqual(self.solution.twoSum([5, 5, 5], 10), [0, 1])\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "add-two-numbers": {
    "solution": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\n        dummy_head = ListNode(0)\n        current = dummy_head\n        carry = 0\n        \n        while l1 or l2 or carry:\n            val1 = l1.val if l1 else 0\n            val2 = l2.val if l2 else 0\n            total = val1 + val2 + carry\n            carry = total // 10\n            current.next = ListNode(total % 10)\n            current = current.next\n            if l1:\n                l1 = l1.next\n            if l2:\n                l2 = l2.next\n        \n        return dummy_head.next",
    "unit_test": "import unittest\n\nclass TestAddTwoNumbers(unittest.TestCase):\n    def list_to_linkedlist(self, lst):\n        dummy = ListNode(0)\n        current = dummy\n        for number in lst:\n            current.next = ListNode(number)\n            current = current.next\n        return dummy.next\n\n    def linkedlist_to_list(self, node):\n        lst = []\n        while node:\n            lst.append(node.val)\n            node = node.next\n        return lst\n\n    def test_add_two_numbers(self):\n        solution = Solution()\n        \n        # Test case 1:\n        l1 = self.list_to_linkedlist([2, 4, 3])\n        l2 = self.list_to_linkedlist([5, 6, 4])\n        result = solution.addTwoNumbers(l1, l2)\n        self.assertEqual(self.linkedlist_to_list(result), [7, 0, 8])\n\n        # Test case 2:\n        l1 = self.list_to_linkedlist([0])\n        l2 = self.list_to_linkedlist([0])\n        result = solution.addTwoNumbers(l1, l2)\n        self.assertEqual(self.linkedlist_to_list(result), [0])\n\n        # Test case 3:\n        l1 = self.list_to_linkedlist([9, 9, 9, 9, 9, 9, 9])\n        l2 = self.list_to_linkedlist([9, 9, 9, 9])\n        result = solution.addTwoNumbers(l1, l2)\n        self.assertEqual(self.linkedlist_to_list(result), [8, 9, 9, 9, 0, 0, 0, 1])\n\n        # Test case 4:\n        l1 = self.list_to_linkedlist([1])\n        l2 = self.list_to_linkedlist([9, 9])\n        result = solution.addTwoNumbers(l1, l2)\n        self.assertEqual(self.linkedlist_to_list(result), [0, 0, 1])\n\n        # Test case 5:\n        l1 = self.list_to_linkedlist([5])\n        l2 = self.list_to_linkedlist([5])\n        result = solution.addTwoNumbers(l1, l2)\n        self.assertEqual(self.linkedlist_to_list(result), [0, 1])\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "longest-substring-without-repeating-characters": {
    "solution": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        char_map = {}\n        left = 0\n        max_length = 0\n\n        for right in range(len(s)):\n            if s[right] in char_map:\n                left = max(left, char_map[s[right]] + 1)\n            char_map[s[right]] = right\n            max_length = max(max_length, right - left + 1)\n\n        return max_length",
    "unit_test": "import unittest\n\nclass TestLongestSubstringWithoutRepeatingCharacters(unittest.TestCase):\n    def test_lengthOfLongestSubstring(self):\n        solution = Solution()\n        self.assertEqual(solution.lengthOfLongestSubstring(\"abcabcbb\"), 3)\n        self.assertEqual(solution.lengthOfLongestSubstring(\"bbbbb\"), 1)\n        self.assertEqual(solution.lengthOfLongestSubstring(\"pwwkew\"), 3)\n        self.assertEqual(solution.lengthOfLongestSubstring(\"\"), 0)\n        self.assertEqual(solution.lengthOfLongestSubstring(\"dvdf\"), 3)\n        self.assertEqual(solution.lengthOfLongestSubstring(\"aab\"), 2)\n        self.assertEqual(solution.lengthOfLongestSubstring(\"abcdefg\"), 7)\n        self.assertEqual(solution.lengthOfLongestSubstring(\"ababcdcd\"), 4)\n        self.assertEqual(solution.lengthOfLongestSubstring(\"a\"), 1)\n        self.assertEqual(solution.lengthOfLongestSubstring(\"abcdeedcba\"), 5)  # e and d repeat\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "median-of-two-sorted-arrays": {
    "solution": "class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        # Ensure nums1 is the smaller array\n        if len(nums1) > len(nums2):\n            nums1, nums2 = nums2, nums1\n        x, y = len(nums1), len(nums2)\n        low, high = 0, x\n        while low <= high:\n            partitionX = (low + high) // 2\n            partitionY = (x + y + 1) // 2 - partitionX\n\n            maxX = float('-inf') if partitionX == 0 else nums1[partitionX - 1]\n            minX = float('inf') if partitionX == x else nums1[partitionX]\n            maxY = float('-inf') if partitionY == 0 else nums2[partitionY - 1]\n            minY = float('inf') if partitionY == y else nums2[partitionY]\n\n            if maxX <= minY and maxY <= minX:\n                # We have partitioned array at correct place\n                if (x + y) % 2 == 0:\n                    return (max(maxX, maxY) + min(minX, minY)) / 2\n                else:\n                    return max(maxX, maxY)\n            elif maxX > minY:\n                # We are too far on right side for partitionX. Go on left side.\n                high = partitionX - 1\n            else:\n                # We are too far on left side for partitionX. Go on right side.\n                low = partitionX + 1\n        raise ValueError(\"Input arrays are not sorted or are invalid\")",
    "unit_test": "import unittest\nfrom typing import List\n\nclass TestMedianOfTwoSortedArrays(unittest.TestCase):\n    def test_median_sorted_arrays(self):\n        sol = Solution()\n        # Test cases\n        self.assertEqual(sol.findMedianSortedArrays([1, 3], [2]), 2.0)\n        self.assertEqual(sol.findMedianSortedArrays([1, 2], [3, 4]), 2.5)\n        self.assertEqual(sol.findMedianSortedArrays([], [1]), 1.0)\n        self.assertEqual(sol.findMedianSortedArrays([2], []), 2.0)\n        self.assertEqual(sol.findMedianSortedArrays([1, 2], [2, 3]), 2.0)\n        self.assertEqual(sol.findMedianSortedArrays([0, 0], [0, 0]), 0.0)\n        self.assertEqual(sol.findMedianSortedArrays([], []), 0.0)  # Edge case: both arrays empty\n        self.assertEqual(sol.findMedianSortedArrays([1, 5], [2, 3]), 2.5)\n        self.assertEqual(sol.findMedianSortedArrays([1, 2, 3], [4, 5, 6, 7]), 4.0)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "longest-palindromic-substring": {
    "solution": "class Solution:\n    def longestPalindrome(self, s: str) -> str:\n        if not s:\n            return \"\"\n        start, end = 0, 0\n        for i in range(len(s)):\n            len1 = self.expandAroundCenter(s, i, i)\n            len2 = self.expandAroundCenter(s, i, i + 1)\n            maxlen = max(len1, len2)\n            if maxlen > (end - start):\n                start = i - (maxlen - 1) // 2\n                end = i + maxlen // 2\n        return s[start:end + 1]\n\n    def expandAroundCenter(self, s: str, left: int, right: int) -> int:\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return right - left - 1\n",
    "unit_test": "import unittest\n\nclass TestLongestPalindromicSubstring(unittest.TestCase):\n    def setUp(self):\n        self.solution = Solution()\n\n    def test_cases(self):\n        self.assertEqual(self.solution.longestPalindrome(\"babad\"), \"bab\")\n        self.assertEqual(self.solution.longestPalindrome(\"cbbd\"), \"bb\")\n        self.assertEqual(self.solution.longestPalindrome(\"a\"), \"a\")\n        self.assertEqual(self.solution.longestPalindrome(\"ac\"), \"a\")\n        self.assertEqual(self.solution.longestPalindrome(\"racecar\"), \"racecar\")\n        self.assertEqual(self.solution.longestPalindrome(\"\"), \"\")\n        self.assertEqual(self.solution.longestPalindrome(\"abccccdd\"), \"dccaccd\")\n        self.assertEqual(self.solution.longestPalindrome(\"aabba\"), \"aabba\")\n        self.assertEqual(self.solution.longestPalindrome(\"abcba\"), \"abcba\")\n        self.assertEqual(self.solution.longestPalindrome(\"forgeeksskeegfor\"), \"geeksskeeg\")\n\nif __name__ == \"__main__\":\n    unittest.main()"
  },
  "zigzag-conversion": {
    "solution": "class Solution:\n    def convert(self, s: str, numRows: int) -> str:\n        if numRows == 1 or numRows >= len(s):\n            return s\n        \n        rows = [''] * min(numRows, len(s))\n        cur_row = 0\n        going_down = False\n        \n        for char in s:\n            rows[cur_row] += char\n            if cur_row == 0:\n                going_down = True\n            elif cur_row == numRows - 1:\n                going_down = False\n            cur_row += 1 if going_down else -1\n        \n        return ''.join(rows)",
    "unit_test": "import unittest\n\nclass TestZigzagConversion(unittest.TestCase):\n    def test_cases(self):\n        sol = Solution()\n        \n        # Test cases\n        self.assertEqual(sol.convert(\"PAYPALISHIRING\", 3), \"PAHNAPLSIIG\")[0]\n        self.assertEqual(sol.convert(\"PAYPALISHIRING\", 4), \"PINALSIGYAHR\")[0]\n        self.assertEqual(sol.convert(\"A\", 1), \"A\")\n        self.assertEqual(sol.convert(\"AB\", 1), \"AB\")\n        self.assertEqual(sol.convert(\"ABC\", 2), \"ACB\")\n        self.assertEqual(sol.convert(\"ABCDEFG\", 3), \"AECDBF\")\n        self.assertEqual(sol.convert(\"ABCDEFGHIJKLMN\", 4), \"AGBDFHCEILJMK\")\n        self.assertEqual(sol.convert(\"\", 1), \"\")\n        self.assertEqual(sol.convert(\"HELLO\", 5), \"HELLO\")\n        self.assertEqual(sol.convert(\"THISISAZIGZAGCONVERSIONTEST\", 6), \"TNCSTOAHVIAEIRZSITEGZIT\")\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "reverse-integer": {
    "solution": "class Solution:\n    def reverse(self, x: int) -> int:\n        sign = -1 if x < 0 else 1\n        x *= sign\n        reversed_x = int(str(x)[::-1])\n        if reversed_x > 2**31 - 1:\n            return 0\n        return sign * reversed_x",
    "unit_test": "import unittest\n\nclass TestReverseInteger(unittest.TestCase):\n    def setUp(self):\n        self.solution = Solution()\n\n    def test_examples(self):\n        self.assertEqual(self.solution.reverse(123), 321)         # Example 1\n        self.assertEqual(self.solution.reverse(-123), -321)       # Example 2\n        self.assertEqual(self.solution.reverse(120), 21)          # Example 3\n\n    def test_edge_cases(self):\n        self.assertEqual(self.solution.reverse(0), 0)             # Edge case: 0\n        self.assertEqual(self.solution.reverse(100), 1)           # Edge case: leading zeros\n        self.assertEqual(self.solution.reverse(1534236469), 0)   # Edge case: overflow\n        self.assertEqual(self.solution.reverse(-1534236469), 0)  # Edge case: negative overflow\n\n    def test_single_digit(self):\n        for i in range(-9, 10):\n            self.assertEqual(self.solution.reverse(i), i)       # Single digit numbers\n\n    def test_large_numbers(self):\n        self.assertEqual(self.solution.reverse(987654321), 123456789) # Large number\n        self.assertEqual(self.solution.reverse(-987654321), -123456789) # Large negative number\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "string-to-integer-atoi": {
    "solution": "class Solution:\n    def myAtoi(self, s: str) -> int:\n        s = s.strip()  # Remove leading and trailing spaces\n        if not s:\n            return 0\n        sign = 1  # Default sign is positive\n        index = 0\n        if s[0] == '-':\n            sign = -1\n            index += 1\n        elif s[0] == '+':\n            index += 1\n        result = 0\n        while index < len(s) and s[index].isdigit():\n            digit = int(s[index])\n            # Check for overflow and underflow\n            if result > (2**31 - 1) // 10 or (result == (2**31 - 1) // 10 and digit > 7):\n                return 2**31 - 1 if sign == 1 else -2**31\n            result = result * 10 + digit\n            index += 1\n        return sign * result",
    "unit_test": "import unittest\n\nclass TestSolution(unittest.TestCase):\n    def setUp(self):\n        self.sol = Solution()\n\n    def test_myAtoi(self):\n        # Test cases from problem statement and additional cases\n        self.assertEqual(self.sol.myAtoi('42'), 42)\n        self.assertEqual(self.sol.myAtoi('   -42'), -42)\n        self.assertEqual(self.sol.myAtoi('4193 with words'), 4193)\n        self.assertEqual(self.sol.myAtoi('words and 987'), 0)\n        self.assertEqual(self.sol.myAtoi('-91283472332'), -2147483648)\n        self.assertEqual(self.sol.myAtoi('91283472332'), 2147483647)\n        self.assertEqual(self.sol.myAtoi(''), 0)\n        self.assertEqual(self.sol.myAtoi('   +0 123'), 0)\n        self.assertEqual(self.sol.myAtoi('   -0.123'), 0)\n        self.assertEqual(self.sol.myAtoi('  +1a123'), 1)\n        self.assertEqual(self.sol.myAtoi('  000123'), 123)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "palindrome-number": {
    "solution": "class Solution:\n    def isPalindrome(self, x: int) -> bool:\n        # Negative numbers are not palindromes\n        if x < 0:\n            return False\n        # Convert integer to string and compare with its reverse\n        return str(x) == str(x)[::-1]",
    "unit_test": "import unittest\n\nclass TestPalindromeNumber(unittest.TestCase):\n    def test_is_palindrome(self):\n        sol = Solution()\n        # Test cases\n        self.assertTrue(sol.isPalindrome(121))      # 121 is a palindrome\n        self.assertFalse(sol.isPalindrome(-121))    # -121 is not a palindrome\n        self.assertFalse(sol.isPalindrome(10))      # 10 is not a palindrome\n        self.assertTrue(sol.isPalindrome(12321))    # 12321 is a palindrome\n        self.assertTrue(sol.isPalindrome(0))        # 0 is a palindrome\n        self.assertFalse(sol.isPalindrome(123456))  # 123456 is not a palindrome\n        self.assertTrue(sol.isPalindrome(1001))     # 1001 is a palindrome\n        self.assertFalse(sol.isPalindrome(201))     # 201 is not a palindrome\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "regular-expression-matching": {
    "solution": "class Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)]\n        dp[0][0] = True\n\n        for j in range(1, len(p) + 1):\n            if p[j - 1] == '*':\n                dp[0][j] = dp[0][j - 2]\n\n        for i in range(1, len(s) + 1):\n            for j in range(1, len(p) + 1):\n                if p[j - 1] == s[i - 1] or p[j - 1] == '.':\n                    dp[i][j] = dp[i - 1][j - 1]\n                elif p[j - 1] == '*':\n                    dp[i][j] = dp[i][j - 2] or (dp[i - 1][j] and (s[i - 1] == p[j - 2] or p[j - 2] == '.'))\n\n        return dp[len(s)][len(p)]",
    "unit_test": "import unittest\n\nclass TestSolution(unittest.TestCase):\n    def test_isMatch(self):\n        solution = Solution()\n        self.assertTrue(solution.isMatch(\"a\", \"a\"))\n        self.assertFalse(solution.isMatch(\"a\", \"aa\"))\n        self.assertTrue(solution.isMatch(\"aa\", \"a*\"))\n        self.assertTrue(solution.isMatch(\"ab\", \".*\"))\n        self.assertFalse(solution.isMatch(\"aab\", \"c*a*b\"))\n        self.assertTrue(solution.isMatch(\"mississippi\", \"mis*is*p*.\"))\n        self.assertFalse(solution.isMatch(\"abcde\", \".*..e.*\"))\n        self.assertTrue(solution.isMatch(\"abbb\", \"ab*\"))\n        self.assertFalse(solution.isMatch(\"b\", \"*\"))\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "container-with-most-water": {
    "solution": "class Solution:\n    def maxArea(self, height: List[int]) -> int:\n        left, right = 0, len(height) - 1\n        max_area = 0\n        while left < right:\n            # Calculate area with the current left and right pointers\n            current_area = min(height[left], height[right]) * (right - left)\n            max_area = max(max_area, current_area)\n            # Move the pointer pointing to the shorter line inward\n            if height[left] < height[right]:\n                left += 1\n            else:\n                right -= 1\n        return max_area",
    "unit_test": "import unittest\nfrom typing import List\n\nclass TestMaxArea(unittest.TestCase):\n    def test_cases(self):\n        solution = Solution()\n        # Test case 1: Standard example\n        self.assertEqual(solution.maxArea([1,8,6,2,5,4,8,3,7]), 49)\n        # Test case 2: Heights are same on both sides\n        self.assertEqual(solution.maxArea([1,1]), 1)\n        # Test case 3: All heights are different\n        self.assertEqual(solution.maxArea([4,3,2,1,4]), 16)\n        # Test case 4: All heights are zeros\n        self.assertEqual(solution.maxArea([0,0,0,0]), 0)\n        # Test case 5: Descending heights\n        self.assertEqual(solution.maxArea([5,4,3,2,1]), 6)\n        # Test case 6: Ascending heights\n        self.assertEqual(solution.maxArea([1,2,3,4,5]), 6)\n        # Test case 7: Large input\n        self.assertEqual(solution.maxArea([1,2,3,4,5,6,7,8,9,10]), 25)\n        # Test case 8: Large heights with large space\n        self.assertEqual(solution.maxArea([1,100,1,100,1,1,1,1,1,100]), 100)\n        # Test case 9: Maximum area at the edges\n        self.assertEqual(solution.maxArea([2,5,1,2,4,1,3]), 8)\n        # Test case 10: Random values\n        self.assertEqual(solution.maxArea([1,3,2,5,25,24,5]), 24)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "integer-to-roman": {
    "solution": "class Solution:\n    def intToRoman(self, num: int) -> str:\n        val = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n        syms = [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"]\n        roman_num = ''\n        i = 0\n        while num > 0:\n            for _ in range(num // val[i]):\n                roman_num += syms[i]\n                num -= val[i]\n            i += 1\n        return roman_num",
    "unit_test": "import unittest\n\nclass TestIntegerToRoman(unittest.TestCase):\n\n    def setUp(self):\n        self.solution = Solution()\n\n    def test_cases(self):\n        self.assertEqual(self.solution.intToRoman(1), \"I\")\n        self.assertEqual(self.solution.intToRoman(4), \"IV\")\n        self.assertEqual(self.solution.intToRoman(9), \"IX\")\n        self.assertEqual(self.solution.intToRoman(58), \"LVIII\")\n        self.assertEqual(self.solution.intToRoman(1994), \"MCMXCIV\")\n        self.assertEqual(self.solution.intToRoman(3), \"III\")\n        self.assertEqual(self.solution.intToRoman(2023), \"MMXXIII\")\n        self.assertEqual(self.solution.intToRoman(44), \"XLIV\")\n        self.assertEqual(self.solution.intToRoman(999), \"CMXCIX\")\n        self.assertEqual(self.solution.intToRoman(1000), \"M\")\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "roman-to-integer": {
    "solution": "class Solution:\n    def romanToInt(self, s: str) -> int:\n        roman_dict = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}\n        total = 0\n        prev_value = 0\n\n        for char in reversed(s):\n            value = roman_dict[char]\n            if value < prev_value:\n                total -= value\n            else:\n                total += value\n            prev_value = value\n\n        return total",
    "unit_test": "import unittest\n\nclass TestRomanToInteger(unittest.TestCase):\n    def setUp(self):\n        self.sol = Solution()\n\n    def test_cases(self):\n        # Test cases\n        self.assertEqual(self.sol.romanToInt(\"III\"), 3)\n        self.assertEqual(self.sol.romanToInt(\"IV\"), 4)\n        self.assertEqual(self.sol.romanToInt(\"IX\"), 9)\n        self.assertEqual(self.sol.romanToInt(\"LVIII\"), 58)\n        self.assertEqual(self.sol.romanToInt(\"MCMXCIV\"), 1994)\n        # Additional test cases\n        self.assertEqual(self.sol.romanToInt(\"MMMCMXC\"), 3900)\n        self.assertEqual(self.sol.romanToInt(\"MMXXIII\"), 2023)\n        self.assertEqual(self.sol.romanToInt(\"CDXLIV\"), 444)\n        self.assertEqual(self.sol.romanToInt(\"MMMMDCCCLXXXVIII\"), 4888)\n        self.assertEqual(self.sol.romanToInt(\"XCV\"), 95)\n        self.assertEqual(self.sol.romanToInt(\"XLII\"), 42)\n        self.assertEqual(self.sol.romanToInt(\"CXXIII\"), 123)\n        self.assertEqual(self.sol.romanToInt(\"XI\"), 11)\n\nif __name__ == \"__main__\":\n    unittest.main()"
  },
  "longest-common-prefix": {
    "solution": "class Solution:\n    def longestCommonPrefix(self, strs):\n        if not strs:\n            return \"\"\n        # Start with the first string as a reference\n        prefix = strs[0]\n        for string in strs[1:]:\n            # Continuously shorten the prefix until it matches the start of the string\n            while not string.startswith(prefix):\n                prefix = prefix[:-1]\n                if not prefix:\n                    return \"\"\n        return prefix",
    "unit_test": "import unittest\n\nclass TestSolution(unittest.TestCase):\n    def setUp(self):\n        self.sol = Solution()\n\n    def test_longest_common_prefix(self):\n        self.assertEqual(self.sol.longestCommonPrefix([\"flower\", \"flow\", \"flight\"]), \"fl\")\n        self.assertEqual(self.sol.longestCommonPrefix([\"dog\", \"racecar\", \"car\"]), \"\")\n        self.assertEqual(self.sol.longestCommonPrefix([\"interspecies\", \"interstellar\", \"interstate\"]), \"inter\")\n        self.assertEqual(self.sol.longestCommonPrefix([]), \"\")\n        self.assertEqual(self.sol.longestCommonPrefix([\"single\"]), \"single\")\n        self.assertEqual(self.sol.longestCommonPrefix([\"a\", \"a\", \"a\"]), \"a\")\n        self.assertEqual(self.sol.longestCommonPrefix([\"\", \"b\", \"c\"]), \"\")\n        self.assertEqual(self.sol.longestCommonPrefix([\"abcd\", \"abef\", \"abxyz\"]), \"ab\")\n        self.assertEqual(self.sol.longestCommonPrefix([\"abc\", \"a\", \"ab\"]), \"a\")\n        self.assertEqual(self.sol.longestCommonPrefix([\"apple\", \"app\", \"apricot\"]), \"ap\")\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "3sum": {
    "solution": "class Solution:\n    def threeSum(self, nums):\n        nums.sort()  # Sort the input array\n        result = []  # This will hold the triplets\n        length = len(nums)\n\n        for i in range(length - 2):\n            # Avoid duplicates for the first number\n            if i > 0 and nums[i] == nums[i - 1]:\n                continue\n\n            left, right = i + 1, length - 1  # Left and right pointers\n            while left < right:\n                total = nums[i] + nums[left] + nums[right]\n                if total < 0:\n                    left += 1  # We need a larger sum\n                elif total > 0:\n                    right -= 1  # We need a smaller sum\n                else:\n                    result.append([nums[i], nums[left], nums[right]])  # Found a triplet\n                    # Avoid duplicates for the second number\n                    while left < right and nums[left] == nums[left + 1]:\n                        left += 1\n                    # Avoid duplicates for the third number\n                    while left < right and nums[right] == nums[right - 1]:\n                        right -= 1\n                    left += 1\n                    right -= 1\n\n        return result",
    "unit_test": "import unittest\n\nclass TestSolution(unittest.TestCase):\n    def setUp(self):\n        self.solution = Solution()\n\n    def test_threeSum(self):\n        # Test case 1\n        self.assertEqual(self.solution.threeSum([-1, 0, 1, 2, -1, -4]), [[-1, -1, 2], [-1, 0, 1]])\n        # Test case 2\n        self.assertEqual(self.solution.threeSum([]), [])\n        # Test case 3\n        self.assertEqual(self.solution.threeSum([0]), [])\n        # Test case 4\n        self.assertEqual(self.solution.threeSum([1, 2, -2, -1]), [])\n        # Test case 5\n        self.assertEqual(self.solution.threeSum([3, 0, -2, -1, 1, 2]), [[-2, -1, 3], [-2, 0, 2], [-1, 0, 1]])\n        # Test case 6 - duplicates\n        self.assertEqual(self.solution.threeSum([-2, 0, 0, 2, 2]), [[-2, 0, 2]])\n        # Test case 7 - multiple valid triplets\n        self.assertEqual(self.solution.threeSum([-1, 2, 1, -4, -2, 3]), [[-4, 1, 3], [-2, 1, 2], [-1, 0, 1]])\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "3sum-closest": {
    "solution": "class Solution:\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        closest_sum = float('inf')\n        for i in range(len(nums) - 2):\n            left, right = i + 1, len(nums) - 1\n            while left < right:\n                current_sum = nums[i] + nums[left] + nums[right]\n                if abs(current_sum - target) < abs(closest_sum - target):\n                    closest_sum = current_sum\n                if current_sum < target:\n                    left += 1\n                elif current_sum > target:\n                    right -= 1\n                else:\n                    # current_sum == target\n                    return current_sum\n        return closest_sum\n",
    "unit_test": "import unittest\n\nclass TestThreeSumClosest(unittest.TestCase):\n\n    def setUp(self):\n        self.solution = Solution()\n\n    def test_example_cases(self):\n        self.assertEqual(self.solution.threeSumClosest([-1, 2, 1, -4], 1), 2)\n        self.assertEqual(self.solution.threeSumClosest([0, 0, 0], 1), 0)\n\n    def test_negative_and_positive(self):\n        self.assertEqual(self.solution.threeSumClosest([-1, 0, 1, 1], 0), 0)\n        self.assertEqual(self.solution.threeSumClosest([-2, 0, 1, 1], 2), 2)\n        self.assertEqual(self.solution.threeSumClosest([-5, 2, -1, -4, 3], -1), -1)\n\n    def test_all_negatives(self):\n        self.assertEqual(self.solution.threeSumClosest([-5, -3, -2, -4], -10), -10)\n        self.assertEqual(self.solution.threeSumClosest([-1, -1, -1, -1], -3), -3)\n\n    def test_large_numbers(self):\n        self.assertEqual(self.solution.threeSumClosest([1000, 2000, 3000, 4000], 7000), 6000)\n        self.assertEqual(self.solution.threeSumClosest([10**6, 10**6, 10**6], 3*10**6), 3*10**6)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "letter-combinations-of-a-phone-number": {
    "solution": "class Solution:\n    def letterCombinations(self, digits: str) -> List[str]:\n        if not digits:\n            return []\n        phone_map = {\n            '2': 'abc', '3': 'def', '4': 'ghi',\n            '5': 'jkl', '6': 'mno', '7': 'pqrs',\n            '8': 'tuv', '9': 'wxyz'\n        }\n        output = ['']\n        for digit in digits:\n            temp = []\n            for combination in output:\n                for letter in phone_map[digit]:\n                    temp.append(combination + letter)\n            output = temp\n        return output\n",
    "unit_test": "import unittest\nfrom typing import List\n\nclass TestSolution(unittest.TestCase):\n    def setUp(self) -> None:\n        self.solution = Solution()\n\n    def test_letterCombinations(self):\n        self.assertEqual(sorted(self.solution.letterCombinations('23')), sorted(['ad', 'ae', 'af', 'bd', 'be', 'bf', 'cd', 'ce', 'cf']))\n        self.assertEqual(sorted(self.solution.letterCombinations('2')), sorted(['a', 'b', 'c']))\n        self.assertEqual(self.solution.letterCombinations(''), [])\n        self.assertEqual(sorted(self.solution.letterCombinations('')) , sorted([]))\n        self.assertEqual(sorted(self.solution.letterCombinations('456')), sorted(['gjm', 'gjn', 'gjo', 'gkm', 'gkn', 'gko', 'glm', 'gln', 'glo', 'hjm', 'hjn', 'hjo', 'hkm', 'hkn', 'hko', 'hlm', 'hln', 'hlo', 'ijm', 'ijn', 'ijo', 'ikm', 'ikn', 'iko', 'ilm', 'iln', 'ilo']))\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "4sum": {
    "solution": "class Solution:\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\n        nums.sort()\n        res = set()  # Use set to avoid duplicates\n        n = len(nums)\n        for i in range(n - 3):\n            for j in range(i + 1, n - 2):\n                left, right = j + 1, n - 1\n                while left < right:\n                    total = nums[i] + nums[j] + nums[left] + nums[right]\n                    if total < target:\n                        left += 1\n                    elif total > target:\n                        right -= 1\n                    else:\n                        res.add((nums[i], nums[j], nums[left], nums[right]))\n                        left += 1\n                        right -= 1\n                        # Skip duplicates for left and right\n                        while left < right and nums[left] == nums[left - 1]:\n                            left += 1\n                        while left < right and nums[right] == nums[right + 1]:\n                            right -= 1\n        return [list(r) for r in res]  # Convert set to list of lists",
    "unit_test": "import unittest\n\nclass TestSolution(unittest.TestCase):\n    def setUp(self):\n        self.solution = Solution()\n\n    def test_fourSum(self):\n        self.assertEqual(self.solution.fourSum([1, 0, -1, 0, -2, 2], 0), [[-2, -1, 0, 1], [0, 0, 0, 0]])\n        self.assertEqual(self.solution.fourSum([], 0), [])\n        self.assertEqual(self.solution.fourSum([2, 2, 2, 2], 8), [[2, 2, 2, 2]])\n        self.assertEqual(self.solution.fourSum([1, 2, 3, 4, 5], 10), [[1, 2, 3, 4]])\n        self.assertEqual(self.solution.fourSum([-1, 0, 1, 2, -1, -2, -3, 3], 0), [[-3, -2, 1, 2], [-3, 0, 0, 3], [-2, -1, 0, 1]])\n        self.assertEqual(self.solution.fourSum([0, 0, 0, 0], 0), [[0, 0, 0, 0]])\n        self.assertEqual(self.solution.fourSum([1, 2, 3, 4, 5, 6], 20), [])\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "remove-nth-node-from-end-of-list": {
    "solution": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\n        dummy = ListNode(0)\n        dummy.next = head\n        fast = slow = dummy\n\n        # Move fast pointer n + 1 steps ahead\n        for _ in range(n + 1):\n            fast = fast.next\n\n        # Move fast to the end, maintaining the gap\n        while fast:\n            slow = slow.next\n            fast = fast.next\n\n        # Remove the nth node from end\n        slow.next = slow.next.next\n\n        return dummy.next\n",
    "unit_test": "import unittest\n\nclass TestRemoveNthNodeFromEnd(unittest.TestCase):\n\n    def create_linked_list(self, values):\n        head = ListNode(values[0])\n        current = head\n        for value in values[1:]:\n            current.next = ListNode(value)\n            current = current.next\n        return head\n\n    def linked_list_to_list(self, head):\n        result = []\n        while head:\n            result.append(head.val)\n            head = head.next\n        return result\n\n    def test_remove_nth_from_end(self):\n        solution = Solution()\n\n        # Test case 1\n        head = self.create_linked_list([1, 2, 3, 4, 5])\n        n = 2\n        result_head = solution.removeNthFromEnd(head, n)\n        self.assertEqual(self.linked_list_to_list(result_head), [1, 2, 3, 5])\n\n        # Test case 2\n        head = self.create_linked_list([1])\n        n = 1\n        result_head = solution.removeNthFromEnd(head, n)\n        self.assertEqual(self.linked_list_to_list(result_head), [])\n\n        # Test case 3\n        head = self.create_linked_list([1, 2])\n        n = 1\n        result_head = solution.removeNthFromEnd(head, n)\n        self.assertEqual(self.linked_list_to_list(result_head), [1])\n\n        # Test case 4\n        head = self.create_linked_list([1, 2, 3, 4, 5])\n        n = 5\n        result_head = solution.removeNthFromEnd(head, n)\n        self.assertEqual(self.linked_list_to_list(result_head), [2, 3, 4, 5])\n\n        # Test case 5\n        head = self.create_linked_list([1, 2])\n        n = 2\n        result_head = solution.removeNthFromEnd(head, n)\n        self.assertEqual(self.linked_list_to_list(result_head), [2])\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "valid-parentheses": {
    "solution": "class Solution:\n    def isValid(self, s: str) -> bool:\n        stack = []\n        mapping = {')': '(', ']': '[', '}': '{'}\n\n        for char in s:\n            if char in mapping:\n                top_element = stack.pop() if stack else '#'\n                if mapping[char] != top_element:\n                    return False\n            else:\n                stack.append(char)\n        return not stack",
    "unit_test": "import unittest\n\nclass TestValidParentheses(unittest.TestCase):\n    def setUp(self):\n        self.solution = Solution()\n\n    def test_valid_cases(self):\n        self.assertTrue(self.solution.isValid(\"()\"))\n        self.assertTrue(self.solution.isValid(\"()[]{}\"))\n        self.assertTrue(self.solution.isValid(\"{[()]}\"))\n        self.assertTrue(self.solution.isValid(\"(())\"))\n        self.assertTrue(self.solution.isValid(\"([{}])\"))\n\n    def test_invalid_cases(self):\n        self.assertFalse(self.solution.isValid(\"(\"))\n        self.assertFalse(self.solution.isValid(\")\"))\n        self.assertFalse(self.solution.isValid(\"(]\"))\n        self.assertFalse(self.solution.isValid(\"([)]\"))\n        self.assertFalse(self.solution.isValid(\"{[]()}\"))\n        self.assertFalse(self.solution.isValid(\"((())){]\"))\n\n    def test_edge_cases(self):\n        self.assertTrue(self.solution.isValid(\"\").strip())\n        self.assertTrue(self.solution.isValid(\"()()()\"))\n        self.assertFalse(self.solution.isValid(\"((())\"))\n        self.assertFalse(self.solution.isValid(\"))))\"))\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "merge-two-sorted-lists": {
    "solution": "class Solution:\n    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:\n        dummy = ListNode(0)\n        tail = dummy\n        while l1 and l2:\n            if l1.val < l2.val:\n                tail.next = l1\n                l1 = l1.next\n            else:\n                tail.next = l2\n                l2 = l2.next\n            tail = tail.next\n        tail.next = l1 if l1 else l2\n        return dummy.next\n",
    "unit_test": "import unittest\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass TestMergeTwoSortedLists(unittest.TestCase):\n    def test_merge_two_sorted_lists(self):\n        # Helper function to convert list to ListNode\n        def list_to_listnode(nums):\n            dummy = ListNode(0)\n            current = dummy\n            for num in nums:\n                current.next = ListNode(num)\n                current = current.next\n            return dummy.next\n\n        # Helper function to convert ListNode to a list\n        def listnode_to_list(node):\n            result = []\n            while node:\n                result.append(node.val)\n                node = node.next\n            return result\n\n        # Test case 1\n        l1 = list_to_listnode([1, 2, 4])\n        l2 = list_to_listnode([1, 3, 4])\n        expected = [1, 1, 2, 3, 4, 4]\n        solution = Solution()\n        merged = solution.mergeTwoLists(l1, l2)\n        self.assertEqual(listnode_to_list(merged), expected)\n\n        # Test case 2\n        l1 = list_to_listnode([])\n        l2 = list_to_listnode([])\n        expected = []\n        merged = solution.mergeTwoLists(l1, l2)\n        self.assertEqual(listnode_to_list(merged), expected)\n\n        # Test case 3\n        l1 = list_to_listnode([])\n        l2 = list_to_listnode([0])\n        expected = [0]\n        merged = solution.mergeTwoLists(l1, l2)\n        self.assertEqual(listnode_to_list(merged), expected)\n\n        # Test case 4\n        l1 = list_to_listnode([2, 4, 6])\n        l2 = list_to_listnode([1, 3, 5])\n        expected = [1, 2, 3, 4, 5, 6]\n        merged = solution.mergeTwoLists(l1, l2)\n        self.assertEqual(listnode_to_list(merged), expected)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "generate-parentheses": {
    "solution": "class Solution:\n    def generateParenthesis(self, n: int) -> List[str]:\n        def backtrack(s='', left=0, right=0):\n            if len(s) == 2 * n:\n                result.append(s)\n                return\n            if left < n:\n                backtrack(s + '(', left + 1, right)\n            if right < left:\n                backtrack(s + ')', left, right + 1)\n\n        result = []\n        backtrack()\n        return result",
    "unit_test": "import unittest\n\nclass TestGenerateParentheses(unittest.TestCase):\n    def setUp(self):\n        self.solution = Solution()\n\n    def test_generate_parentheses(self):\n        self.assertEqual(sorted(self.solution.generateParenthesis(1)), sorted(['()']))\n        self.assertEqual(sorted(self.solution.generateParenthesis(2)), sorted(['(())', '()()']))\n        self.assertEqual(sorted(self.solution.generateParenthesis(3)), sorted(['((()))', '(()())', '(())()', '()(())', '()()()']))\n        self.assertEqual(sorted(self.solution.generateParenthesis(4)), sorted(['(((())))', '((()()))', '((())())', '((()))()', '(()(()))', '(()()())', '(()())()', '(())()', '()((()))', '()(()())', '()(())()', '()()()()']))\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "merge-k-sorted-lists": {
    "solution": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def mergeKLists(self, lists):\n        import heapq\n        min_heap = []\n        # Initialize the heap with the head of each list\n        for i in range(len(lists)):\n            if lists[i] is not None:\n                heapq.heappush(min_heap, (lists[i].val, i, lists[i]))\n\n        dummy = ListNode(0)\n        current = dummy\n\n        while min_heap:\n            val, idx, node = heapq.heappop(min_heap)\n            current.next = node\n            current = current.next\n            # If there is a next node, push it to the heap\n            if node.next:\n                heapq.heappush(min_heap, (node.next.val, idx, node.next))\n\n        return dummy.next",
    "unit_test": "import unittest\n\nclass TestMergeKSortedLists(unittest.TestCase):\n    def list_to_linkedlist(self, lst):\n        dummy = ListNode(0)\n        current = dummy\n        for value in lst:\n            current.next = ListNode(value)\n            current = current.next\n        return dummy.next\n\n    def linkedlist_to_list(self, node):\n        result = []\n        while node:\n            result.append(node.val)\n            node = node.next\n        return result\n\n    def test_merge_k_lists(self):\n        solution = Solution()\n        lists = [[1, 4, 5], [1, 3, 4], [2, 6]]\n        linked_lists = [self.list_to_linkedlist(lst) for lst in lists]\n        merged = solution.mergeKLists(linked_lists)\n        self.assertEqual(self.linkedlist_to_list(merged), [1, 1, 2, 3, 4, 4, 5, 6])\n\n        lists = [[]]\n        linked_lists = [self.list_to_linkedlist(lst) for lst in lists]\n        merged = solution.mergeKLists(linked_lists)\n        self.assertEqual(self.linkedlist_to_list(merged), [])\n\n        lists = [[], [5, 6], []]\n        linked_lists = [self.list_to_linkedlist(lst) for lst in lists]\n        merged = solution.mergeKLists(linked_lists)\n        self.assertEqual(self.linkedlist_to_list(merged), [5, 6])\n\n        lists = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n        linked_lists = [self.list_to_linkedlist(lst) for lst in lists]\n        merged = solution.mergeKLists(linked_lists)\n        self.assertEqual(self.linkedlist_to_list(merged), [1, 2, 3, 4, 5, 6, 7, 8, 9])\n\n        lists = [[-1, 5, 11], [2, 6], [], [0, 3, 4]]\n        linked_lists = [self.list_to_linkedlist(lst) for lst in lists]\n        merged = solution.mergeKLists(linked_lists)\n        self.assertEqual(self.linkedlist_to_list(merged), [-1, 0, 2, 3, 4, 5, 6, 11])\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "swap-nodes-in-pairs": {
    "solution": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        # Create a dummy node that acts as the previous node for the head\n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n\n        while prev.next and prev.next.next:\n            # Nodes to be swapped\n            first = prev.next\n            second = prev.next.next\n\n            # Performing the swap\n            first.next = second.next\n            second.next = first\n            prev.next = second\n\n            # Move to the next pair\n            prev = first\n\n        return dummy.next\n",
    "unit_test": "import unittest\n\nclass TestSwapNodesInPairs(unittest.TestCase):\n    def list_to_nodes(self, lst):\n        if not lst:\n            return None\n        head = ListNode(lst[0])\n        curr = head\n        for val in lst[1:]:\n            curr.next = ListNode(val)\n            curr = curr.next\n        return head\n\n    def nodes_to_list(self, node):\n        lst = []\n        while node:\n            lst.append(node.val)\n            node = node.next\n        return lst\n\n    def test_swap_pairs(self):\n        sol = Solution()\n        # Test cases\n        self.assertEqual(self.nodes_to_list(sol.swapPairs(self.list_to_nodes([1, 2, 3, 4]))), [2, 1, 4, 3])\n        self.assertEqual(self.nodes_to_list(sol.swapPairs(self.list_to_nodes([]))), [])\n        self.assertEqual(self.nodes_to_list(sol.swapPairs(self.list_to_nodes([1]))), [1])\n        self.assertEqual(self.nodes_to_list(sol.swapPairs(self.list_to_nodes([1, 2]))), [2, 1])\n        self.assertEqual(self.nodes_to_list(sol.swapPairs(self.list_to_nodes([1, 2, 3]))), [2, 1, 3])\n        self.assertEqual(self.nodes_to_list(sol.swapPairs(self.list_to_nodes([1, 2, 3, 4, 5]))), [2, 1, 4, 3, 5])\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "reverse-nodes-in-k-group": {
    "solution": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def reverseKGroup(self, head: ListNode, k: int) -> ListNode:\n        if head is None or k == 1:\n            return head\n\n        dummy = ListNode(0)\n        dummy.next = head\n        prev_group_end = dummy\n\n        while True:\n            kth_node = self.getKth(prev_group_end, k)\n            if not kth_node:\n                break\n            next_group_start = kth_node.next\n\n            # Reverse the current k nodes\n            prev, curr = kth_node.next, prev_group_end.next\n            for _ in range(k):\n                next_temp = curr.next\n                curr.next = prev\n                prev = curr\n                curr = next_temp\n\n            # Reconnect the reversed group\n            new_group_start = prev_group_end.next\n            prev_group_end.next = kth_node\n            new_group_start.next = next_group_start\n\n            # Move to the next group\n            prev_group_end = new_group_start\n\n        return dummy.next\n\n    def getKth(self, curr, k):\n        while curr and k:\n            curr = curr.next\n            k -= 1\n        return curr\n",
    "unit_test": "import unittest\n\nclass TestSolution(unittest.TestCase):\n    def list_to_nodes(self, lst):\n        head = ListNode(0)\n        curr = head\n        for val in lst:\n            curr.next = ListNode(val)\n            curr = curr.next\n        return head.next\n\n    def nodes_to_list(self, node):\n        lst = []\n        while node:\n            lst.append(node.val)\n            node = node.next\n        return lst\n\n    def test_reverseKGroup(self):\n        sol = Solution()\n\n        # Test case 1\n        head = self.list_to_nodes([1, 2, 3, 4, 5])\n        k = 2\n        result = sol.reverseKGroup(head, k)\n        self.assertEqual(self.nodes_to_list(result), [2, 1, 4, 3, 5])\n\n        # Test case 2\n        head = self.list_to_nodes([1, 2, 3, 4, 5])\n        k = 3\n        result = sol.reverseKGroup(head, k)\n        self.assertEqual(self.nodes_to_list(result), [3, 2, 1, 4, 5])\n\n        # Test case 3\n        head = self.list_to_nodes([1, 2, 3, 4, 5])\n        k = 1\n        result = sol.reverseKGroup(head, k)\n        self.assertEqual(self.nodes_to_list(result), [1, 2, 3, 4, 5])\n\n        # Test case 4\n        head = self.list_to_nodes([])\n        k = 3\n        result = sol.reverseKGroup(head, k)\n        self.assertEqual(self.nodes_to_list(result), [])\n\n        # Test case 5\n        head = self.list_to_nodes([1, 2, 3])\n        k = 3\n        result = sol.reverseKGroup(head, k)\n        self.assertEqual(self.nodes_to_list(result), [3, 2, 1])\n\n        # Test case 6\n        head = self.list_to_nodes([1])\n        k = 1\n        result = sol.reverseKGroup(head, k)\n        self.assertEqual(self.nodes_to_list(result), [1])\n\n        # Test case 7\n        head = self.list_to_nodes([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n        k = 4\n        result = sol.reverseKGroup(head, k)\n        self.assertEqual(self.nodes_to_list(result), [4, 3, 2, 1, 8, 7, 6, 5, 9, 10])\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "remove-duplicates-from-sorted-array": {
    "solution": "class Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        if not nums:\n            return 0\n        \n        # Initialize the counter for unique elements\n        unique_count = 1\n        \n        # Loop through the sorted array\n        for i in range(1, len(nums)):\n            # If current element is not equal to the last unique element\n            if nums[i] != nums[unique_count - 1]:\n                nums[unique_count] = nums[i]\n                unique_count += 1\n        \n        return unique_count\n",
    "unit_test": "import unittest\nfrom typing import List\n\nclass TestRemoveDuplicates(unittest.TestCase):\n    def setUp(self):\n        self.solution = Solution()\n\n    def test_remove_duplicates(self):\n        # Test case 1: basic test\n        nums1 = [1, 1, 2]\n        length1 = self.solution.removeDuplicates(nums1)\n        self.assertEqual(length1, 2)\n        self.assertEqual(nums1[:length1], [1, 2])\n\n        # Test case 2: no duplicates\n        nums2 = [1, 2, 3, 4]\n        length2 = self.solution.removeDuplicates(nums2)\n        self.assertEqual(length2, 4)\n        self.assertEqual(nums2[:length2], [1, 2, 3, 4])\n\n        # Test case 3: all duplicates\n        nums3 = [1, 1, 1, 1]\n        length3 = self.solution.removeDuplicates(nums3)\n        self.assertEqual(length3, 1)\n        self.assertEqual(nums3[:length3], [1])\n\n        # Test case 4: empty list\n        nums4 = []\n        length4 = self.solution.removeDuplicates(nums4)\n        self.assertEqual(length4, 0)\n        self.assertEqual(nums4[:length4], [])\n\n        # Test case 5: already unique\n        nums5 = [1, 2, 3]\n        length5 = self.solution.removeDuplicates(nums5)\n        self.assertEqual(length5, 3)\n        self.assertEqual(nums5[:length5], [1, 2, 3])\n\n        # Test case 6: large input\n        nums6 = list(range(1000)) * 2  # [0, 0, 1, 1, ..., 999, 999]\n        length6 = self.solution.removeDuplicates(nums6)\n        self.assertEqual(length6, 1000)\n        self.assertEqual(nums6[:length6], list(range(1000)))\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "remove-element": {
    "solution": "class Solution:\n    def removeElement(self, nums: List[int], val: int) -> int:\n        k = 0\n        for i in range(len(nums)):\n            if nums[i] != val:\n                nums[k] = nums[i]\n                k += 1\n        return k",
    "unit_test": "import unittest\nfrom typing import List\n\nclass Solution:\n    def removeElement(self, nums: List[int], val: int) -> int:\n        k = 0\n        for i in range(len(nums)):\n            if nums[i] != val:\n                nums[k] = nums[i]\n                k += 1\n        return k\n\nclass TestRemoveElement(unittest.TestCase):\n    def test_cases(self):\n        sol = Solution()\n        nums1 = [3, 2, 2, 3]\n        val1 = 3\n        self.assertEqual(sol.removeElement(nums1, val1), 2)\n        self.assertEqual(nums1[:2], [2, 2])\n\n        nums2 = [0, 1, 2, 2, 3, 0, 4, 2]\n        val2 = 2\n        self.assertEqual(sol.removeElement(nums2, val2), 5)\n        self.assertEqual(nums2[:5], [0, 1, 3, 0, 4])\n\n        nums3 = [1, 2, 3]\n        val3 = 4\n        self.assertEqual(sol.removeElement(nums3, val3), 3)\n        self.assertEqual(nums3[:3], [1, 2, 3])\n\n        nums4 = []\n        val4 = 1\n        self.assertEqual(sol.removeElement(nums4, val4), 0)\n        self.assertEqual(nums4, [])\n\n        nums5 = [5, 5, 5]\n        val5 = 5\n        self.assertEqual(sol.removeElement(nums5, val5), 0)\n        self.assertEqual(nums5, [])\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "find-the-index-of-the-first-occurrence-in-a-string": {
    "solution": "class Solution:\n    def strStr(self, haystack: str, needle: str) -> int:\n        if not needle:\n            return 0\n        return haystack.find(needle)",
    "unit_test": "import unittest\n\nclass TestSolution(unittest.TestCase):\n    def test_strStr(self):\n        sol = Solution()\n        self.assertEqual(sol.strStr('hello', 'll'), 2)\n        self.assertEqual(sol.strStr('aaaaa', 'bba'), -1)\n        self.assertEqual(sol.strStr('', ''), 0)\n        self.assertEqual(sol.strStr('abc', 'c'), 2)\n        self.assertEqual(sol.strStr('abc', 'a'), 0)\n        self.assertEqual(sol.strStr('abc', 'd'), -1)\n        self.assertEqual(sol.strStr('hello world', 'world'), 6)\n        self.assertEqual(sol.strStr('mississippi', 'issip'), 4)\n        self.assertEqual(sol.strStr(' ', ' '), 0)\n        self.assertEqual(sol.strStr('a', 'a'), 0)\n        self.assertEqual(sol.strStr('a', ''), 0)\n        self.assertEqual(sol.strStr('', 'a'), -1)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "divide-two-integers": {
    "solution": "class Solution:\n    def divide(self, dividend: int, divisor: int) -> int:\n        # Handle edge cases:\n        if dividend == 0:\n            return 0\n        if divisor == 0:\n            return (2**31 - 1)  # Division by zero is not allowed (return max int)\n        if dividend == -2**31 and divisor == -1:\n            return (2**31 - 1)  # Overflow case by returning maximum int\n\n        # Determine the sign of the quotient\n        negative = (dividend < 0) != (divisor < 0)\n\n        # Use absolute values\n        dividend, divisor = abs(dividend), abs(divisor)\n        quotient = 0\n\n        # Subtract divisor from dividend until dividend is smaller than divisor\n        while dividend >= divisor:\n            dividend -= divisor\n            quotient += 1\n\n        # Apply sign to the quotient\n        return -quotient if negative else quotient",
    "unit_test": "import unittest\n\nclass TestDivideTwoIntegers(unittest.TestCase):\n    def test_divide(self):\n        sol = Solution()\n        # Test cases\n        self.assertEqual(sol.divide(10, 2), 5)\n        self.assertEqual(sol.divide(7, -3), -2)\n        self.assertEqual(sol.divide(0, 1), 0)\n        self.assertEqual(sol.divide(1, 1), 1)\n        self.assertEqual(sol.divide(-1, -1), 1)\n        self.assertEqual(sol.divide(-2147483648, -1), 2147483647)\n        self.assertEqual(sol.divide(2147483647, 1), 2147483647)\n        self.assertEqual(sol.divide(2147483647, 2), 1073741823)\n        self.assertEqual(sol.divide(-2147483648, 2), -1073741824)\n        self.assertEqual(sol.divide(10, 3), 3)\n        self.assertEqual(sol.divide(17, 4), 4)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "substring-with-concatenation-of-all-words": {
    "solution": "class Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        if not s or not words:\n            return []\n        word_length = len(words[0])\n        word_count = len(words)\n        total_length = word_length * word_count\n        word_map = Counter(words)\n        result_indices = []\n\n        for i in range(len(s) - total_length + 1):\n            substring = s[i:i + total_length]\n            seen_words = []\n            for j in range(word_count):\n                word = substring[j * word_length:(j + 1) * word_length]\n                seen_words.append(word)\n\n            if Counter(seen_words) == word_map:\n                result_indices.append(i)\n\n        return result_indices;",
    "unit_test": "import unittest\nfrom collections import Counter\nfrom typing import List\n\nclass TestSolution(unittest.TestCase):\n    def test_findSubstring(self):\n        solution = Solution()\n        self.assertEqual(solution.findSubstring(\"barfoothefoobarman\", [\"foo\",\"bar\"]), [0, 9])\n        self.assertEqual(solution.findSubstring(\"wordgoodgoodgoodbestword\", [\"word\",\"good\",\"best\",\"word\"]), [])\n        self.assertEqual(solution.findSubstring(\"barfoofoobarthefoobarman\", [\"bar\",\"foo\",\"the\"]), [6, 9, 12])\n        self.assertEqual(solution.findSubstring(\"manmanmanman\", [\"man\"]), [0, 3, 6, 9])\n        self.assertEqual(solution.findSubstring(\"\", [\"bar\"]), [])\n        self.assertEqual(solution.findSubstring(\"barfoothefoobarman\", []), [])\n        self.assertEqual(solution.findSubstring(\"abcdabcdabcd\", [\"abc\",\"d\"]), [0, 4, 8])  \n        self.assertEqual(solution.findSubstring(\"aaaazaazaaaa\", [\"aaa\",\"aaa\"]), [])\n        self.assertEqual(solution.findSubstring(\"abababab\", [\"ab\",\"ba\"]), [0, 2, 4, 6])\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "next-permutation": {
    "solution": "class Solution:\n    def nextPermutation(self, nums: List[int]) -> None:\n        \"\"\"Do not return anything, modify nums in-place instead.\"\"\"\n        # Find the longest non-increasing suffix\n        i = len(nums) - 1\n        while i > 0 and nums[i - 1] >= nums[i]:\n            i -= 1\n\n        if i <= 0:\n            nums.reverse()\n            return\n\n        # Find the rightmost successor to the pivot\n        j = len(nums) - 1\n        while nums[j] <= nums[i - 1]:\n            j -= 1\n\n        # Swap the pivot with j\n        nums[i - 1], nums[j] = nums[j], nums[i - 1]\n\n        # Reverse the suffix\n        nums[i:] = reversed(nums[i:])",
    "unit_test": "import unittest\nfrom typing import List\n\nclass TestNextPermutation(unittest.TestCase):\n    def test_next_permutation(self):\n        sol = Solution()\n\n        # Test case 1\n        nums1 = [1, 2, 3]\n        sol.nextPermutation(nums1)\n        self.assertEqual(nums1, [1, 3, 2])\n\n        # Test case 2\n        nums2 = [3, 2, 1]\n        sol.nextPermutation(nums2)\n        self.assertEqual(nums2, [1, 2, 3])\n\n        # Test case 3\n        nums3 = [1, 1, 5]\n        sol.nextPermutation(nums3)\n        self.assertEqual(nums3, [1, 5, 1])\n\n        # Test case 4\n        nums4 = [1]\n        sol.nextPermutation(nums4)\n        self.assertEqual(nums4, [1])\n\n        # Test case 5\n        nums5 = [1, 5, 1]\n        sol.nextPermutation(nums5)\n        self.assertEqual(nums5, [5, 1, 1])\n\n        # Test case 6\n        nums6 = [2, 3, 1]\n        sol.nextPermutation(nums6)\n        self.assertEqual(nums6, [3, 1, 2])\n\n        # Test case 7: The last permutation\n        nums7 = [1, 2]\n        sol.nextPermutation(nums7)\n        self.assertEqual(nums7, [2, 1])\n\n        # Test case 8: Check with duplicate values\n        nums8 = [1, 5, 1, 5]\n        sol.nextPermutation(nums8)\n        self.assertEqual(nums8, [5, 1, 1, 5])\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "longest-valid-parentheses": {
    "solution": "class Solution:\n    def longestValidParentheses(self, s: str) -> int:\n        max_length = 0\n        stack = [-1]  # Start with -1 to handle base case for valid index\n\n        for i, char in enumerate(s):\n            if char == '(':  # Push index onto stack for '('\n                stack.append(i)\n            else:\n                stack.pop()  # Pop the last '(' index\n                if not stack:\n                    stack.append(i)  # Push the current index as the last unmatched ')'\n                else:\n                    # Calculate length of valid substring\n                    max_length = max(max_length, i - stack[-1])\n\n        return max_length\n",
    "unit_test": "import unittest\n\nclass TestLongestValidParentheses(unittest.TestCase):\n    def test_examples(self):\n        self.assertEqual(Solution().longestValidParentheses(\"(()\"), 2)\n        self.assertEqual(Solution().longestValidParentheses(\")()())\"), 4)\n        self.assertEqual(Solution().longestValidParentheses(\"\"), 0)\n        self.assertEqual(Solution().longestValidParentheses(\"()(()\"), 2)\n        self.assertEqual(Solution().longestValidParentheses(\"(())\"), 4)\n        self.assertEqual(Solution().longestValidParentheses(\")(()()))\"), 6)\n        self.assertEqual(Solution().longestValidParentheses(\")()())\"), 4)\n        self.assertEqual(Solution().longestValidParentheses(\"((()))\"), 6)\n        self.assertEqual(Solution().longestValidParentheses(\"((()()))\"), 8)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "search-in-rotated-sorted-array": {
    "solution": "class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = left + (right - left) // 2\n            if nums[mid] == target:\n                return mid\n            # Check if the left side is sorted\n            if nums[left] <= nums[mid]:\n                if nums[left] <= target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            # If the right side is sorted\n            else:\n                if nums[mid] < target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n        return -1",
    "unit_test": "import unittest\nfrom typing import List\n\nclass TestSearchInRotatedSortedArray(unittest.TestCase):\n\n    def test_cases(self):\n        sol = Solution()\n        self.assertEqual(sol.search([4,5,6,7,0,1,2], 0), 4)\n        self.assertEqual(sol.search([4,5,6,7,0,1,2], 3), -1)\n        self.assertEqual(sol.search([1], 0), -1)\n        self.assertEqual(sol.search([1, 3], 3), 1)\n        self.assertEqual(sol.search([5, 1, 3], 3), 2)\n        self.assertEqual(sol.search([1, 3, 5], 5), 2)\n        self.assertEqual(sol.search([], 1), -1)\n        self.assertEqual(sol.search([3, 1], 3), 0)\n        self.assertEqual(sol.search([1, 2, 3], 1), 0)\n        self.assertEqual(sol.search([3, 1], 1), 1)\n        self.assertEqual(sol.search([1, 3, 1, 1, 1], 3), 1)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "find-first-and-last-position-of-element-in-sorted-array": {
    "solution": "class Solution:\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\n        def findLeftIndex(nums, target):\n            left, right = 0, len(nums) - 1\n            while left <= right:\n                mid = left + (right - left) // 2\n                if nums[mid] < target:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return left\n\n        def findRightIndex(nums, target):\n            left, right = 0, len(nums) - 1\n            while left <= right:\n                mid = left + (right - left) // 2\n                if nums[mid] <= target:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return right\n\n        leftIndex = findLeftIndex(nums, target)\n        rightIndex = findRightIndex(nums, target)\n        if leftIndex <= rightIndex:\n            return [leftIndex, rightIndex]\n        else:\n            return [-1, -1]",
    "unit_test": "import unittest\n\nclass TestSolution(unittest.TestCase):\n    def test_searchRange(self):\n        solution = Solution()\n        self.assertEqual(solution.searchRange([5,7,7,8,8,10], 8), [3, 4])\n        self.assertEqual(solution.searchRange([5,7,7,8,8,10], 6), [-1, -1])\n        self.assertEqual(solution.searchRange([], 0), [-1, -1])\n        self.assertEqual(solution.searchRange([1], 1), [0, 0])\n        self.assertEqual(solution.searchRange([1, 2, 3], 2), [1, 1])\n        self.assertEqual(solution.searchRange([2, 2, 2, 2], 2), [0, 3])\n        self.assertEqual(solution.searchRange([1, 2, 2, 3], 2), [1, 2])\n        self.assertEqual(solution.searchRange([2, 2, 2], 3), [-1, -1])\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "search-insert-position": {
    "solution": "class Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = left + (right - left) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return left",
    "unit_test": "import unittest\nfrom typing import List\n\nclass Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = left + (right - left) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return left\n\nclass TestSearchInsert(unittest.TestCase):\n\n    def setUp(self):\n        self.solution = Solution()\n\n    def test_search_insert(self):\n        self.assertEqual(self.solution.searchInsert([1, 3, 5, 6], 5), 2)\n        self.assertEqual(self.solution.searchInsert([1, 3, 5, 6], 2), 1)\n        self.assertEqual(self.solution.searchInsert([1, 3, 5, 6], 7), 4)\n        self.assertEqual(self.solution.searchInsert([1, 3, 5, 6], 0), 0)\n        self.assertEqual(self.solution.searchInsert([], 1), 0)\n        self.assertEqual(self.solution.searchInsert([1], 1), 0)\n        self.assertEqual(self.solution.searchInsert([1], 0), 0)\n        self.assertEqual(self.solution.searchInsert([1], 2), 1)\n        self.assertEqual(self.solution.searchInsert([1, 2, 3, 4], 3), 2)\n        self.assertEqual(self.solution.searchInsert([1, 2, 3, 4], 5), 4)\n        self.assertEqual(self.solution.searchInsert([2, 4, 6, 8], 5), 3)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "valid-sudoku": {
    "solution": "class Solution:\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\n        rows = [{} for _ in range(9)]\n        cols = [{} for _ in range(9)]\n        boxes = [{} for _ in range(9)]\n\n        for r in range(9):\n            for c in range(9):\n                num = board[r][c]\n                if num == '.':\n                    continue\n                # Calculate the index of the 3x3 box\n                box_index = (r // 3) * 3 + (c // 3)\n                if (num in rows[r]) or (num in cols[c]) or (num in boxes[box_index]):\n                    return False\n                rows[r][num] = True\n                cols[c][num] = True\n                boxes[box_index][num] = True\n        return True\n",
    "unit_test": "import unittest\nfrom typing import List\n\nclass TestSolution(unittest.TestCase):\n    def setUp(self):\n        self.solution = Solution()\n\n    def test_isValidSudoku(self):\n        # Test case 1: Valid Sudoku\n        board1 = [\n            [\"5\", \"3\", \".\", \".\", \"7\", \".\", \".\", \".\", \".\"],\n            [\"6\", \".\", \".\", \"1\", \"9\", \"5\", \".\", \".\", \".\"],\n            [\".\", \"9\", \"8\", \".\", \".\", \".\", \".\", \"6\", \".\"],\n            [\"8\", \".\", \".\", \".\", \"6\", \".\", \".\", \".\", \"3\"],\n            [\"4\", \".\", \".\", \"8\", \".\", \"3\", \".\", \".\", \"1\"],\n            [\"7\", \".\", \".\", \".\", \"2\", \".\", \".\", \".\", \"6\"],\n            [\".\", \"6\", \".\", \".\", \".\", \"2\", \"8\", \".\", \".\"],\n            [\".\", \".\", \".\", \"4\", \"1\", \"9\", \".\", \".\", \"5\"],\n            [\".\", \".\", \".\", \".\", \"8\", \".\", \".\", \"7\", \"9\"]\n        ]\n        self.assertTrue(self.solution.isValidSudoku(board1))\n\n        # Test case 2: Invalid Sudoku (Row)\n        board2 = [\n            [\"8\", \"3\", \".\", \".\", \"7\", \".\", \".\", \".\", \".\"],\n            [\"6\", \".\", \".\", \"1\", \"9\", \"5\", \".\", \".\", \".\"],\n            [\".\", \"9\", \"8\", \".\", \".\", \".\", \".\", \"6\", \".\"],\n            [\"8\", \".\", \".\", \".\", \"6\", \".\", \".\", \".\", \"3\"],\n            [\"4\", \".\", \".\", \"8\", \".\", \"3\", \".\", \".\", \"1\"],\n            [\"7\", \".\", \".\", \".\", \"2\", \".\", \".\", \".\", \"6\"],\n            [\".\", \"6\", \".\", \".\", \".\", \"2\", \"8\", \".\", \".\"],\n            [\".\", \".\", \".\", \"4\", \"1\", \"9\", \".\", \".\", \"5\"],\n            [\".\", \".\", \".\", \".\", \"8\", \".\", \".\", \"7\", \"9\"]\n        ]\n        self.assertFalse(self.solution.isValidSudoku(board2))\n\n        # Test case 3: Invalid Sudoku (Column)\n        board3 = [\n            [\"5\", \"3\", \".\", \".\", \"7\", \".\", \".\", \".\", \".\"],\n            [\"6\", \".\", \".\", \"1\", \"9\", \"5\", \".\", \".\", \".\"],\n            [\".\", \"9\", \"8\", \".\", \".\", \".\", \".\", \"6\", \".\"],\n            [\"8\", \".\", \".\", \".\", \"6\", \".\", \".\", \".\", \"3\"],\n            [\"4\", \".\", \".\", \"8\", \".\", \"3\", \".\", \".\", \"1\"],\n            [\"7\", \".\", \".\", \".\", \"2\", \".\", \".\", \".\", \"6\"],\n            [\"9\", \"6\", \".\", \".\", \".\", \"2\", \"8\", \".\", \".\"],\n            [\".\", \".\", \".\", \"4\", \"1\", \"9\", \".\", \".\", \"5\"],\n            [\".\", \".\", \".\", \".\", \"8\", \".\", \".\", \"7\", \"9\"]\n        ]\n        self.assertFalse(self.solution.isValidSudoku(board3))\n\n        # Test case 4: Invalid Sudoku (Box)\n        board4 = [\n            [\"5\", \"3\", \"5\", \".\", \"7\", \".\", \".\", \".\", \".\"],\n            [\"6\", \".\", \".\", \"1\", \"9\", \"5\", \".\", \".\", \".\"],\n            [\".\", \"9\", \"8\", \".\", \".\", \".\", \".\", \"6\", \".\"],\n            [\"8\", \".\", \".\", \".\", \"6\", \".\", \".\", \".\", \"3\"],\n            [\"4\", \".\", \".\", \"8\", \".\", \"3\", \".\", \".\", \"1\"],\n            [\"7\", \".\", \".\", \".\", \"2\", \".\", \".\", \".\", \"6\"],\n            [\".\", \"6\", \".\", \".\", \".\", \"2\", \"8\", \".\", \".\"],\n            [\".\", \".\", \".\", \"4\", \"1\", \"9\", \".\", \".\", \"5\"],\n            [\".\", \".\", \".\", \".\", \"8\", \".\", \".\", \"7\", \"9\"]\n        ]\n        self.assertFalse(self.solution.isValidSudoku(board4))\n\n        # Test case 5: Empty Sudoku (All dots)\n        board5 = [\n            [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\n            [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\n            [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\n            [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\n            [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\n            [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\n            [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\n            [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\n            [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\n        ]\n        self.assertTrue(self.solution.isValidSudoku(board5))\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "sudoku-solver": {
    "solution": "class Solution:\n    def solveSudoku(self, board: List[List[str]]) -> None:\n        def is_valid(board, row, col, num):\n            for i in range(9):\n                if board[row][i] == num:\n                    return False\n                if board[i][col] == num:\n                    return False\n                if board[3 * (row // 3) + i // 3][3 * (col // 3) + i % 3] == num:\n                    return False\n            return True\n\n        def solve(board):\n            for i in range(9):\n                for j in range(9):\n                    if board[i][j] == '.':\n                        for num in map(str, range(1, 10)):\n                            if is_valid(board, i, j, num):\n                                board[i][j] = num\n                                if solve(board):\n                                    return True\n                                board[i][j] = '.'\n                        return False\n            return True\n\n        solve(board)",
    "unit_test": "import unittest\n\nclass TestSudokuSolver(unittest.TestCase):\n    def test_solveSudoku(self):\n        sol = Solution()\n        board1 = [\n            ['5', '3', '.', '.', '7', '.', '.', '.', '.'],\n            ['6', '.', '.', '1', '9', '5', '.', '.', '.'],\n            ['.', '9', '8', '.', '.', '.', '.', '6', '.'],\n            ['8', '.', '.', '.', '6', '.', '.', '.', '3'],\n            ['4', '.', '9', '8', '.', '3', '.', '.', '1'],\n            ['7', '.', '.', '.', '2', '.', '.', '.', '6'],\n            ['.', '6', '.', '.', '.', '.', '2', '8', '.'],\n            ['.', '.', '.', '4', '1', '9', '.', '.', '5'],\n            ['.', '.', '.', '.', '8', '.', '.', '7', '9']\n        ]\n        expected1 = [\n            ['5', '3', '4', '6', '7', '8', '9', '1', '2'],\n            ['6', '7', '2', '1', '9', '5', '3', '4', '8'],\n            ['1', '9', '8', '3', '4', '2', '5', '6', '7'],\n            ['8', '5', '9', '7', '6', '1', '4', '2', '3'],\n            ['4', '2', '6', '8', '5', '3', '7', '9', '1'],\n            ['7', '1', '3', '9', '2', '4', '8', '5', '6'],\n            ['9', '6', '1', '5', '3', '7', '2', '8', '4'],\n            ['2', '8', '7', '4', '1', '9', '6', '3', '5'],\n            ['3', '4', '5', '2', '8', '6', '1', '7', '9']\n        ]\n        sol.solveSudoku(board1)\n        self.assertEqual(board1, expected1)\n\n        board2 = [\n            ['.', '.', '.', '3', '.', '.', '8', '9', '.'],\n            ['.', '6', '5', '.', '7', '4', '1', '.', '.'],\n            ['.', '8', '.', '2', '.', '.', '4', '3', '6'],\n            ['8', '2', '.', '.', '.', '.', '.', '7', '9'],\n            ['7', '.', '.', '.', '3', '8', '.', '.', '1'],\n            ['.', '3', '9', '5', '.', '.', '2', '.', '8'],\n            ['6', '.', '3', '.', '.', '2', '5', '1', '.'],\n            ['.', '.', '1', '8', '4', '.', '6', '2', '3'],\n            ['.', '9', '.', '6', '2', '1', '.', '5', '.']\n        ]\n        expected2 = [\n            ['4', '1', '2', '3', '6', '5', '8', '9', '7'],\n            ['3', '6', '5', '9', '7', '4', '1', '8', '2'],\n            ['9', '8', '7', '2', '1', '8', '4', '3', '6'],\n            ['8', '2', '4', '1', '5', '6', '3', '7', '9'],\n            ['7', '5', '6', '4', '3', '8', '9', '7', '1'],\n            ['1', '3', '9', '5', '2', '7', '2', '4', '8'],\n            ['6', '7', '3', '4', '8', '2', '5', '1', '9'],\n            ['2', '4', '1', '8', '5', '9', '6', '2', '3'],\n            ['5', '9', '8', '6', '2', '1', '7', '5', '4']\n        ]\n        sol.solveSudoku(board2)\n        self.assertEqual(board2, expected2)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "count-and-say": {
    "solution": "class Solution:\n    def countAndSay(self, n: int) -> str:\n        if n == 1:\n            return \"1\"\n        previous = self.countAndSay(n - 1)\n        count = 1\n        result = \"\"\n\n        for i in range(1, len(previous)):\n            if previous[i] == previous[i - 1]:\n                count += 1\n            else:\n                result += str(count) + previous[i - 1]\n                count = 1\n        result += str(count) + previous[-1]\n        return result\n",
    "unit_test": "import unittest\n\nclass TestCountAndSay(unittest.TestCase):\n    def setUp(self):\n        self.solution = Solution()\n\n    def test_count_and_say(self):\n        self.assertEqual(self.solution.countAndSay(1), \"1\")\n        self.assertEqual(self.solution.countAndSay(2), \"11\")\n        self.assertEqual(self.solution.countAndSay(3), \"21\")\n        self.assertEqual(self.solution.countAndSay(4), \"1211\")\n        self.assertEqual(self.solution.countAndSay(5), \"111221\")\n        self.assertEqual(self.solution.countAndSay(6), \"312211\")\n        self.assertEqual(self.solution.countAndSay(7), \"13112221\")\n        self.assertEqual(self.solution.countAndSay(8), \"1113213211\")\n        self.assertEqual(self.solution.countAndSay(9), \"31131211131221\")\n        self.assertEqual(self.solution.countAndSay(10), \"13211311123113112211\")\n\nif __name__ == \"__main__\":\n    unittest.main()"
  },
  "combination-sum": {
    "solution": "class Solution:\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n        def backtrack(start, path, target):\n            if target == 0:\n                result.append(path)\n                return\n            if target < 0:\n                return\n            for i in range(start, len(candidates)):\n                backtrack(i, path + [candidates[i]], target - candidates[i])\n\n        result = []\n        backtrack(0, [], target)\n        return result\n",
    "unit_test": "import unittest\nfrom typing import List\n\nclass TestCombinationSum(unittest.TestCase):\n\n    def test_combination_sum(self):\n        s = Solution()\n        self.assertEqual(sorted(s.combinationSum([2, 3, 6, 7], 7)), sorted([[7], [2, 2, 3]]))\n        self.assertEqual(sorted(s.combinationSum([2, 3, 5], 8)), sorted([[2, 2, 2, 2], [2, 3, 3], [3, 5]]))\n        self.assertEqual(s.combinationSum([1], 2), [[1, 1]])\n        self.assertEqual(s.combinationSum([1], 0), [[]])\n        self.assertEqual(s.combinationSum([2], 3), [])\n        self.assertEqual(s.combinationSum([], 7), [])\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "combination-sum-ii": {
    "solution": "class Solution:\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\n        candidates.sort()\n        results = []\n        self.backtrack(candidates, target, 0, [], results)\n        return results\n\n    def backtrack(self, candidates, target, start, path, results):\n        if target == 0:\n            results.append(path)\n            return\n        if target < 0:\n            return\n\n        for i in range(start, len(candidates)):\n            if i > start and candidates[i] == candidates[i - 1]:\n                continue  # skip duplicates\n            self.backtrack(candidates, target - candidates[i], i + 1, path + [candidates[i]], results)",
    "unit_test": "import unittest\nfrom typing import List\n\nclass TestSolution(unittest.TestCase):\n    def setUp(self):\n        self.solution = Solution()\n\n    def test_combinationSum2(self):\n        # Test case 1\n        self.assertEqual(self.solution.combinationSum2([10,1,2,7,6,1,5], 8), [[1,1,6],[1,2,5],[6,2],[7,1]])\n        # Test case 2\n        self.assertEqual(self.solution.combinationSum2([1,1,1,1], 2), [[1,1]])\n        # Test case 3\n        self.assertEqual(self.solution.combinationSum2([2,5,2,1,2], 5), [[1,2,2],[5]])\n        # Test case 4\n        self.assertEqual(self.solution.combinationSum2([1,2,3,4], 6), [[1,2,3],[2,4]])\n        # Test case 5\n        self.assertEqual(self.solution.combinationSum2([], 5), [])\n        # Test case 6\n        self.assertEqual(self.solution.combinationSum2([1,2,3], 0), [[]])  # target is 0\n        # Edge case with negative numbers\n        self.assertEqual(self.solution.combinationSum2([-1, 0, 1], 0), [[0]])\n        # Edge case with all elements the same\n        self.assertEqual(self.solution.combinationSum2([2, 2, 2], 4), [[2, 2]])\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "first-missing-positive": {
    "solution": "class Solution:\n    def firstMissingPositive(self, nums):\n        n = len(nums)\n        for i in range(n):\n            while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:\n                # Swap nums[i] with nums[nums[i] - 1]\n                nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]\n\n        for i in range(n):\n            if nums[i] != i + 1:\n                return i + 1\n\n        return n + 1",
    "unit_test": "import unittest\n\nclass TestSolution(unittest.TestCase):\n    def test_firstMissingPositive(self):\n        solution = Solution()\n        self.assertEqual(solution.firstMissingPositive([1, 2, 0]), 3)\n        self.assertEqual(solution.firstMissingPositive([3, 4, -1, 1]), 2)\n        self.assertEqual(solution.firstMissingPositive([7, 8, 9, 11, 12]), 1)\n        self.assertEqual(solution.firstMissingPositive([1, 1]), 2)\n        self.assertEqual(solution.firstMissingPositive([]), 1)\n        self.assertEqual(solution.firstMissingPositive([2]), 1)\n        self.assertEqual(solution.firstMissingPositive([1]), 2)\n        self.assertEqual(solution.firstMissingPositive([5, 4, 3, 2, 1]), 6)\n        self.assertEqual(solution.firstMissingPositive([-1, -2, -3]), 1)\n        self.assertEqual(solution.firstMissingPositive([-1, 0, 1, 2]), 3)\n        self.assertEqual(solution.firstMissingPositive([0, 1, 2]), 3)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "trapping-rain-water": {
    "solution": "class Solution:\n    def trap(self, height):\n        if not height:\n            return 0\n        left, right = 0, len(height) - 1\n        left_max, right_max = height[left], height[right]\n        trapped_water = 0\n\n        while left < right:\n            if height[left] < height[right]:\n                left += 1\n                left_max = max(left_max, height[left])\n                trapped_water += left_max - height[left]\n            else:\n                right -= 1\n                right_max = max(right_max, height[right])\n                trapped_water += right_max - height[right]\n\n        return trapped_water",
    "unit_test": "import unittest\n\nclass TestTrappingRainWater(unittest.TestCase):\n    def test_trap(self):\n        solution = Solution()\n        # Test cases\n        self.assertEqual(solution.trap([0,1,0,2,1,0,1,3,2,1,2,1]), 6)\n        self.assertEqual(solution.trap([4,2,0,3,2,5]), 9)\n        self.assertEqual(solution.trap([1,0,2]), 1)\n        self.assertEqual(solution.trap([0,1,0,0,1,0,0]), 0)\n        self.assertEqual(solution.trap([]), 0)\n        self.assertEqual(solution.trap([2,0,2]), 2)\n        self.assertEqual(solution.trap([3,1,3,2,5]), 6)\n        self.assertEqual(solution.trap([0,2,0]), 0)\n        self.assertEqual(solution.trap([2, 0, 2, 0, 2]), 4)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "multiply-strings": {
    "solution": "class Solution:\n    def multiply(self, num1: str, num2: str) -> str:\n        if num1 == '0' or num2 == '0':\n            return '0'\n\n        # Result can be at most len(num1) + len(num2)\n        result = [0] * (len(num1) + len(num2))\n        \n        # Reverse both numbers for easier indexing\n        num1 = num1[::-1]\n        num2 = num2[::-1]\n        \n        # Multiply each digit and add to the result array\n        for i in range(len(num1)):\n            for j in range(len(num2)):\n                product = (ord(num1[i]) - ord('0')) * (ord(num2[j]) - ord('0'))\n                result[i + j] += product\n                # Handle carry\n                result[i + j + 1] += result[i + j] // 10\n                result[i + j] %= 10\n        \n        # Remove leading zeros and convert result to string\n        while len(result) > 1 and result[-1] == 0:\n            result.pop()\n        \n        return ''.join(str(x) for x in result[::-1])",
    "unit_test": "import unittest\n\nclass TestMultiplyStrings(unittest.TestCase):\n    def test_multiply(self):\n        solution = Solution()\n        self.assertEqual(solution.multiply('2', '3'), '6')\n        self.assertEqual(solution.multiply('123', '456'), '56088')\n        self.assertEqual(solution.multiply('0', '5'), '0')\n        self.assertEqual(solution.multiply('5', '0'), '0')\n        self.assertEqual(solution.multiply('0', '0'), '0')\n        self.assertEqual(solution.multiply('2', '9000'), '18000')\n        self.assertEqual(solution.multiply('100', '1000'), '100000')\n        self.assertEqual(solution.multiply('12345', '6789'), '83810205')\n        self.assertEqual(solution.multiply('999999', '999999'), '999998000001')\n        self.assertEqual(solution.multiply('1', '1'), '1')\n        self.assertEqual(solution.multiply('123456789', '987654321'), '121932631112635269')\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "wildcard-matching": {
    "solution": "class Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)]\n        dp[0][0] = True  # Empty string and empty pattern match\n\n        # Fill the first row for patterns with '*' allowing them to match empty string\n        for j in range(1, len(p) + 1):\n            if p[j - 1] == '*':\n                dp[0][j] = dp[0][j - 1]\n\n        for i in range(1, len(s) + 1):\n            for j in range(1, len(p) + 1):\n                if p[j - 1] == s[i - 1] or p[j - 1] == '?':\n                    dp[i][j] = dp[i - 1][j - 1]\n                elif p[j - 1] == '*':\n                    dp[i][j] = dp[i - 1][j] or dp[i][j - 1]\n\n        return dp[len(s)][len(p)]\n",
    "unit_test": "import unittest\n\nclass TestWildcardMatching(unittest.TestCase):\n    def setUp(self):\n        self.solution = Solution()\n\n    def test_isMatch(self):\n        self.assertTrue(self.solution.isMatch(\"aa\", \"a*\"))\n        self.assertFalse(self.solution.isMatch(\"aa\", \"a\"))\n        self.assertTrue(self.solution.isMatch(\"abcd\", \"a*d\"))\n        self.assertTrue(self.solution.isMatch(\"adceb\", \"*a*b\"))\n        self.assertFalse(self.solution.isMatch(\"acdcb\", \"a*c?b\"))\n        self.assertTrue(self.solution.isMatch(\"\", \"*\"))\n        self.assertFalse(self.solution.isMatch(\"\", \"a*\"))\n        self.assertTrue(self.solution.isMatch(\"xaylmz\", \"*a*b*\"))\n        self.assertFalse(self.solution.isMatch(\"mississippi\", \"m??*ss*?i*pi\"))\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "jump-game-ii": {
    "solution": "class Solution:\n    def jump(self, nums: List[int]) -> int:\n        n = len(nums)\n        if n == 1:\n            return 0\n\n        jumps = 0\n        current_end = 0\n        farthest = 0\n\n        for i in range(n - 1):\n            farthest = max(farthest, i + nums[i])\n            if i == current_end:\n                jumps += 1\n                current_end = farthest\n\n        return jumps",
    "unit_test": "import unittest\n\nclass TestJumpGameII(unittest.TestCase):\n    def test_jump(self):\n        sol = Solution()\n        # Test cases\n        self.assertEqual(sol.jump([2,3,1,1,4]), 2)\n        self.assertEqual(sol.jump([2,3,0,1,4]), 2)\n        self.assertEqual(sol.jump([0]), 0)\n        self.assertEqual(sol.jump([1, 2]), 1)\n        self.assertEqual(sol.jump([1, 2, 3]), 2)\n        self.assertEqual(sol.jump([1, 1, 1, 1, 1]), 4)\n        self.assertEqual(sol.jump([5, 4, 3, 2, 1]), 1)\n        self.assertEqual(sol.jump([1, 2, 3, 4, 5]), 4)\n        self.assertEqual(sol.jump([2, 1]), 1)\n        self.assertEqual(sol.jump([10, 1, 1, 1, 1, 1]), 1)\n        self.assertEqual(sol.jump([1, 3, 5, 8, 9, 2, 6, 7, 6, 8, 9]), 3)\n\nif __name__ == \"__main__\":\n    unittest.main()"
  },
  "permutations": {
    "solution": "from typing import List\n\nclass Solution:\n    def permute(self, nums: List[int]) -> List[List[int]]:\n        def backtrack(start: int):\n            if start == len(nums):\n                res.append(nums[:])\n                return\n            for i in range(start, len(nums)):\n                nums[start], nums[i] = nums[i], nums[start]  # Swap\n                backtrack(start + 1)\n                nums[start], nums[i] = nums[i], nums[start]  # Backtrack\n\n        res = []\n        backtrack(0)\n        return res\n",
    "unit_test": "import unittest\n\nclass TestSolution(unittest.TestCase):\n    def test_permute(self):\n        solution = Solution()\n        self.assertEqual(sorted(solution.permute([1, 2, 3])), sorted([[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]))\n        self.assertEqual(sorted(solution.permute([0, 1])), sorted([[0, 1], [1, 0]]))\n        self.assertEqual(sorted(solution.permute([1])), sorted([[1]]))\n        self.assertEqual(sorted(solution.permute([])), sorted([[]]))  # Edge case: empty list\n        self.assertEqual(sorted(solution.permute([1, 1, 2])), sorted([[1, 1, 2], [1, 2, 1], [2, 1, 1]]))  # Test with duplicates\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "permutations-ii": {
    "solution": "class Solution:\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\n        def backtrack(start):\n            if start == len(nums):\n                res.append(nums[:])\n                return\n            seen = set()\n            for i in range(start, len(nums)):\n                if nums[i] in seen:\n                    continue\n                seen.add(nums[i])\n                nums[start], nums[i] = nums[i], nums[start]\n                backtrack(start + 1)\n                nums[start], nums[i] = nums[i], nums[start]\n\n        res = []\n        nums.sort()\n        backtrack(0)\n        return res\n",
    "unit_test": "import unittest\nfrom typing import List\n\nclass TestPermutationsII(unittest.TestCase):\n    def test_permuteUnique(self):\n        solution = Solution()\n        # Test cases\n        self.assertEqual(sorted(solution.permuteUnique([1, 1, 2])), sorted([[1, 1, 2], [1, 2, 1], [2, 1, 1]]))\n        self.assertEqual(sorted(solution.permuteUnique([1, 2, 3])), sorted([[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]))\n        self.assertEqual(sorted(solution.permuteUnique([])), sorted([[]]))\n        self.assertEqual(sorted(solution.permuteUnique([1])), sorted([[1]]))\n        self.assertEqual(sorted(solution.permuteUnique([1, 1, 1, 1])), sorted([[1, 1, 1, 1]]))\n        self.assertEqual(sorted(solution.permuteUnique([1, 2, 2, 3])), sorted([[1, 2, 2, 3], [1, 2, 3, 2], [1, 3, 2, 2], [2, 1, 2, 3], [2, 1, 3, 2], [2, 2, 1, 3], [2, 2, 3, 1], [2, 3, 1, 2], [2, 3, 2, 1], [3, 1, 2, 2], [3, 2, 1, 2], [3, 2, 2, 1]]))\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "rotate-image": {
    "solution": "class Solution:\n    def rotate(self, matrix):\n        n = len(matrix)\n        # Transpose the matrix\n        for i in range(n):\n            for j in range(i, n):\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n        # Reverse each row\n        for i in range(n):\n            matrix[i].reverse()",
    "unit_test": "import unittest\n\nclass TestRotateImage(unittest.TestCase):\n    def test_rotate(self):\n        sol = Solution()\n        matrix1 = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n        sol.rotate(matrix1)\n        self.assertEqual(matrix1, [[7, 4, 1], [8, 5, 2], [9, 6, 3]])\n\n        matrix2 = [[5, 1, 9, 11], [2, 4, 8, 10], [13, 3, 6, 7], [15, 14, 12, 16]]\n        sol.rotate(matrix2)\n        self.assertEqual(matrix2, [[15, 13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7, 10, 11]])\n\n        matrix3 = [[1]]\n        sol.rotate(matrix3)\n        self.assertEqual(matrix3, [[1]])\n\n        matrix4 = [[1, 2], [3, 4]]\n        sol.rotate(matrix4)\n        self.assertEqual(matrix4, [[3, 1], [4, 2]])\n\n        matrix5 = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]\n        sol.rotate(matrix5)\n        self.assertEqual(matrix5, [[13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4]])\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "group-anagrams": {
    "solution": "class Solution:\n    def groupAnagrams(self, strs):\n        anagrams = {}\n        for s in strs:\n            # Sort the string and use it as a key\n            key = ''.join(sorted(s))\n            if key in anagrams:\n                anagrams[key].append(s)\n            else:\n                anagrams[key] = [s]\n        return list(anagrams.values())",
    "unit_test": "import unittest\n\nclass TestGroupAnagrams(unittest.TestCase):\n    def test_group_anagrams(self):\n        solution = Solution()\n        self.assertEqual(solution.groupAnagrams([\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]), sorted([[\"bat\"], [\"nat\", \"tan\"], [\"ate\", \"eat\", \"tea\"]]))\n        self.assertEqual(solution.groupAnagrams([\"listen\", \"silent\", \"enlist\", \"inlets\", \"google\", \"glooge\"]), sorted([[\"google\", \"glooge\"], [\"listen\", \"silent\", \"enlist\", \"inlets\"]]))\n        self.assertEqual(solution.groupAnagrams([\"\", \"b\", \"a\", \"ab\", \"ba\", \"a\"]), sorted([[\"a\"], [\"b\"], [\"ab\", \"ba\"]]))\n        self.assertEqual(solution.groupAnagrams([\"abcd\", \"dcba\", \"bcda\", \"abcd\"]), sorted([[\"abcd\", \"abcd\"], [\"bcda\", \"dcba\"]]))\n        self.assertEqual(solution.groupAnagrams([\"apple\", \"pale\", \"plea\", \"peal\", \"leap\"]), sorted([[\"apple\"], [\"leap\", \"peal\", \"plea\", \"pale\"]]))\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "powx-n": {
    "solution": "class Solution:\n    def myPow(self, x: float, n: int) -> float:\n        if n == 0:\n            return 1\n        if n < 0:\n            x = 1 / x\n            n = -n\n        result = 1\n        while n:\n            if n % 2:\n                result *= x\n            x *= x\n            n //= 2\n        return result",
    "unit_test": "import unittest\n\nclass TestSolution(unittest.TestCase):\n    def test_myPow(self):\n        sol = Solution()\n        # Test case 1: Basic case\n        self.assertEqual(sol.myPow(2.0, 10), 1024.0)\n        # Test case 2: Case with negative exponent\n        self.assertEqual(sol.myPow(2.0, -2), 0.25)\n        # Test case 3: Base is 1\n        self.assertEqual(sol.myPow(1.0, 10), 1.0)\n        # Test case 4: Base is 0.5 and exponent is 3\n        self.assertEqual(sol.myPow(0.5, 3), 0.125)\n        # Test case 5: Exponent is 0\n        self.assertEqual(sol.myPow(10.0, 0), 1.0)\n        # Test case 6: Negative base with even exponent\n        self.assertEqual(sol.myPow(-2.0, 4), 16.0)\n        # Test case 7: Negative base with odd exponent\n        self.assertEqual(sol.myPow(-2.0, 3), -8.0)\n        # Test case 8: Very large exponent\n        self.assertEqual(sol.myPow(2.0, 30), 1073741824.0)\n        # Test case 9: Very negative exponent\n        self.assertEqual(sol.myPow(2.0, -30), 1/1073741824.0)\n        # Test case 10: Base case with 0\n        self.assertEqual(sol.myPow(0.0, 5), 0.0)  \n        # Test case 11: Edge case: 0 raised to a negative power\n        with self.assertRaises(ZeroDivisionError):\n            sol.myPow(0.0, -1)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "n-queens": {
    "solution": "class Solution:\n    def solveNQueens(self, n: int) -> List[List[str]]:\n        def backtrack(row):\n            if row == n:\n                result.append([''.join(board[i]) for i in range(n)])\n                return\n            for col in range(n):\n                if col not in cols and (row - col) not in diag1 and (row + col) not in diag2:\n                    board[row][col] = 'Q'\n                    cols.add(col)\n                    diag1.add(row - col)\n                    diag2.add(row + col)\n                    backtrack(row + 1)\n                    board[row][col] = '.'\n                    cols.remove(col)\n                    diag1.remove(row - col)\n                    diag2.remove(row + col)\n\n        result = []\n        board = [['.'] * n for _ in range(n)]\n        cols = set()\n        diag1 = set()\n        diag2 = set()\n        backtrack(0)\n        return result\n",
    "unit_test": "import unittest\n\nclass TestNQueens(unittest.TestCase):\n    def test_solve_n_queens(self):\n        solution = Solution()\n        # Test case 1: n = 1\n        self.assertEqual(solution.solveNQueens(1), [['Q']])\n        # Test case 2: n = 4\n        result = solution.solveNQueens(4)\n        expected = [['.Q..',  \n                     '...Q',  \n                     'Q...',  \n                     '..Q.'], \n                    ['..Q.',  \n                     'Q...',  \n                     '...Q',  \n                     '.Q..']]\n        self.assertEqual(sorted(result), sorted(expected))\n        # Test case 3: n = 2 (no solutions)\n        self.assertEqual(solution.solveNQueens(2), [])\n        # Test case 4: n = 3 (no solutions)\n        self.assertEqual(solution.solveNQueens(3), [])\n        # Test case 5: n = 5\n        result = solution.solveNQueens(5)\n        self.assertTrue(len(result) > 0)  # There should be solutions \n        # Test case 6: n = 8\n        result = solution.solveNQueens(8)\n        self.assertTrue(len(result) > 0)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "n-queens-ii": {
    "solution": "class Solution:\n    def totalNQueens(self, n: int) -> int:\n        def is_not_under_attack(row, col):\n            return col not in cols and (row - col) not in diagonal1 and (row + col) not in diagonal2\n\n        def place_queen(row, col):\n            cols.add(col)\n            diagonal1.add(row - col)\n            diagonal2.add(row + col)\n\n        def remove_queen(row, col):\n            cols.remove(col)\n            diagonal1.remove(row - col)\n            diagonal2.remove(row + col)\n\n        def backtrack(row):\n            if row == n:\n                nonlocal count\n                count += 1\n                return\n            for col in range(n):\n                if is_not_under_attack(row, col):\n                    place_queen(row, col)\n                    backtrack(row + 1)\n                    remove_queen(row, col)\n\n        count = 0\n        cols, diagonal1, diagonal2 = set(), set(), set()\n        backtrack(0)\n        return count\n",
    "unit_test": "import unittest\n\nclass TestNQueensSolution(unittest.TestCase):\n    def test_totalNQueens(self):\n        solution = Solution()\n        self.assertEqual(solution.totalNQueens(1), 1)\n        self.assertEqual(solution.totalNQueens(2), 0)\n        self.assertEqual(solution.totalNQueens(3), 0)\n        self.assertEqual(solution.totalNQueens(4), 2)\n        self.assertEqual(solution.totalNQueens(5), 10)\n        self.assertEqual(solution.totalNQueens(6), 4)\n        self.assertEqual(solution.totalNQueens(7), 40)\n        self.assertEqual(solution.totalNQueens(8), 92)\n        self.assertEqual(solution.totalNQueens(9), 352)\n        self.assertEqual(solution.totalNQueens(10), 724)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "maximum-subarray": {
    "solution": "class Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        max_sum = nums[0]\n        current_sum = nums[0]\n        for i in range(1, len(nums)):\n            current_sum = max(nums[i], current_sum + nums[i])\n            max_sum = max(max_sum, current_sum)\n        return max_sum\n",
    "unit_test": "import unittest\n\nclass TestMaxSubArray(unittest.TestCase):\n    def setUp(self):\n        self.solution = Solution()\n\n    def test_max_sub_array(self):\n        # Test cases\n        self.assertEqual(self.solution.maxSubArray([-2,1,-3,4,-1,2,1,-5,4]), 6)  # [4, -1, 2, 1]\n        self.assertEqual(self.solution.maxSubArray([1]), 1)  # [1]\n        self.assertEqual(self.solution.maxSubArray([5,4,-1,7,8]), 23)  # [5, 4, -1, 7, 8]\n        self.assertEqual(self.solution.maxSubArray([-1,-2,-3]), -1)  # [-1]\n        self.assertEqual(self.solution.maxSubArray([0,0,0,0]), 0)  # [0]\n        self.assertEqual(self.solution.maxSubArray([1,2,3,4,5]), 15)  # [1, 2, 3, 4, 5]\n        self.assertEqual(self.solution.maxSubArray([-2,-1]), -1)  # [-1]\n        self.assertEqual(self.solution.maxSubArray([2,-1,2,3]), 6)  # [2, 3]\n        self.assertEqual(self.solution.maxSubArray([-2,4,-1,2,1,-5,4]), 6)  # [4, -1, 2, 1]\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "spiral-matrix": {
    "solution": "class Solution:\n    def spiralOrder(self, matrix):\n        if not matrix:\n            return []\n        result = []\n        top, bottom, left, right = 0, len(matrix) - 1, 0, len(matrix[0]) - 1\n        while top <= bottom and left <= right:\n            # Traverse from left to right\n            for i in range(left, right + 1):\n                result.append(matrix[top][i])\n            top += 1\n            # Traverse downwards\n            for i in range(top, bottom + 1):\n                result.append(matrix[i][right])\n            right -= 1\n            if top <= bottom:\n                # Traverse from right to left\n                for i in range(right, left - 1, -1):\n                    result.append(matrix[bottom][i])\n                bottom -= 1\n            if left <= right:\n                # Traverse upwards\n                for i in range(bottom, top - 1, -1):\n                    result.append(matrix[i][left])\n                left += 1\n        return result",
    "unit_test": "import unittest\n\nclass TestSpiralOrder(unittest.TestCase):\n    def setUp(self):\n        self.solution = Solution()\n\n    def test_spiralOrder(self):\n        # Test case 1\n        matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n        self.assertEqual(self.solution.spiralOrder(matrix), [1, 2, 3, 6, 9, 8, 7, 4, 5])\n\n        # Test case 2\n        matrix = [[1]]\n        self.assertEqual(self.solution.spiralOrder(matrix), [1])\n\n        # Test case 3\n        matrix = [[1, 2], [3, 4]]\n        self.assertEqual(self.solution.spiralOrder(matrix), [1, 2, 4, 3])\n\n        # Test case 4\n        matrix = []\n        self.assertEqual(self.solution.spiralOrder(matrix), [])\n\n        # Test case 5\n        matrix = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]\n        self.assertEqual(self.solution.spiralOrder(matrix), [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7])\n\n        # Test case 6\n        matrix = [[1, 2, 3], [4, 5, 6]]\n        self.assertEqual(self.solution.spiralOrder(matrix), [1, 2, 3, 6, 5, 4])\n\n        # Test case 7\n        matrix = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]\n        self.assertEqual(self.solution.spiralOrder(matrix), [1, 2, 3, 4, 8, 12, 16, 15, 14, 13, 9, 5, 6, 7, 11, 10])\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "jump-game": {
    "solution": "class Solution:\n    def canJump(self, nums: List[int]) -> bool:\n        reachable = 0\n        for i in range(len(nums)):\n            if i > reachable:\n                return False\n            reachable = max(reachable, i + nums[i])\n        return True",
    "unit_test": "import unittest\nfrom typing import List\n\nclass Solution:\n    def canJump(self, nums: List[int]) -> bool:\n        reachable = 0\n        for i in range(len(nums)):\n            if i > reachable:\n                return False\n            reachable = max(reachable, i + nums[i])\n        return True\n\nclass TestJumpGame(unittest.TestCase):\n    def setUp(self):\n        self.solution = Solution()\n\n    def test_can_jump(self):\n        self.assertTrue(self.solution.canJump([2, 3, 1, 1, 4]))\n        self.assertFalse(self.solution.canJump([3, 2, 1, 0, 4]))\n        self.assertTrue(self.solution.canJump([0]))\n        self.assertTrue(self.solution.canJump([1, 0, 0]))\n        self.assertTrue(self.solution.canJump([2, 0]))\n        self.assertFalse(self.solution.canJump([1, 1, 0, 0]))\n        self.assertTrue(self.solution.canJump([4, 0, 0, 0]))\n        self.assertFalse(self.solution.canJump([0, 1, 2, 3, 4]))\n        self.assertTrue(self.solution.canJump([5, 9, 3, 2, 0, 0, 1]))\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "merge-intervals": {
    "solution": "class Solution:\n    def merge(self, intervals):\n        # Sort the intervals based on the starting times\n        intervals.sort(key=lambda x: x[0])\n        merged = []\n\n        for interval in intervals:\n            # If the list of merged intervals is empty or if the current interval does not overlap with the last merged one, append it.\n            if not merged or merged[-1][1] < interval[0]:\n                merged.append(interval)\n            else:\n                # There is an overlap, so we merge the current interval with the last merged one.\n                merged[-1][1] = max(merged[-1][1], interval[1])\n\n        return merged",
    "unit_test": "import unittest\n\nclass TestSolution(unittest.TestCase):\n    def test_merge(self):\n        solution = Solution()\n        # Test cases\n        self.assertEqual(solution.merge([[1,3],[2,6],[8,10],[15,18]]), [[1,6],[8,10],[15,18]])\n        self.assertEqual(solution.merge([[1,4],[4,5]]), [[1,5]])\n        self.assertEqual(solution.merge([[1, 4], [2, 3]]), [[1, 4]])\n        self.assertEqual(solution.merge([[1, 2], [3, 4],[5, 6],[7, 8]]), [[1, 2], [3, 4], [5, 6], [7, 8]])\n        self.assertEqual(solution.merge([[1, 10], [2, 3], [4, 5], [6, 7]]), [[1, 10]])\n        self.assertEqual(solution.merge([]), [])\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "insert-interval": {
    "solution": "class Solution:\n    def insert(self, intervals, newInterval):\n        merged = []\n        i = 0\n        # Add all intervals before the newInterval\n        while i < len(intervals) and intervals[i][1] < newInterval[0]:\n            merged.append(intervals[i])\n            i += 1\n        # Merge newInterval with overlapping intervals\n        while i < len(intervals) and intervals[i][0] <= newInterval[1]:\n            newInterval[0] = min(newInterval[0], intervals[i][0])\n            newInterval[1] = max(newInterval[1], intervals[i][1])\n            i += 1\n        merged.append(newInterval)\n        # Add remaining intervals\n        while i < len(intervals):\n            merged.append(intervals[i])\n            i += 1\n        return merged\n",
    "unit_test": "import unittest\n\nclass TestInsertInterval(unittest.TestCase):\n    def setUp(self):\n        self.solution = Solution()\n\n    def test_insert_intervals(self):\n        # Test case 1\n        self.assertEqual(self.solution.insert([[1,3],[6,9]], [2,5]), [[1,5],[6,9]])\n        # Test case 2\n        self.assertEqual(self.solution.insert([[1,2],[3,5],[6,7],[8,10],[12,16]], [4,8]), [[1,2],[3,10],[12,16]])\n        # Test case 3\n        self.assertEqual(self.solution.insert([], [5,7]), [[5,7]])\n        # Test case 4\n        self.assertEqual(self.solution.insert([[1,5]], [2,3]), [[1,5]])\n        # Test case 5\n        self.assertEqual(self.solution.insert([[1,5]], [0,0]), [[0,0],[1,5]])\n        # Test case 6\n        self.assertEqual(self.solution.insert([[1,5]], [5,7]), [[1,7]])\n        # Test case 7\n        self.assertEqual(self.solution.insert([[1,3],[4,6],[7,9]], [4,8]), [[1,3],[4,9]])\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "length-of-last-word": {
    "solution": "class Solution:\n    def lengthOfLastWord(self, s: str) -> int:\n        words = s.split()\n        if not words:\n            return 0\n        return len(words[-1])",
    "unit_test": "import unittest\n\nclass TestLengthOfLastWord(unittest.TestCase):\n    def setUp(self):\n        self.solution = Solution()\n\n    def test_length_of_last_word(self):\n        self.assertEqual(self.solution.lengthOfLastWord(\"Hello World\"), 5)\n        self.assertEqual(self.solution.lengthOfLastWord(\"   fly me   to   the moon  \"), 4)\n        self.assertEqual(self.solution.lengthOfLastWord(\"luffy is still joyboy\"), 6)\n        self.assertEqual(self.solution.lengthOfLastWord(\"word\"), 4)\n        self.assertEqual(self.solution.lengthOfLastWord(\"   \"), 0)\n        self.assertEqual(self.solution.lengthOfLastWord(\"abc deg fg  \"), 2)\n        self.assertEqual(self.solution.lengthOfLastWord(\"singleword\"), 10)\n        self.assertEqual(self.solution.lengthOfLastWord(\"   trailing spaces   \"), 7)\n        self.assertEqual(self.solution.lengthOfLastWord(\"leading and trailing spaces     \"), 7)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "spiral-matrix-ii": {
    "solution": "class Solution:\n    def generateMatrix(self, n: int) -> List[List[int]]:\n        matrix = [[0] * n for _ in range(n)]\n        left, right, top, bottom = 0, n - 1, 0, n - 1\n        num = 1\n        while left <= right and top <= bottom:\n            for i in range(left, right + 1):\n                matrix[top][i] = num\n                num += 1\n            top += 1\n            for i in range(top, bottom + 1):\n                matrix[i][right] = num\n                num += 1\n            right -= 1\n            if top <= bottom:\n                for i in range(right, left - 1, -1):\n                    matrix[bottom][i] = num\n                    num += 1\n                bottom -= 1\n            if left <= right:\n                for i in range(bottom, top - 1, -1):\n                    matrix[i][left] = num\n                    num += 1\n                left += 1\n        return matrix",
    "unit_test": "import unittest\nfrom typing import List\n\nclass TestSolution(unittest.TestCase):\n    def test_generateMatrix(self):\n        sol = Solution()\n        self.assertEqual(sol.generateMatrix(1), [[1]])\n        self.assertEqual(sol.generateMatrix(2), [[1, 2], [4, 3]])\n        self.assertEqual(sol.generateMatrix(3), [[1, 2, 3], [8, 9, 4], [7, 6, 5]])\n        self.assertEqual(sol.generateMatrix(4), [[1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7]])\n        self.assertEqual(sol.generateMatrix(5), [[1, 2, 3, 4, 5], [16, 17, 18, 19, 6], [15, 24, 25, 20, 7], [14, 23, 22, 21, 8], [13, 12, 11, 10, 9]])\n        self.assertEqual(sol.generateMatrix(6), [[1, 2, 3, 4, 5, 6], [20, 21, 22, 23, 24, 7], [19, 32, 33, 34, 25, 8], [18, 31, 30, 29, 26, 9], [17, 16, 15, 14, 13, 10], [36, 35, 34, 33, 12, 11]])\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "permutation-sequence": {
    "solution": "class Solution:\n    def getPermutation(self, n: int, k: int) -> str:\n        import math\n        nums = [str(i) for i in range(1, n + 1)]\n        k -= 1  # Convert k to zero-based index\n        permutation = \"\"\n\n        for i in range(n):\n            # Calculate the factorial of the remaining numbers\n            fact = math.factorial(n - 1 - i)\n            index = k // fact\n            permutation += nums[index]\n            nums.pop(index)\n            k %= fact\n\n        return permutation\n",
    "unit_test": "import unittest\n\nclass TestSolution(unittest.TestCase):\n    \n    def test_get_permutation(self):\n        sol = Solution()\n        self.assertEqual(sol.getPermutation(3, 3), \"213\")\n        self.assertEqual(sol.getPermutation(4, 9), \"2314\")\n        self.assertEqual(sol.getPermutation(3, 1), \"123\")\n        self.assertEqual(sol.getPermutation(4, 24), \"4321\")\n        self.assertEqual(sol.getPermutation(5, 10), \"13425\")\n        self.assertEqual(sol.getPermutation(1, 1), \"1\")\n        self.assertEqual(sol.getPermutation(2, 2), \"21\")\n\nif __name__ == \"__main__\":\n    unittest.main()"
  },
  "rotate-list": {
    "solution": "class Solution:\n    def rotate(self, head: ListNode, k: int) -> ListNode:\n        if not head or k == 0:\n            return head\n        # Calculate the length of the list\n        length = 1\n        last_node = head\n        while last_node.next:\n            last_node = last_node.next\n            length += 1\n        # Make the list circular\n        last_node.next = head\n        # Find the point to break the circle\n        k = k % length\n        steps_to_new_head = length - k\n        new_last = head\n        for _ in range(steps_to_new_head - 1):\n            new_last = new_last.next\n        new_head = new_last.next\n        new_last.next = None\n        return new_head\n\n# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n",
    "unit_test": "import unittest\n\nclass TestRotateList(unittest.TestCase):\n    def list_to_linkedlist(self, lst):\n        head = ListNode(0)\n        current = head\n        for val in lst:\n            current.next = ListNode(val)\n            current = current.next\n        return head.next\n\n    def linkedlist_to_list(self, head):\n        lst = []\n        while head:\n            lst.append(head.val)\n            head = head.next\n        return lst\n\n    def test_rotate(self):\n        sol = Solution()\n\n        # Test case 1: Rotate by 2 positions\n        head = self.list_to_linkedlist([1, 2, 3, 4, 5])\n        result = sol.rotate(head, 2)\n        self.assertEqual(self.linkedlist_to_list(result), [4, 5, 1, 2, 3])\n\n        # Test case 2: Rotate by 0 positions (no rotation)\n        head = self.list_to_linkedlist([1, 2, 3, 4, 5])\n        result = sol.rotate(head, 0)\n        self.assertEqual(self.linkedlist_to_list(result), [1, 2, 3, 4, 5])\n\n        # Test case 3: Rotate by length of the list\n        head = self.list_to_linkedlist([1, 2, 3, 4, 5])\n        result = sol.rotate(head, 5)\n        self.assertEqual(self.linkedlist_to_list(result), [1, 2, 3, 4, 5])\n\n        # Test case 4: Rotate by length + 1\n        head = self.list_to_linkedlist([1, 2, 3, 4, 5])\n        result = sol.rotate(head, 6)\n        self.assertEqual(self.linkedlist_to_list(result), [5, 1, 2, 3, 4])\n\n        # Test case 5: Single node rotation\n        head = self.list_to_linkedlist([1])\n        result = sol.rotate(head, 3)\n        self.assertEqual(self.linkedlist_to_list(result), [1])\n\n        # Test case 6: Empty list rotation\n        head = self.list_to_linkedlist([])\n        result = sol.rotate(head, 3)\n        self.assertEqual(self.linkedlist_to_list(result), [])\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "unique-paths": {
    "solution": "class Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        dp = [[1] * n for _ in range(m)]\n        \n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n        \n        return dp[-1][-1]",
    "unit_test": "import unittest\n\nclass TestSolution(unittest.TestCase):\n    def test_uniquePaths(self):\n        sol = Solution()\n        # Test cases\n        self.assertEqual(sol.uniquePaths(3, 7), 28)  # 3x7 grid\n        self.assertEqual(sol.uniquePaths(3, 2), 3)   # 3x2 grid\n        self.assertEqual(sol.uniquePaths(1, 1), 1)   # 1x1 grid\n        self.assertEqual(sol.uniquePaths(2, 2), 2)   # 2x2 grid\n        self.assertEqual(sol.uniquePaths(5, 5), 70)  # 5x5 grid\n        self.assertEqual(sol.uniquePaths(10, 10), 48620)  # 10x10 grid\n        self.assertEqual(sol.uniquePaths(2, 3), 3)   # 2x3 grid\n        self.assertEqual(sol.uniquePaths(7, 3), 28)  # 7x3 grid\n        self.assertEqual(sol.uniquePaths(19, 3), 1771)  # 19x3 grid\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "unique-paths-ii": {
    "solution": "class Solution:\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\n        if not obstacleGrid or obstacleGrid[0][0] == 1:\n            return 0\n        rows = len(obstacleGrid)\n        cols = len(obstacleGrid[0])\n        dp = [[0] * cols for _ in range(rows)]\n        dp[0][0] = 1\n        \n        for i in range(rows):\n            for j in range(cols):\n                if obstacleGrid[i][j] == 1:\n                    dp[i][j] = 0\n                else:\n                    if i > 0:\n                        dp[i][j] += dp[i - 1][j]\n                    if j > 0:\n                        dp[i][j] += dp[i][j - 1]\n        return dp[rows - 1][cols - 1]",
    "unit_test": "import unittest\nfrom typing import List\n\nclass Solution:\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\n        if not obstacleGrid or obstacleGrid[0][0] == 1:\n            return 0\n        rows = len(obstacleGrid)\n        cols = len(obstacleGrid[0])\n        dp = [[0] * cols for _ in range(rows)]\n        dp[0][0] = 1\n        \n        for i in range(rows):\n            for j in range(cols):\n                if obstacleGrid[i][j] == 1:\n                    dp[i][j] = 0\n                else:\n                    if i > 0:\n                        dp[i][j] += dp[i - 1][j]\n                    if j > 0:\n                        dp[i][j] += dp[i][j - 1]\n        return dp[rows - 1][cols - 1]\n\nclass TestUniquePathsWithObstacles(unittest.TestCase):\n    def setUp(self):\n        self.solution = Solution()\n\n    def test_unique_paths_with_obstacles(self):\n        self.assertEqual(self.solution.uniquePathsWithObstacles([[0,0,0],[0,1,0],[0,0,0]]), 2)\n        self.assertEqual(self.solution.uniquePathsWithObstacles([[0,1],[0,0]]), 1)\n        self.assertEqual(self.solution.uniquePathsWithObstacles([[1]]), 0)\n        self.assertEqual(self.solution.uniquePathsWithObstacles([[0]]), 1)\n        self.assertEqual(self.solution.uniquePathsWithObstacles([[0,0,0],[1,1,0],[0,0,0]]), 4)\n        self.assertEqual(self.solution.uniquePathsWithObstacles([[0,0],[0,1],[0,0]]), 1)\n        self.assertEqual(self.solution.uniquePathsWithObstacles([[0,0,0],[0,0,0],[0,0,0]]), 6)\n        self.assertEqual(self.solution.uniquePathsWithObstacles([[0,0,0],[0,1,0],[0,0,0],[0,1,0]]), 2)\n        self.assertEqual(self.solution.uniquePathsWithObstacles([[0,0],[1,0],[0,0]]), 1)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "minimum-path-sum": {
    "solution": "class Solution:\n    def minPathSum(self, grid):\n        if not grid:\n            return 0\n        rows = len(grid)\n        cols = len(grid[0])\n        # Initialize the first row\n        for c in range(1, cols):\n            grid[0][c] += grid[0][c - 1]\n        # Initialize the first column\n        for r in range(1, rows):\n            grid[r][0] += grid[r - 1][0]\n        # Update the grid\n        for r in range(1, rows):\n            for c in range(1, cols):\n                grid[r][c] += min(grid[r - 1][c], grid[r][c - 1])\n        return grid[rows - 1][cols - 1]",
    "unit_test": "import unittest\n\nclass TestMinimumPathSum(unittest.TestCase):\n    def setUp(self):\n        self.solution = Solution()\n\n    def test_case_1(self):\n        grid = [[1,3,1],[1,5,1],[4,2,1]]\n        self.assertEqual(self.solution.minPathSum(grid), 7)\n\n    def test_case_2(self):\n        grid = [[1,2,3],[4,5,6]]\n        self.assertEqual(self.solution.minPathSum(grid), 12)\n\n    def test_case_3(self):\n        grid = [[1]]\n        self.assertEqual(self.solution.minPathSum(grid), 1)\n\n    def test_case_4(self):\n        grid = [[1,2],[5,6],[1,1]]\n        self.assertEqual(self.solution.minPathSum(grid), 8)\n\n    def test_case_5(self):\n        grid = []\n        self.assertEqual(self.solution.minPathSum(grid), 0)\n\n    def test_case_6(self):\n        grid = [[1,2,3],[4,5,6],[7,8,9]]\n        self.assertEqual(self.solution.minPathSum(grid), 21)\n\nif __name__ == \"__main__\":\n    unittest.main()"
  },
  "valid-number": {
    "solution": "class Solution:\n    def isNumber(self, s: str) -> bool:\n        # Strip leading and trailing whitespaces\n        s = s.strip()\n        if not s:\n            return False\n        # Initialize state flags\n        num_seen = False\n        dot_seen = False\n        e_seen = False\n        # Validate each character\n        for i, char in enumerate(s):\n            if char.isdigit():\n                num_seen = True\n            elif char == '.':\n                if dot_seen or e_seen:\n                    return False\n                dot_seen = True\n            elif char in ['e', 'E']:  # Check for scientific notation\n                if e_seen or not num_seen:\n                    return False\n                e_seen = True\n                num_seen = False  # Reset num since we expect digits after 'e'\n            elif char in ['+', '-']:  # +/- sign\n                if i > 0 and s[i-1] not in ['e', 'E']:\n                    return False\n            else:\n                return False\n        return num_seen\n\n",
    "unit_test": "import unittest\n\nclass TestSolution(unittest.TestCase):\n    def setUp(self):\n        self.solution = Solution()\n\n    def test_valid_numbers(self):\n        self.assertTrue(self.solution.isNumber(\"2\"))\n        self.assertTrue(self.solution.isNumber(\"  -42  \"))\n        self.assertTrue(self.solution.isNumber(\" 3.14159 \"))\n        self.assertTrue(self.solution.isNumber(\"  +.8  \"))\n        self.assertTrue(self.solution.isNumber(\"-.1e10\"))\n        self.assertTrue(self.solution.isNumber(\"1.2e3\"))\n        self.assertTrue(self.solution.isNumber(\"0.1\"))\n        self.assertTrue(self.solution.isNumber(\"1E10\"))\n        self.assertTrue(self.solution.isNumber(\".5E-2\"))\n\n    def test_invalid_numbers(self):\n        self.assertFalse(self.solution.isNumber(\"abc\"))\n        self.assertFalse(self.solution.isNumber(\"1a\"))\n        self.assertFalse(self.solution.isNumber(\"1e.\"))\n        self.assertFalse(self.solution.isNumber(\"-e3\"))\n        self.assertFalse(self.solution.isNumber(\"\"))\n        self.assertFalse(self.solution.isNumber(\"--1\"))\n        self.assertFalse(self.solution.isNumber(\"1.2.3\"))\n        self.assertFalse(self.solution.isNumber(\"1e+-3\"))\n        self.assertFalse(self.solution.isNumber(\"1e3.5\"))\n\nif __name__ == \"__main__\":\n    unittest.main()"
  },
  "plus-one": {
    "solution": "class Solution:\n    def plusOne(self, digits):\n        # Start from the last digit and go backwards\n        for i in range(len(digits) - 1, -1, -1):\n            if digits[i] < 9:\n                digits[i] += 1  # Increment the digit\n                return digits\n            else:\n                digits[i] = 0  # Set to 0 if 9\n        # If all digits were 9, we need an additional 1 at the start\n        return [1] + digits\n",
    "unit_test": "import unittest\n\nclass TestPlusOne(unittest.TestCase):\n    def test_plus_one(self):\n        solution = Solution()\n        self.assertEqual(solution.plusOne([1, 2, 3]), [1, 2, 4])\n        self.assertEqual(solution.plusOne([4, 3, 2, 1]), [4, 3, 2, 2])\n        self.assertEqual(solution.plusOne([0]), [1])\n        self.assertEqual(solution.plusOne([9]), [1, 0])\n        self.assertEqual(solution.plusOne([1, 4, 9]), [1, 5, 0])\n        self.assertEqual(solution.plusOne([9, 9, 9]), [1, 0, 0, 0])\n        self.assertEqual(solution.plusOne([2, 9, 9]), [3, 0, 0])\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "add-binary": {
    "solution": "class Solution:\n    def addBinary(self, a: str, b: str) -> str:\n        result = []\n        carry = 0\n        max_length = max(len(a), len(b))\n\n        # Pad the shorter string with zeros at the front\n        a = a.zfill(max_length)\n        b = b.zfill(max_length)\n\n        # Iterate from the end to the beginning\n        for i in range(max_length - 1, -1, -1):\n            total = carry\n            total += 1 if a[i] == '1' else 0\n            total += 1 if b[i] == '1' else 0\n\n            carry = total // 2\n            result.append(str(total % 2))\n\n        if carry:\n            result.append('1')\n\n        # The result is reversed because we've constructed it backwards\n        return ''.join(result[::-1])",
    "unit_test": "import unittest\n\nclass TestAddBinary(unittest.TestCase):\n    def setUp(self):\n        self.solution = Solution()\n\n    def test_add_binary(self):\n        self.assertEqual(self.solution.addBinary('11', '1'), '100')  # 3 in binary\n        self.assertEqual(self.solution.addBinary('1010', '1011'), '10101')  # 10 + 11 = 21 in binary\n        self.assertEqual(self.solution.addBinary('0', '0'), '0')  # 0 + 0 = 0\n        self.assertEqual(self.solution.addBinary('1', '0'), '1')  # 1 + 0 = 1\n        self.assertEqual(self.solution.addBinary('1111', '1111'), '11110')  # 15 + 15 = 30\n        self.assertEqual(self.solution.addBinary('1101', '1011'), '11000')  # 13 + 11 = 24\n        self.assertEqual(self.solution.addBinary('11111111', '1'), '100000000')  # 255 + 1 = 256\n        self.assertEqual(self.solution.addBinary('', '1'), '1')  # '' + 1 = 1\n        self.assertEqual(self.solution.addBinary('1', ''), '1')  # 1 + '' = 1\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "text-justification": {
    "solution": "class Solution:\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\n        res = []\n        curr = []\n        num_of_letters = 0\n\n        for w in words:\n            if num_of_letters + len(w) + len(curr) > maxWidth:\n                for i in range(maxWidth - num_of_letters):\n                    curr[i % (len(curr) - 1 or 1)] += ' '\n                res.append(''.join(curr))\n                curr = []\n                num_of_letters = 0\n            curr.append(w)\n            num_of_letters += len(w)\n\n        return res + [' '.join(curr).ljust(maxWidth)]\n",
    "unit_test": "import unittest\nfrom typing import List\n\nclass TestSolution(unittest.TestCase):\n    def test_fullJustify(self):\n        solution = Solution()\n        self.assertEqual(solution.fullJustify(['This', 'is', 'an', 'example', 'of', 'text', 'justification.'], 16), ['This    is    an', 'example  of text', 'justification.  '])\n        self.assertEqual(solution.fullJustify(['What', 'must', 'be', 'acknowledgment', 'that', 'there', 'will', 'always', 'be', 'a', 'response', 'to', 'these', 'words'], 16), ['What   must   be', 'acknowledgment  ', 'that there will', 'always be a', 'response   to', 'these words    '])\n        self.assertEqual(solution.fullJustify(['Science', 'is', 'what', 'we', 'understand', 'well', 'enough', 'to', 'explain', 'to', 'a', 'computer.', 'Art', 'is', 'everything', 'else', 'we', 'do'], 20), ['Science  is  what  we', 'understand well enough', 'to explain to a computer.', 'Art is everything else we', 'do                  '])\n        self.assertEqual(solution.fullJustify(['Justification', 'example'], 15), ['Justification', 'example     '])\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "sqrtx": {
    "solution": "class Solution:\n    def mySqrt(self, x: int) -> int:\n        if x < 2:\n            return x\n        left, right = 2, x // 2\n        while left <= right:\n            mid = left + (right - left) // 2\n            square = mid * mid\n            if square == x:\n                return mid\n            elif square < x:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return right",
    "unit_test": "import unittest\n\nclass TestMySqrt(unittest.TestCase):\n    def setUp(self):\n        self.solution = Solution()\n\n    def test_mySqrt(self):\n        self.assertEqual(self.solution.mySqrt(0), 0)\n        self.assertEqual(self.solution.mySqrt(1), 1)\n        self.assertEqual(self.solution.mySqrt(4), 2)\n        self.assertEqual(self.solution.mySqrt(8), 2)\n        self.assertEqual(self.solution.mySqrt(9), 3)\n        self.assertEqual(self.solution.mySqrt(16), 4)\n        self.assertEqual(self.solution.mySqrt(15), 3)\n        self.assertEqual(self.solution.mySqrt(25), 5)\n        self.assertEqual(self.solution.mySqrt(1024), 32)\n        self.assertEqual(self.solution.mySqrt(2147395600), 46340)  # 46340^2 = 2147395600\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "climbing-stairs": {
    "solution": "class Solution:\n    def climbStairs(self, n: int) -> int:\n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        first, second = 1, 2\n        for _ in range(3, n + 1):\n            first, second = second, first + second\n        return second",
    "unit_test": "import unittest\n\nclass TestClimbStairs(unittest.TestCase):\n    def setUp(self):\n        self.solution = Solution()\n\n    def test_climb_stairs(self):\n        self.assertEqual(self.solution.climbStairs(1), 1)\n        self.assertEqual(self.solution.climbStairs(2), 2)\n        self.assertEqual(self.solution.climbStairs(3), 3)\n        self.assertEqual(self.solution.climbStairs(4), 5)\n        self.assertEqual(self.solution.climbStairs(5), 8)\n        self.assertEqual(self.solution.climbStairs(6), 13)\n        self.assertEqual(self.solution.climbStairs(7), 21)\n        self.assertEqual(self.solution.climbStairs(8), 34)\n        self.assertEqual(self.solution.climbStairs(9), 55)\n        self.assertEqual(self.solution.climbStairs(10), 89)\n        self.assertEqual(self.solution.climbStairs(20), 10946)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "simplify-path": {
    "solution": "class Solution:\n    def simplifyPath(self, path: str) -> str:\n        stack = []\n        # Split the path by '/' and process each component\n        for component in path.split('/'): \n            if component == '' or component == '.':  \n                # Ignore empty components and current directory\n                continue \n            elif component == '..':  \n                # Go back to the previous directory if possible\n                if stack:  \n                    stack.pop()  \n            else:\n                # Add the valid component to the stack\n                stack.append(component)  \n        # Join the components in the stack to form the simplified path\n        return '/' + '/'.join(stack)",
    "unit_test": "import unittest\n\nclass TestSimplifyPath(unittest.TestCase):\n    def setUp(self):\n        self.s = Solution()\n\n    def test_simplify_path(self):\n        self.assertEqual(self.s.simplifyPath('/home/'), '/home')\n        self.assertEqual(self.s.simplifyPath('/../'), '/')\n        self.assertEqual(self.s.simplifyPath('/home//foo/'), '/home/foo')\n        self.assertEqual(self.s.simplifyPath('/a/./b/../../c/'), '/c')\n        self.assertEqual(self.s.simplifyPath('/a/../../b/../c//.//'), '/c')\n        self.assertEqual(self.s.simplifyPath('/a//b////c/d//././/..'), '/a/b/c')\n        self.assertEqual(self.s.simplifyPath('/.../'), '/...')\n        self.assertEqual(self.s.simplifyPath('//a/b/c/../..//..'), '/a')\n        self.assertEqual(self.s.simplifyPath('/../../a/b/c'), '/a/b/c')\n        self.assertEqual(self.s.simplifyPath('/a/b/c/..'), '/a/b')\n        self.assertEqual(self.s.simplifyPath('/././..'), '/')\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "edit-distance": {
    "solution": "class Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        m, n = len(word1), len(word2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n        # Initialize the dp array\n        for i in range(m + 1):\n            dp[i][0] = i\n        for j in range(n + 1):\n            dp[0][j] = j\n\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if word1[i - 1] == word2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n\n        return dp[m][n]",
    "unit_test": "import unittest\n\nclass TestEditDistance(unittest.TestCase):\n    def setUp(self):\n        self.solution = Solution()\n\n    def test_minDistance(self):\n        self.assertEqual(self.solution.minDistance(\"horse\", \"ros\"), 3)\n        self.assertEqual(self.solution.minDistance(\"intention\", \"execution\"), 5)\n        self.assertEqual(self.solution.minDistance(\"\", \"a\"), 1)\n        self.assertEqual(self.solution.minDistance(\"a\", \"\"), 1)\n        self.assertEqual(self.solution.minDistance(\"\", \"\"), 0)\n        self.assertEqual(self.solution.minDistance(\"kitten\", \"sitting\"), 3)\n        self.assertEqual(self.solution.minDistance(\"flaw\", \"lawn\"), 2)\n        self.assertEqual(self.solution.minDistance(\"abc\", \"abc\"), 0)\n        self.assertEqual(self.solution.minDistance(\"sunday\", \"saturday\"), 3)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "set-matrix-zeroes": {
    "solution": "class Solution:\n    def setZeroes(self, matrix: List[List[int]]) -> None:\n        if not matrix or not matrix[0]:\n            return\n        rows, cols = len(matrix), len(matrix[0])\n        row_zero = any(matrix[0][j] == 0 for j in range(cols))\n        col_zero = any(matrix[i][0] == 0 for i in range(rows))\n\n        for i in range(1, rows):\n            for j in range(1, cols):\n                if matrix[i][j] == 0:\n                    matrix[i][0] = 0\n                    matrix[0][j] = 0\n\n        for i in range(1, rows):\n            for j in range(1, cols):\n                if matrix[i][0] == 0 or matrix[0][j] == 0:\n                    matrix[i][j] = 0\n\n        if row_zero:\n            for j in range(cols):\n                matrix[0][j] = 0\n        if col_zero:\n            for i in range(rows):\n                matrix[i][0] = 0\n",
    "unit_test": "import unittest\nfrom typing import List\n\nclass TestSetMatrixZeroes(unittest.TestCase):\n    def test_set_zeroes(self):\n        sol = Solution()\n\n        # Test case 1: basic example where multiple zeroes are present.\n        matrix1 = [[1, 1, 1], [1, 0, 1], [1, 1, 1]]\n        sol.setZeroes(matrix1)\n        self.assertEqual(matrix1, [[1, 0, 1], [0, 0, 0], [1, 0, 1]])\n\n        # Test case 2: no zeros, the matrix should remain the same.\n        matrix2 = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n        sol.setZeroes(matrix2)\n        self.assertEqual(matrix2, [[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n\n        # Test case 3: all zero matrix.\n        matrix3 = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]\n        sol.setZeroes(matrix3)\n        self.assertEqual(matrix3, [[0, 0, 0], [0, 0, 0], [0, 0, 0]])\n\n        # Test case 4: single row with a zero.\n        matrix4 = [[1, 2, 0]]\n        sol.setZeroes(matrix4)\n        self.assertEqual(matrix4, [[0, 0, 0]])\n\n        # Test case 5: single column with a zero.\n        matrix5 = [[1], [0], [3]]\n        sol.setZeroes(matrix5)\n        self.assertEqual(matrix5, [[0], [0], [0]])\n\n        # Test case 6: larger matrix with multiple zeros.\n        matrix6 = [[1, 1, 1, 1], [1, 0, 1, 1], [1, 1, 1, 0], [1, 1, 1, 1]]\n        sol.setZeroes(matrix6)\n        self.assertEqual(matrix6, [[1, 0, 0, 1], [0, 0, 0, 0], [1, 0, 0, 0], [1, 0, 0, 1]])\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "search-a-2d-matrix": {
    "solution": "class Solution:\n    def searchMatrix(self, matrix, target):\n        if not matrix or not matrix[0]:\n            return False\n\n        rows, cols = len(matrix), len(matrix[0])\n        left, right = 0, rows * cols - 1\n\n        while left <= right:\n            mid = (left + right) // 2\n            mid_value = matrix[mid // cols][mid % cols]\n\n            if mid_value == target:\n                return True\n            elif mid_value < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n\n        return False",
    "unit_test": "import unittest\n\nclass TestSolution(unittest.TestCase):\n    def setUp(self):\n        self.solution = Solution()\n\n    def test_searchMatrix(self):\n        self.assertTrue(self.solution.searchMatrix([[1]], 1))\n        self.assertFalse(self.solution.searchMatrix([[1]], 0))\n        self.assertTrue(self.solution.searchMatrix([[1, 3, 5]], 3))\n        self.assertFalse(self.solution.searchMatrix([[1, 3, 5]], 0))\n        self.assertTrue(self.solution.searchMatrix([[1], [3], [5], [7]], 5))\n        self.assertFalse(self.solution.searchMatrix([[1], [3], [5], [7]], 0))\n        self.assertTrue(self.solution.searchMatrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 5))\n        self.assertFalse(self.solution.searchMatrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 10))\n        self.assertTrue(self.solution.searchMatrix([[1, 3, 5], [7, 9, 11], [13, 15, 17]], 13))\n        self.assertFalse(self.solution.searchMatrix([], 5))\n        self.assertFalse(self.solution.searchMatrix([[]], 5))\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "sort-colors": {
    "solution": "class Solution:\n    def sortColors(self, nums):\n        low, mid, high = 0, 0, len(nums) - 1\n        while mid <= high:\n            if nums[mid] == 0:\n                nums[low], nums[mid] = nums[mid], nums[low]\n                low += 1\n                mid += 1\n            elif nums[mid] == 1:\n                mid += 1\n            else:\n                nums[mid], nums[high] = nums[high], nums[mid]\n                high -= 1",
    "unit_test": "import unittest\n\nclass TestSortColors(unittest.TestCase):\n    def test_sort_colors(self):\n        solution = Solution()\n        test_cases = [\n            ([2, 0, 2, 1, 1, 0], [0, 0, 1, 1, 2, 2]),\n            ([2, 0, 1], [0, 1, 2]),\n            ([0, 1, 2], [0, 1, 2]),\n            ([1], [1]),\n            ([2], [2]),\n            ([], []),\n            ([1, 0, 1, 0, 1], [0, 0, 1, 1, 1]),\n            ([0, 0, 0, 0, 0], [0, 0, 0, 0, 0]),\n            ([1, 1, 1, 1, 1], [1, 1, 1, 1, 1]),\n            ([2, 1, 0, 1, 2, 0], [0, 0, 1, 1, 2, 2]),\n        ]\n        for nums, expected in test_cases:\n            solution.sortColors(nums)\n            self.assertEqual(nums, expected)\n\nif __name__ == \"__main__\":\n    unittest.main()"
  },
  "minimum-window-substring": {
    "solution": "class Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        from collections import Counter\n        if not t or not s:\n            return \"\"\n        dict_t = Counter(t)\n        required = len(dict_t)\n\n        # Filter s to only characters in t\n        filtered_s = [(i, char) for i, char in enumerate(s) if char in dict_t]\n\n        l, r = 0, 0\n        formed = 0\n        window_counts = {}\n        ans = float(\"inf\"), None, None  # length of window, left, right\n\n        while r < len(filtered_s):\n            character = filtered_s[r][1]\n            window_counts[character] = window_counts.get(character, 0) + 1\n\n            if character in dict_t and window_counts[character] == dict_t[character]:\n                formed += 1\n\n            while l <= r and formed == required:\n                character = filtered_s[l][1]\n\n                start = filtered_s[l][0]\n                end = filtered_s[r][0]\n                if end - start + 1 < ans[0]:\n                    ans = (end - start + 1, start, end)\n\n                window_counts[character] -= 1\n                if character in dict_t and window_counts[character] < dict_t[character]:\n                    formed -= 1\n\n                l += 1\n            r += 1\n\n        return \"\" if ans[1] is None else s[ans[1]:ans[2] + 1]",
    "unit_test": "import unittest\n\nclass TestMinimumWindowSubstring(unittest.TestCase):\n    def test_cases(self):\n        solution = Solution()\n        self.assertEqual(solution.minWindow(\"ADOBECODEBANC\", \"ABC\"), \"BANC\")\n        self.assertEqual(solution.minWindow(\"a\", \"a\"), \"a\")\n        self.assertEqual(solution.minWindow(\"a\", \"aa\"), \"\")\n        self.assertEqual(solution.minWindow(\"aabb\", \"ab\"), \"ab\")\n        self.assertEqual(solution.minWindow(\"cabwefgccdbct\", \"cae\"), \"cabwefg\")\n        self.assertEqual(solution.minWindow(\"a\", \"b\"), \"\")\n        self.assertEqual(solution.minWindow(\"aa\", \"aa\"), \"aa\")\n        self.assertEqual(solution.minWindow(\"ab\", \"b\"), \"b\")\n        self.assertEqual(solution.minWindow(\"abc\", \"abc\"), \"abc\")\n\nif __name__ == \"__main__\":\n    unittest.main()"
  },
  "combinations": {
    "solution": "class Solution:\n    def combine(self, n: int, k: int) -> List[List[int]]:\n        def backtrack(start: int, path: List[int]):\n            if len(path) == k:\n                res.append(path[:])  # make a deep copy of path\n                return\n            for i in range(start, n + 1):\n                path.append(i)  # add i into the current combination\n                backtrack(i + 1, path)  # use next integers to complete the combination\n                path.pop()  # backtrack\n\n        res = []\n        backtrack(1, [])  # Start from the first number\n        return res\n",
    "unit_test": "import unittest\n\nclass TestSolution(unittest.TestCase):\n    def test_combine(self):\n        sol = Solution()\n        self.assertEqual(sorted(sol.combine(4, 2)), sorted([[2, 3], [1, 2], [1, 3], [1, 4], [2, 4], [3, 4]]))\n        self.assertEqual(sorted(sol.combine(1, 1)), sorted([[1]]))\n        self.assertEqual(sorted(sol.combine(3, 1)), sorted([[1], [2], [3]]))\n        self.assertEqual(sorted(sol.combine(5, 3)), sorted([[1, 2, 3], [1, 2, 4], [1, 2, 5], [1, 3, 4], [1, 3, 5], [1, 4, 5], [2, 3, 4], [2, 3, 5], [2, 4, 5], [3, 4, 5]]))\n        self.assertEqual(sol.combine(0, 0), [[]])\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "subsets": {
    "solution": "class Solution:\n    def subsets(self, nums):\n        result = []\n        self.backtrack(result, [], nums, 0)\n        return result\n\n    def backtrack(self, result, temp_list, nums, start):\n        result.append(temp_list[:])\n        for i in range(start, len(nums)):\n            temp_list.append(nums[i])\n            self.backtrack(result, temp_list, nums, i + 1)\n            temp_list.pop()",
    "unit_test": "import unittest\n\nclass TestSubsets(unittest.TestCase):\n    def test_subsets(self):\n        solution = Solution()\n        self.assertEqual(sorted(solution.subsets([1, 2, 3])), sorted([[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]))\n        self.assertEqual(sorted(solution.subsets([])), sorted([[]]))\n        self.assertEqual(sorted(solution.subsets([0])), sorted([[], [0]]))\n        self.assertEqual(sorted(solution.subsets([1])), sorted([[], [1]]))\n        self.assertEqual(sorted(solution.subsets([1, 2])), sorted([[], [1], [1, 2], [2]]))\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "word-search": {
    "solution": "class Solution:\n    def exist(self, board: List[List[str]], word: str) -> bool:\n        if not board:\n            return False\n        self.rows, self.cols = len(board), len(board[0])\n        self.visited = set()\n        self.board = board\n\n        for r in range(self.rows):\n            for c in range(self.cols):\n                if self.backtrack(r, c, word, 0):\n                    return True\n        return False\n\n    def backtrack(self, r: int, c: int, word: str, index: int) -> bool:\n        if index == len(word):\n            return True\n        if r < 0 or c < 0 or r >= self.rows or c >= self.cols:\n            return False\n        if (r, c) in self.visited or self.board[r][c] != word[index]:\n            return False\n\n        self.visited.add((r, c))\n        found = (self.backtrack(r + 1, c, word, index + 1) or\n                  self.backtrack(r - 1, c, word, index + 1) or\n                  self.backtrack(r, c + 1, word, index + 1) or\n                  self.backtrack(r, c - 1, word, index + 1))\n        self.visited.remove((r, c))\n        return found\n",
    "unit_test": "import unittest\nfrom typing import List\n\nclass Solution:\n    def exist(self, board: List[List[str]], word: str) -> bool:\n        if not board:\n            return False\n        self.rows, self.cols = len(board), len(board[0])\n        self.visited = set()\n        self.board = board\n\n        for r in range(self.rows):\n            for c in range(self.cols):\n                if self.backtrack(r, c, word, 0):\n                    return True\n        return False\n\n    def backtrack(self, r: int, c: int, word: str, index: int) -> bool:\n        if index == len(word):\n            return True\n        if r < 0 or c < 0 or r >= self.rows or c >= self.cols:\n            return False\n        if (r, c) in self.visited or self.board[r][c] != word[index]:\n            return False\n\n        self.visited.add((r, c))\n        found = (self.backtrack(r + 1, c, word, index + 1) or\n                  self.backtrack(r - 1, c, word, index + 1) or\n                  self.backtrack(r, c + 1, word, index + 1) or\n                  self.backtrack(r, c - 1, word, index + 1))\n        self.visited.remove((r, c))\n        return found\n\nclass TestSolution(unittest.TestCase):\n    def test_exist(self):\n        sol = Solution()\n        self.assertTrue(sol.exist([['A', 'B', 'C', 'E'],\n                                     ['S', 'F', 'C', 'S'],\n                                     ['A', 'D', 'E', 'E']], \"ABCCED\"))\n        self.assertTrue(sol.exist([['a', 'b'], ['c', 'd']], 'abcd'))\n        self.assertFalse(sol.exist([['a', 'b'], ['c', 'd']], 'acbd'))\n        self.assertFalse(sol.exist([], 'abc'))\n        self.assertFalse(sol.exist([['A', 'B']], 'AAB'))\n        self.assertTrue(sol.exist([['A', 'B'], ['C', 'D']], 'AB'))\n        self.assertFalse(sol.exist([['A']], 'B'))\n        self.assertTrue(sol.exist([['A'], ['A'], ['A']], 'A'))\n        self.assertFalse(sol.exist([['C', 'A', 'A'], ['C', 'A', 'A'], ['C', 'A', 'A']], 'CAAAA'))\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "remove-duplicates-from-sorted-array-ii": {
    "solution": "class Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        if not nums:\n            return 0\n        n = len(nums)\n        # The new length of the array where duplicates are allowed at most 2\n        length = 1\n        count = 1\n\n        for i in range(1, n):\n            # Count occurrences of nums[i]\n            if nums[i] == nums[i - 1]:\n                count += 1\n            else:\n                count = 1\n\n            if count <= 2:\n                nums[length] = nums[i]\n                length += 1\n\n        return length\n",
    "unit_test": "import unittest\nfrom typing import List\n\nclass TestRemoveDuplicates(unittest.TestCase):\n    def test_remove_duplicates(self):\n        sol = Solution()\n        # Test Case 1\n        nums = [1, 1, 1, 2, 2, 3]\n        new_length = sol.removeDuplicates(nums)\n        self.assertEqual(new_length, 5)\n        self.assertEqual(nums[:new_length], [1, 1, 2, 2, 3])\n\n        # Test Case 2\n        nums = [0, 0, 1, 1, 1, 2, 3, 3]\n        new_length = sol.removeDuplicates(nums)\n        self.assertEqual(new_length, 7)\n        self.assertEqual(nums[:new_length], [0, 0, 1, 1, 2, 3, 3])\n\n        # Test Case 3\n        nums = [1, 2, 3, 4]\n        new_length = sol.removeDuplicates(nums)\n        self.assertEqual(new_length, 4)\n        self.assertEqual(nums[:new_length], [1, 2, 3, 4])\n\n        # Test Case 4\n        nums = []\n        new_length = sol.removeDuplicates(nums)\n        self.assertEqual(new_length, 0)\n\n        # Test Case 5\n        nums = [1, 1, 1]\n        new_length = sol.removeDuplicates(nums)\n        self.assertEqual(new_length, 2)\n        self.assertEqual(nums[:new_length], [1, 1])\n\n        # Test Case 6\n        nums = [1, 1, 2, 2, 2, 3, 3, 3, 4]\n        new_length = sol.removeDuplicates(nums)\n        self.assertEqual(new_length, 8)\n        self.assertEqual(nums[:new_length], [1, 1, 2, 2, 3, 3, 4])\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "search-in-rotated-sorted-array-ii": {
    "solution": "class Solution:\n    def search(self, nums: List[int], target: int) -> bool:\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return True\n            # Handle duplicates\n            if nums[left] == nums[mid] == nums[right]:\n                left += 1\n                right -= 1\n            elif nums[left] <= nums[mid]:  # Left side is sorted\n                if nums[left] <= target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            else:  # Right side is sorted\n                if nums[mid] < target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n        return False",
    "unit_test": "import unittest\nfrom typing import List\n\nclass Solution:\n    def search(self, nums: List[int], target: int) -> bool:\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return True\n            # Handle duplicates\n            if nums[left] == nums[mid] == nums[right]:\n                left += 1\n                right -= 1\n            elif nums[left] <= nums[mid]:  # Left side is sorted\n                if nums[left] <= target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            else:  # Right side is sorted\n                if nums[mid] < target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n        return False\n\nclass TestSolution(unittest.TestCase):\n    def test_search(self):\n        sol = Solution()\n        # Test cases\n        self.assertTrue(sol.search([2,5,6,0,0,1,2], 0))\n        self.assertTrue(sol.search([2,5,6,0,0,1,2], 1))\n        self.assertFalse(sol.search([2,5,6,0,0,1,2], 3))\n        self.assertTrue(sol.search([1], 1))\n        self.assertFalse(sol.search([1], 0))\n        self.assertTrue(sol.search([1, 3, 1, 1, 1], 3))\n        self.assertTrue(sol.search([1, 1, 1, 1, 1, 3, 1, 1], 3))\n        self.assertFalse(sol.search([1, 1, 1, 1, 1, 1, 1, 1], 2))\n        self.assertFalse(sol.search([], 0))\n        self.assertTrue(sol.search([3, 1], 1))\n        self.assertFalse(sol.search([3, 1], 2))\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "remove-duplicates-from-sorted-list-ii": {
    "solution": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def deleteDuplicates(self, head: ListNode) -> ListNode:\n        # Dummy node to help simplify operations\n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        current = head\n        \n        while current:\n            # If it's a duplicate\n            if current.next and current.val == current.next.val:\n                # Skip all nodes with the same value\n                while current.next and current.val == current.next.val:\n                    current = current.next\n                # Remove duplicates\n                prev.next = current.next\n            else:\n                # No duplicates found\n                prev = prev.next\n            current = current.next\n\n        return dummy.next",
    "unit_test": "import unittest\n\nclass TestSolution(unittest.TestCase):\n    def list_to_linkedlist(self, lst):\n        if not lst:\n            return None\n        head = ListNode(lst[0])\n        current = head\n        for value in lst[1:]:\n            current.next = ListNode(value)\n            current = current.next\n        return head\n\n    def linkedlist_to_list(self, node):\n        lst = []\n        while node:\n            lst.append(node.val)\n            node = node.next\n        return lst\n\n    def test_deleteDuplicates(self):\n        sol = Solution()\n        # Test case 1: 1 -> 2 -> 3 -> 3 -> 4 -> 4 -> 5\n        head = self.list_to_linkedlist([1, 2, 3, 3, 4, 4, 5])\n        result = sol.deleteDuplicates(head)\n        self.assertEqual(self.linkedlist_to_list(result), [1, 2, 5])\n\n        # Test case 2: 1 -> 1 -> 1 -> 2 -> 3\n        head = self.list_to_linkedlist([1, 1, 1, 2, 3])\n        result = sol.deleteDuplicates(head)\n        self.assertEqual(self.linkedlist_to_list(result), [2, 3])\n\n        # Test case 3: 1 -> 2 -> 3 -> 4 -> 5\n        head = self.list_to_linkedlist([1, 2, 3, 4, 5])\n        result = sol.deleteDuplicates(head)\n        self.assertEqual(self.linkedlist_to_list(result), [1, 2, 3, 4, 5])\n\n        # Test case 4: 1 -> 1 -> 2 -> 2\n        head = self.list_to_linkedlist([1, 1, 2, 2])\n        result = sol.deleteDuplicates(head)\n        self.assertEqual(self.linkedlist_to_list(result), [])\n\n        # Test case 5: empty list\n        head = self.list_to_linkedlist([])\n        result = sol.deleteDuplicates(head)\n        self.assertEqual(self.linkedlist_to_list(result), [])\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "remove-duplicates-from-sorted-list": {
    "solution": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def deleteDuplicates(self, head: ListNode) -> ListNode:\n        current = head\n        while current and current.next:\n            if current.val == current.next.val:\n                current.next = current.next.next\n            else:\n                current = current.next\n        return head",
    "unit_test": "import unittest\n\nclass TestSolution(unittest.TestCase):\n    def list_to_linkedlist(self, elements):\n        head = ListNode(0)\n        current = head\n        for element in elements:\n            current.next = ListNode(element)\n            current = current.next\n        return head.next\n\n    def linkedlist_to_list(self, node):\n        result = []\n        while node:\n            result.append(node.val)\n            node = node.next\n        return result\n\n    def test_deleteDuplicates(self):\n        solution = Solution()\n        # Test case 1\n        head = self.list_to_linkedlist([1, 1, 2])\n        result = solution.deleteDuplicates(head)\n        self.assertEqual(self.linkedlist_to_list(result), [1, 2])\n        # Test case 2\n        head = self.list_to_linkedlist([1, 1, 2, 3, 3])\n        result = solution.deleteDuplicates(head)\n        self.assertEqual(self.linkedlist_to_list(result), [1, 2, 3])\n        # Test case 3\n        head = self.list_to_linkedlist([])\n        result = solution.deleteDuplicates(head)\n        self.assertEqual(self.linkedlist_to_list(result), [])\n        # Test case 4\n        head = self.list_to_linkedlist([1, 1, 1])\n        result = solution.deleteDuplicates(head)\n        self.assertEqual(self.linkedlist_to_list(result), [1])\n        # Test case 5\n        head = self.list_to_linkedlist([2, 2, 2, 3, 4, 4, 5])\n        result = solution.deleteDuplicates(head)\n        self.assertEqual(self.linkedlist_to_list(result), [2, 3, 4, 5])\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "largest-rectangle-in-histogram": {
    "solution": "class Solution:\n    def largestRectangleArea(self, heights: List[int]) -> int:\n        stack = []  # This will hold the indices of the bars\n        max_area = 0\n        heights.append(0)  # Sentinel value to ensure all bars are processed\n        for i in range(len(heights)):\n            while stack and heights[stack[-1]] > heights[i]:\n                h = heights[stack.pop()]\n                w = i if not stack else i - stack[-1] - 1\n                max_area = max(max_area, h * w)\n            stack.append(i)\n        return max_area",
    "unit_test": "import unittest\nfrom typing import List\n\nclass TestLargestRectangleArea(unittest.TestCase):\n    def test_largest_rectangle_area(self):\n        sol = Solution()\n        # Test cases\n        self.assertEqual(sol.largestRectangleArea([2, 1, 5, 6, 2, 3]), 10)\n        self.assertEqual(sol.largestRectangleArea([2, 4]), 4)\n        self.assertEqual(sol.largestRectangleArea([1, 1, 1, 1]), 4)\n        self.assertEqual(sol.largestRectangleArea([]), 0)\n        self.assertEqual(sol.largestRectangleArea([7, 1, 4, 3]), 7)\n        self.assertEqual(sol.largestRectangleArea([1, 2, 3, 4, 5]), 9)\n        self.assertEqual(sol.largestRectangleArea([5, 4, 3, 2, 1]), 9)\n        self.assertEqual(sol.largestRectangleArea([2, 1, 2]), 3)\n        self.assertEqual(sol.largestRectangleArea([0, 9]), 9)\n        self.assertEqual(sol.largestRectangleArea([1, 0, 0, 1]), 1)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "maximal-rectangle": {
    "solution": "class Solution:\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\n        if not matrix or not matrix[0]:\n            return 0\n        max_area = 0\n        heights = [0] * len(matrix[0])\n        for row in matrix:\n            for i in range(len(row)):\n                if row[i] == '1':\n                    heights[i] += 1\n                else:\n                    heights[i] = 0\n            max_area = max(max_area, self.largestRectangleArea(heights))\n        return max_area\n\n    def largestRectangleArea(self, heights: List[int]) -> int:\n        stack = []\n        max_area = 0\n        heights.append(0)  # Append a zero height to pop remaining bars\n        for i, h in enumerate(heights):\n            while stack and heights[stack[-1]] > h:\n                height = heights[stack.pop()]\n                width = i if not stack else i - stack[-1] - 1\n                max_area = max(max_area, height * width)\n            stack.append(i)\n        return max_area\n",
    "unit_test": "import unittest\n\nclass TestMaximalRectangle(unittest.TestCase):\n    def test_examples(self):\n        sol = Solution()\n        self.assertEqual(sol.maximalRectangle([['1', '0', '1', '0', '0'],\n                                                ['1', '0', '1', '1', '1'],\n                                                ['1', '1', '1', '1', '1'],\n                                                ['1', '0', '0', '1', '0']]), 6)\n        self.assertEqual(sol.maximalRectangle([['0', '0', '0', '0'],\n                                                ['0', '0', '0', '0']]), 0)\n        self.assertEqual(sol.maximalRectangle([['1', '1'],\n                                                ['1', '1']]), 4)\n        self.assertEqual(sol.maximalRectangle([['0', '1'],\n                                                ['1', '1']]), 2)\n        self.assertEqual(sol.maximalRectangle([['1']]), 1)\n        self.assertEqual(sol.maximalRectangle([]), 0)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "partition-list": {
    "solution": "class Solution:\n    def partition(self, head: ListNode, x: int) -> ListNode:\n        before_head = ListNode(0)  # Dummy node for the \"before\" list\n        before = before_head\n        after_head = ListNode(0)  # Dummy node for the \"after\" list\n        after = after_head\n\n        while head:\n            if head.val < x:\n                before.next = head  # Add to the \"before\" list\n                before = before.next\n            else:\n                after.next = head  # Add to the \"after\" list\n                after = after.next\n            head = head.next\n\n        after.next = None  # End the \"after\" list\n        before.next = after_head.next  # Connect the two lists\n\n        return before_head.next  # Return the merged list, skipping the dummy node",
    "unit_test": "import unittest\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass TestSolution(unittest.TestCase):\n    def setUp(self):\n        self.solution = Solution()\n\n    def list_to_nodes(self, lst):\n        head = ListNode(0)\n        curr = head\n        for value in lst:\n            curr.next = ListNode(value)\n            curr = curr.next\n        return head.next\n\n    def nodes_to_list(self, node):\n        lst = []\n        while node:\n            lst.append(node.val)\n            node = node.next\n        return lst\n\n    def test_partition(self):\n        test_cases = [\n            ([1, 4, 3, 2, 5, 2], 3, [1, 2, 2, 4, 3, 5]),\n            ([2, 1], 2, [1, 2]),\n            ([], 0, []),\n            ([3, 3, 3, 3], 3, [3, 3, 3, 3]),\n            ([1, 2], 3, [1, 2]),\n            ([4, 2, 3, 5, 2, 2], 3, [2, 2, 2, 4, 3, 5]),\n        ]\n\n        for i, (lst, x, expected) in enumerate(test_cases):\n            head = self.list_to_nodes(lst)\n            partitioned_head = self.solution.partition(head, x)\n            result = self.nodes_to_list(partitioned_head)\n            self.assertEqual(result, expected, f'Test case {i + 1} failed')\n\nif __name__ == \"__main__\":\n    unittest.main()"
  },
  "scramble-string": {
    "solution": "class Solution:\n    def isScramble(self, s1: str, s2: str) -> bool:\n        if len(s1) != len(s2):\n            return False\n        if s1 == s2:\n            return True\n        if sorted(s1) != sorted(s2):\n            return False\n\n        n = len(s1)\n        for i in range(1, n):\n            if (self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:])) or \n               (self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i])):\n                return True\n        return False\n",
    "unit_test": "import unittest\n\nclass TestScrambleString(unittest.TestCase):\n    def setUp(self):\n        self.solution = Solution()\n\n    def test_isScramble(self):\n        self.assertTrue(self.solution.isScramble(\"great\", \"rgeat\"))\n        self.assertFalse(self.solution.isScramble(\"abcde\", \"caebd\"))\n        self.assertTrue(self.solution.isScramble(\"a\", \"a\"))\n        self.assertFalse(self.solution.isScramble(\"a\", \"b\"))\n        self.assertTrue(self.solution.isScramble(\"abcd\", \"badc\"))\n        self.assertFalse(self.solution.isScramble(\"hello\", \"billion\"))\n        self.assertTrue(self.solution.isScramble(\"ab\", \"ba\"))\n        self.assertFalse(self.solution.isScramble(\"abc\", \"cba\"))\n        self.assertTrue(self.solution.isScramble(\"xxyyz\", \"yxyzx\"))\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "merge-sorted-array": {
    "solution": "class Solution:\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\n        i, j, k = m - 1, n - 1, m + n - 1\n        while i >= 0 and j >= 0:\n            if nums1[i] > nums2[j]:\n                nums1[k] = nums1[i]\n                i -= 1\n            else:\n                nums1[k] = nums2[j]\n                j -= 1\n            k -= 1\n        while j >= 0:\n            nums1[k] = nums2[j]\n            j -= 1\n            k -= 1\n",
    "unit_test": "import unittest\nfrom typing import List\n\nclass TestMergeSortedArray(unittest.TestCase):\n    def test_merge_sorted_array(self):\n        solution = Solution()\n        nums1 = [1,2,3,0,0,0]\n        nums2 = [2,5,6]\n        solution.merge(nums1, 3, nums2, 3)\n        self.assertEqual(nums1, [1,2,2,3,5,6])\n        \n        nums1 = [1]\n        nums2 = []\n        solution.merge(nums1, 1, nums2, 0)\n        self.assertEqual(nums1, [1])\n\n        nums1 = [0]\n        nums2 = [1]\n        solution.merge(nums1, 0, nums2, 1)\n        self.assertEqual(nums1, [1])\n\n        nums1 = [2,0]\n        nums2 = [1]\n        solution.merge(nums1, 1, nums2, 1)\n        self.assertEqual(nums1, [1,2])\n\n        nums1 = [1,2,3,0,0,0]\n        nums2 = [0,3,5]\n        solution.merge(nums1, 3, nums2, 3)\n        self.assertEqual(nums1, [0,1,2,3,3,5])\n\n        nums1 = []\n        nums2 = [1,2,3]\n        solution.merge(nums1, 0, nums2, 3)\n        self.assertEqual(nums1, [1,2,3])\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "gray-code": {
    "solution": "class Solution:\n    def grayCode(self, n: int) -> List[int]:\n        return [i ^ (i >> 1) for i in range(1 << n)]",
    "unit_test": "import unittest\nfrom typing import List\n\nclass Solution:\n    def grayCode(self, n: int) -> List[int]:\n        return [i ^ (i >> 1) for i in range(1 << n)]\n\nclass TestGrayCode(unittest.TestCase):\n    def test_gray_code(self):\n        sol = Solution()\n        self.assertEqual(sol.grayCode(0), [0])\n        self.assertEqual(sol.grayCode(1), [0, 1])\n        self.assertEqual(sol.grayCode(2), [0, 1, 3, 2])\n        self.assertEqual(sol.grayCode(3), [0, 1, 3, 2, 6, 7, 5, 4])\n        self.assertEqual(sol.grayCode(4), [0, 1, 3, 2, 6, 7, 5, 4, 12, 13, 15, 14, 10, 11, 9, 8])\n        self.assertEqual(sol.grayCode(5), [0, 1, 3, 2, 6, 7, 5, 4, 12, 13, 15, 14, 10, 11, 9, 8, 24, 25, 27, 26, 30, 31, 29, 28, 20, 21, 23, 22, 18, 19, 17, 16])\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "subsets-ii": {
    "solution": "class Solution:\n    def subsetsWithDup(self, nums):\n        res = []\n        nums.sort()\n        self.backtrack(nums, 0, [], res)\n        return res\n\n    def backtrack(self, nums, start, path, res):\n        res.append(path)\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            self.backtrack(nums, i + 1, path + [nums[i]], res)",
    "unit_test": "import unittest\n\nclass TestSubsetsII(unittest.TestCase):\n    def setUp(self):\n        self.solution = Solution()\n\n    def test_subsetsWithDup(self):\n        # Test case 1: basic test case\n        nums = [1, 2, 2]\n        expected = [[], [1], [1, 2], [1, 2, 2], [2], [2, 2]]\n        result = self.solution.subsetsWithDup(nums)\n        self.assertTrue(sorted(result) == sorted(expected))\n\n        # Test case 2: all unique elements\n        nums = [1, 2, 3]\n        expected = [[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]\n        result = self.solution.subsetsWithDup(nums)\n        self.assertTrue(sorted(result) == sorted(expected))\n\n        # Test case 3: all duplicates\n        nums = [2, 2, 2]\n        expected = [[], [2], [2, 2], [2, 2, 2]]\n        result = self.solution.subsetsWithDup(nums)\n        self.assertTrue(sorted(result) == sorted(expected))\n\n        # Test case 4: empty array\n        nums = []\n        expected = [[]]\n        result = self.solution.subsetsWithDup(nums)\n        self.assertTrue(sorted(result) == sorted(expected))\n\n        # Test case 5: mixed duplicates\n        nums = [1, 1, 2]\n        expected = [[], [1], [1, 1], [1, 2], [1, 1, 2], [2]]\n        result = self.solution.subsetsWithDup(nums)\n        self.assertTrue(sorted(result) == sorted(expected))\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "decode-ways": {
    "solution": "class Solution:\n    def numDecodings(self, s: str) -> int:\n        if not s or s[0] == '0':\n            return 0\n        n = len(s)\n        dp = [0] * (n + 1)\n        dp[0], dp[1] = 1, 1\n\n        for i in range(2, n + 1):\n            if s[i-1] != '0':\n                dp[i] += dp[i-1]\n            if 10 <= int(s[i-2:i]) <= 26:\n                dp[i] += dp[i-2]\n\n        return dp[n]",
    "unit_test": "import unittest\n\nclass TestSolution(unittest.TestCase):\n    def test_numDecodings(self):\n        sol = Solution()\n        # Test cases\n        self.assertEqual(sol.numDecodings(\"12\"), 2)  # AB, L\n        self.assertEqual(sol.numDecodings(\"226\"), 3)  # BBF, ZF, VF\n        self.assertEqual(sol.numDecodings(\"0\"), 0)    # Invalid\n        self.assertEqual(sol.numDecodings(\"06\"), 0)   # Invalid\n        self.assertEqual(sol.numDecodings(\"27\"), 1)   # BG\n        self.assertEqual(sol.numDecodings(\"1234\"), 3) # ABCD, LCD, AWCD\n        self.assertEqual(sol.numDecodings(\"111\"), 3)  # AAA, KA, AK\n        self.assertEqual(sol.numDecodings(\"1111\"), 5) # AAAA, KAA, AKA, AK, AA\n        self.assertEqual(sol.numDecodings(\"99\"), 1)   # IY\n        self.assertEqual(sol.numDecodings(\"1212\"), 5) # ABAB, ALB, AAB, LBB, LAL\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "reverse-linked-list-ii": {
    "solution": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def reverseBetween(self, head: ListNode, left: int, right: int) -> ListNode:\n        if not head or left == right:\n            return head\n\n        dummy = ListNode(0)\n        dummy.next = head\n        pre = dummy\n        for _ in range(left - 1):\n            pre = pre.next\n\n        cur = pre.next\n        tail = cur\n        for _ in range(right - left + 1):\n            tail = tail.next\n\n        # Reverse\n        prev = None\n        for _ in range(right - left + 1):\n            next_node = cur.next\n            cur.next = prev\n            prev = cur\n            cur = next_node\n\n        # Connect reversed part with the prev part\n        pre.next.next = cur\n        pre.next = prev\n\n        return dummy.next",
    "unit_test": "import unittest\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def reverseBetween(self, head: ListNode, left: int, right: int) -> ListNode:\n        if not head or left == right:\n            return head\n\n        dummy = ListNode(0)\n        dummy.next = head\n        pre = dummy\n        for _ in range(left - 1):\n            pre = pre.next\n\n        cur = pre.next\n        tail = cur\n        for _ in range(right - left + 1):\n            tail = tail.next\n\n        # Reverse\n        prev = None\n        for _ in range(right - left + 1):\n            next_node = cur.next\n            cur.next = prev\n            prev = cur\n            cur = next_node\n\n        # Connect reversed part with the prev part\n        pre.next.next = cur\n        pre.next = prev\n\n        return dummy.next\n\nclass TestSolution(unittest.TestCase):\n    def list_to_nodes(self, lst):\n        dummy = ListNode(0)\n        curr = dummy\n        for val in lst:\n            curr.next = ListNode(val)\n            curr = curr.next\n        return dummy.next\n\n    def nodes_to_list(self, node):\n        lst = []\n        while node:\n            lst.append(node.val)\n            node = node.next\n        return lst\n\n    def test_reverse_between(self):\n        sol = Solution()\n        # Test case 1: standard case\n        head = self.list_to_nodes([1, 2, 3, 4, 5])\n        result = sol.reverseBetween(head, 2, 4)\n        self.assertEqual(self.nodes_to_list(result), [1, 4, 3, 2, 5])\n\n        # Test case 2: reverse entire list\n        head = self.list_to_nodes([1, 2, 3, 4, 5])\n        result = sol.reverseBetween(head, 1, 5)\n        self.assertEqual(self.nodes_to_list(result), [5, 4, 3, 2, 1])\n\n        # Test case 3: reverse only one element (no change)\n        head = self.list_to_nodes([1, 2, 3, 4, 5])\n        result = sol.reverseBetween(head, 3, 3)\n        self.assertEqual(self.nodes_to_list(result), [1, 2, 3, 4, 5])\n\n        # Test case 4: edge case with two elements\n        head = self.list_to_nodes([1, 2])\n        result = sol.reverseBetween(head, 1, 2)\n        self.assertEqual(self.nodes_to_list(result), [2, 1])\n\n        # Test case 5: single-node list\n        head = self.list_to_nodes([1])\n        result = sol.reverseBetween(head, 1, 1)\n        self.assertEqual(self.nodes_to_list(result), [1])\n\n        # Test case 6: very large list\n        head = self.list_to_nodes(list(range(1, 101)))\n        result = sol.reverseBetween(head, 40, 60)\n        expected = list(range(1, 40)) + list(range(60, 61)) + list(range(59, 39, -1)) + list(range(61, 101))\n        self.assertEqual(self.nodes_to_list(result), expected)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "restore-ip-addresses": {
    "solution": "class Solution:\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        def is_valid(segment):\n            # Check if the segment is valid (0-255 and doesn't have leading zero)\n            return int(segment) <= 255 and str(int(segment)) == segment\n\n        def backtrack(start=0, parts=[]):\n            if len(parts) == 4 and start == len(s):\n                result.append('.'.join(parts))\n                return\n            if len(parts) > 4:\n                return\n\n            for length in range(1, 4):\n                if start + length <= len(s):\n                    segment = s[start:start + length]\n                    if is_valid(segment):\n                        backtrack(start + length, parts + [segment])\n\n        result = []\n        backtrack()\n        return result",
    "unit_test": "import unittest\n\nclass TestRestoreIpAddresses(unittest.TestCase):\n    def setUp(self):\n        self.solution = Solution()\n\n    def test_examples(self):\n        # Example 1\n        self.assertEqual(sorted(self.solution.restoreIpAddresses('25525511135')), sorted(['255.255.11.135', '255.255.111.35']))\n        # Example 2\n        self.assertEqual(sorted(self.solution.restoreIpAddresses('0000')), sorted(['0.0.0.0']))\n        # Example 3\n        self.assertEqual(self.solution.restoreIpAddresses('1111'), ['1.1.1.1'])\n        # Example 4\n        self.assertEqual(self.solution.restoreIpAddresses('010010'), ['0.10.0.10', '0.100.1.0'])\n        # Example 5\n        self.assertEqual(self.solution.restoreIpAddresses('101023'), sorted(['1.0.10.23', '1.0.102.3', '10.1.0.23', '10.10.2.3', '101.0.2.3']))\n\n    def test_invalid_cases(self):\n        # Test case with more than 12 chars\n        self.assertEqual(self.solution.restoreIpAddresses('255255255255255'), []) \n        # Test case with invalid segments\n        self.assertEqual(self.solution.restoreIpAddresses('256256256256'), [])\n        self.assertEqual(self.solution.restoreIpAddresses('255.255.255.255255'), [])\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "binary-tree-inorder-traversal": {
    "solution": "class Solution:\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        result = []\n        self._inorder_helper(root, result)\n        return result\n\n    def _inorder_helper(self, node: Optional[TreeNode], result: List[int]):\n        if node is not None:\n            self._inorder_helper(node.left, result)  # Traverse left subtree\n            result.append(node.val)                  # Visit node\n            self._inorder_helper(node.right, result) # Traverse right subtree\n",
    "unit_test": "import unittest\n\nclass TestBinaryTreeInorderTraversal(unittest.TestCase):\n\n    class TreeNode:\n        def __init__(self, val=0, left=None, right=None):\n            self.val = val\n            self.left = left\n            self.right = right\n\n    def test_inorder_traversal(self):\n        sol = Solution()\n\n        # Test case 1: A simple binary tree\n        root1 = self.TreeNode(1)\n        root1.right = self.TreeNode(2)\n        root1.right.left = self.TreeNode(3)\n        expected1 = [1, 3, 2]\n        self.assertEqual(sol.inorderTraversal(root1), expected1)\n\n        # Test case 2: A tree with a single node\n        root2 = self.TreeNode(10)\n        expected2 = [10]\n        self.assertEqual(sol.inorderTraversal(root2), expected2)\n\n        # Test case 3: A tree that is left-heavy\n        root3 = self.TreeNode(3)\n        root3.left = self.TreeNode(2)\n        root3.left.left = self.TreeNode(1)\n        expected3 = [1, 2, 3]\n        self.assertEqual(sol.inorderTraversal(root3), expected3)\n\n        # Test case 4: A tree that is right-heavy\n        root4 = self.TreeNode(1)\n        root4.right = self.TreeNode(2)\n        root4.right.right = self.TreeNode(3)\n        expected4 = [1, 2, 3]\n        self.assertEqual(sol.inorderTraversal(root4), expected4)\n\n        # Test case 5: Empty tree\n        root5 = None\n        expected5 = []\n        self.assertEqual(sol.inorderTraversal(root5), expected5)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "unique-binary-search-trees-ii": {
    "solution": "class Solution:\n    def generateTrees(self, n: int):\n        if n == 0:\n            return []\n        return self._generate_trees(1, n)\n\n    def _generate_trees(self, start: int, end: int):\n        if start > end:\n            return [None]\n\n        all_trees = []\n        for i in range(start, end + 1):\n            # generate all left subtrees\n            left_trees = self._generate_trees(start, i - 1)\n            # generate all right subtrees\n            right_trees = self._generate_trees(i + 1, end)\n\n            # combine left and right trees with the root i\n            for left in left_trees:\n                for right in right_trees:\n                    current_tree = TreeNode(i)\n                    current_tree.left = left\n                    current_tree.right = right\n                    all_trees.append(current_tree)\n        return all_trees\n\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right",
    "unit_test": "import unittest\n\nclass TestUniqueBinarySearchTreesII(unittest.TestCase):\n    def setUp(self):\n        self.solution = Solution()\n\n    def test_generate_trees_0(self):\n        self.assertEqual(self.solution.generateTrees(0), [])\n\n    def test_generate_trees_1(self):\n        result = self.solution.generateTrees(1)\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0].val, 1)\n\n    def test_generate_trees_2(self):\n        result = self.solution.generateTrees(2)\n        self.assertEqual(len(result), 2)\n\n    def test_generate_trees_3(self):\n        result = self.solution.generateTrees(3)\n        self.assertEqual(len(result), 5)\n\n    def test_generate_trees_4(self):\n        result = self.solution.generateTrees(4)\n        self.assertEqual(len(result), 14)\n\n    def test_generate_trees_5(self):\n        result = self.solution.generateTrees(5)\n        self.assertEqual(len(result), 42)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "unique-binary-search-trees": {
    "solution": "class Solution:\n    def numTrees(self, n: int) -> int:\n        # Create an array to store results of subproblems\n        dp = [0] * (n + 1)\n        # There is one unique BST for 0 or 1 nodes\n        dp[0], dp[1] = 1, 1\n\n        # Fill dp array for each count of nodes from 2 to n\n        for nodes in range(2, n + 1):\n            for root in range(1, nodes + 1):\n                left_trees = dp[root - 1]  # Number of unique left BSTs\n                right_trees = dp[nodes - root]  # Number of unique right BSTs\n                dp[nodes] += left_trees * right_trees\n\n        return dp[n]\n",
    "unit_test": "import unittest\n\nclass TestSolution(unittest.TestCase):\n    def test_num_trees(self):\n        solution = Solution()\n        # Test cases to verify the correctness of the solution\n        self.assertEqual(solution.numTrees(0), 1)  # Base case: 0 nodes\n        self.assertEqual(solution.numTrees(1), 1)  # Base case: 1 node\n        self.assertEqual(solution.numTrees(2), 2)  # BSTs: [1,2], [2,1]\n        self.assertEqual(solution.numTrees(3), 5)  # BSTs: 5 unique BSTs\n        self.assertEqual(solution.numTrees(4), 14) # BSTs: 14 unique BSTs\n        self.assertEqual(solution.numTrees(5), 42) # BSTs: 42 unique BSTs\n        self.assertEqual(solution.numTrees(6), 132) # BSTs: 132 unique BSTs\n        self.assertEqual(solution.numTrees(7), 429) # BSTs: 429 unique BSTs\n        self.assertEqual(solution.numTrees(8), 1430) # BSTs: 1430 unique BSTs\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "interleaving-string": {
    "solution": "class Solution:\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n        if len(s1) + len(s2) != len(s3):\n            return False\n        dp = [[False] * (len(s2) + 1) for _ in range(len(s1) + 1)]\n        dp[0][0] = True\n\n        for i in range(1, len(s1) + 1):\n            dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]\n\n        for j in range(1, len(s2) + 1):\n            dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]\n\n        for i in range(1, len(s1) + 1):\n            for j in range(1, len(s2) + 1):\n                dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or \\\n                            (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n\n        return dp[len(s1)][len(s2)]",
    "unit_test": "import unittest\n\nclass TestInterleavingString(unittest.TestCase):\n    def test_interleaving(self):\n        solution = Solution()\n        self.assertTrue(solution.isInterleave(\"aab\", \"xyz\", \"aaxyzb\"))\n        self.assertFalse(solution.isInterleave(\"aabcc\", \"dbbca\", \"aadbbcbcac\"))\n        self.assertTrue(solution.isInterleave(\"\", \"\", \"\"))\n        self.assertFalse(solution.isInterleave(\"abc\", \"def\", \"abdecf\"))\n        self.assertTrue(solution.isInterleave(\"\", \"abc\", \"abc\"))\n        self.assertTrue(solution.isInterleave(\"a\", \"b\", \"ab\"))\n        self.assertFalse(solution.isInterleave(\"ab\", \"ab\", \"ababab\"))\n        self.assertTrue(solution.isInterleave(\"ab\", \"ab\", \"abab\"))\n        self.assertFalse(solution.isInterleave(\"abaac\", \"aacaa\", \"aacabaab\"))\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "validate-binary-search-tree": {
    "solution": "class Solution:\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\n        def validate(node, low=float('-inf'), high=float('inf')):\n            if not node:\n                return True\n            if not (low < node.val < high):\n                return False\n            return validate(node.left, low, node.val) and validate(node.right, node.val, high)\n\n        return validate(root)",
    "unit_test": "import unittest\n\nclass TestSolution(unittest.TestCase):\n    def test_isValidBST(self):\n        sol = Solution()\n\n        # Test case 1: Valid BST\n        root1 = TreeNode(2)\n        root1.left = TreeNode(1)\n        root1.right = TreeNode(3)\n        self.assertTrue(sol.isValidBST(root1))\n\n        # Test case 2: Invalid BST (3 is not less than 2)\n        root2 = TreeNode(5)\n        root2.left = TreeNode(1)\n        root2.right = TreeNode(4)\n        root2.right.left = TreeNode(3)\n        root2.right.right = TreeNode(6)\n        self.assertFalse(sol.isValidBST(root2))\n\n        # Test case 3: Empty tree (should be valid)\n        root3 = None\n        self.assertTrue(sol.isValidBST(root3))\n\n        # Test case 4: Single node tree (should be valid)\n        root4 = TreeNode(1)\n        self.assertTrue(sol.isValidBST(root4))\n\n        # Test case 5: Larger valid BST\n        root5 = TreeNode(10)\n        root5.left = TreeNode(5)\n        root5.right = TreeNode(15)\n        root5.right.left = TreeNode(11)\n        root5.right.right = TreeNode(20)\n        self.assertTrue(sol.isValidBST(root5))\n\n        # Test case 6: Larger invalid BST\n        root6 = TreeNode(10)\n        root6.left = TreeNode(5)\n        root6.right = TreeNode(15)\n        root6.right.left = TreeNode(12)\n        root6.right.right = TreeNode(7)  # 7 is not > 10\n        self.assertFalse(sol.isValidBST(root6))\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "recover-binary-search-tree": {
    "solution": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def recoverTree(self, root: TreeNode) -> None:\n        # Initialize variables for nodes to swap\n        self.first = self.second = None\n        self.prev = None\n\n        # In-order traversal to find two swapped nodes\n        def inorder(node):\n            if not node:\n                return\n            inorder(node.left)\n            # If the previous node is greater than the current node, we have an anomaly\n            if self.prev and self.prev.val > node.val:\n                if not self.first:\n                    self.first = self.prev\n                self.second = node\n            self.prev = node\n            inorder(node.right)\n\n        inorder(root)\n        # Swap the values of the first and second nodes\n        if self.first and self.second:\n            self.first.val, self.second.val = self.second.val, self.first.val\n",
    "unit_test": "import unittest\n\nclass TestRecoverBinarySearchTree(unittest.TestCase):\n    def create_tree(self, values):\n        if not values:\n            return None\n        nodes = [TreeNode(val) if val is not None else None for val in values]\n        kid_nodes = nodes[::-1]\n        root = kid_nodes.pop()\n        for node in nodes:\n            if node:\n                if kid_nodes:\n                    node.left = kid_nodes.pop()\n                if kid_nodes:\n                    node.right = kid_nodes.pop()\n        return root\n\n    def test_recoverTree(self):\n        solution = Solution()\n        # Test case 1\n        root = self.create_tree([1, 3, None, None, 2])\n        solution.recoverTree(root)\n        self.assertEqual(root.val, 3)\n        self.assertEqual(root.left.val, 2)\n\n        # Test case 2\n        root = self.create_tree([3, 1, 4, None, None, 2])\n        solution.recoverTree(root)\n        self.assertEqual(root.val, 2)\n        self.assertEqual(root.right.val, 4)\n        self.assertEqual(root.left.val, 1)\n\n        # Test case 3 - No swap needed\n        root = self.create_tree([2, 1, 3])\n        solution.recoverTree(root)\n        self.assertEqual(root.val, 2)\n        self.assertEqual(root.left.val, 1)\n        self.assertEqual(root.right.val, 3)\n\n        # Test case 4 - Larger tree with swaps\n        root = self.create_tree([5, 3, 8, 1, 4, 7, 9])\n        root.left.val, root.right.val = root.right.val, root.left.val  # Swap 3 and 8\n        solution.recoverTree(root)\n        self.assertEqual(root.val, 5)\n        self.assertEqual(root.left.val, 8)\n        self.assertEqual(root.right.val, 3)\n\nif __name__ == '__main__':\n    unittest.main()"
  },
  "same-tree": {
    "solution": "class Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p and not q:\n            return True  # Both trees are empty\n        if not p or not q:\n            return False  # One of the trees is empty\n        if p.val != q.val:\n            return False  # Values are different\n        # Check the left and right subtrees\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)",
    "unit_test": "import unittest\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass TestSolution(unittest.TestCase):\n\n    def test_isSameTree(self):\n        sol = Solution()\n        # Example 1: Same trees\n        p1 = TreeNode(1)\n        p1.left = TreeNode(2)\n        p1.right = TreeNode(3)\n        q1 = TreeNode(1)\n        q1.left = TreeNode(2)\n        q1.right = TreeNode(3)\n        self.assertTrue(sol.isSameTree(p1, q1))\n\n        # Example 2: Different trees\n        p2 = TreeNode(1)\n        p2.left = TreeNode(2)\n        q2 = TreeNode(1)\n        q2.right = TreeNode(2)\n        self.assertFalse(sol.isSameTree(p2, q2))\n\n        # Example 3: One tree empty\n        p3 = None\n        q3 = TreeNode(1)\n        self.assertFalse(sol.isSameTree(p3, q3))\n\n        # Example 4: Both trees empty\n        p4 = None\n        q4 = None\n        self.assertTrue(sol.isSameTree(p4, q4))\n\n        # Example 5: Same single-node trees\n        p5 = TreeNode(1)\n        q5 = TreeNode(1)\n        self.assertTrue(sol.isSameTree(p5, q5))\n\n        # Example 6: More complex same trees\n        p6 = TreeNode(1)\n        p6.left = TreeNode(2)\n        p6.right = TreeNode(3)\n        p6.left.left = TreeNode(4)\n        p6.left.right = TreeNode(5)\n        q6 = TreeNode(1)\n        q6.left = TreeNode(2)\n        q6.right = TreeNode(3)\n        q6.left.left = TreeNode(4)\n        q6.left.right = TreeNode(5)\n        self.assertTrue(sol.isSameTree(p6, q6))\n\n        # Example 7: Different value\n        p7 = TreeNode(1)\n        p7.left = TreeNode(2)\n        p7.right = TreeNode(3)\n        q7 = TreeNode(1)\n        q7.left = TreeNode(2)\n        q7.right = TreeNode(4)\n        self.assertFalse(sol.isSameTree(p7, q7))\n\nif __name__ == '__main__':\n    unittest.main()"
  }
}
