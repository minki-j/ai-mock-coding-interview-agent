{
    "content": "<p>Write a function to find the longest common prefix string amongst an array of strings.</p>\n\n<p>If there is no common prefix, return an empty string <code>&quot;&quot;</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> strs = [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]\n<strong>Output:</strong> &quot;fl&quot;\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> strs = [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]\n<strong>Output:</strong> &quot;&quot;\n<strong>Explanation:</strong> There is no common prefix among the input strings.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= strs.length &lt;= 200</code></li>\n\t<li><code>0 &lt;= strs[i].length &lt;= 200</code></li>\n\t<li><code>strs[i]</code> consists of only lowercase English letters.</li>\n</ul>\n",
    "difficulty": "Easy",
    "title": "Longest Common Prefix",
    "topicTags": [
        {
            "name": "String"
        },
        {
            "name": "Trie"
        }
    ],
    "solution": {
        "content": "[TOC]\n\n## Video Solution\n---\n\n<div class='video-preview'></div>\n\n<div>&nbsp;\n</div>\n\n## Solution Article\n\n---\n\n\n### Approach 1: Horizontal scanning\n\n#### Intuition\n\nFor a start we will describe a simple way of finding the longest prefix shared by a set of strings $$LCP(S_1  \\ldots  S_n)$$.\nWe will use the observation that :\n\n$$LCP(S_1 \\ldots S_n) = LCP(LCP(LCP(S_1, S_2),S_3),\\ldots S_n)$$\n\n#### Algorithm\n\n To employ this idea, the algorithm iterates through the strings $$[S_1  \\ldots  S_n]$$, finding at each iteration $$i$$ the longest common prefix of strings $$LCP(S_1  \\ldots  S_i)$$ When $$LCP(S_1  \\ldots  S_i)$$ is an empty string, the algorithm ends. Otherwise after $$n$$ iterations, the algorithm returns $$LCP(S_1  \\ldots  S_n)$$.\n\n ![Finding the longest common prefix](https://leetcode.com/media/original_images/14_basic.png){:width=\"539px\"}\n \n\n *Figure 1. Finding the longest common prefix (Horizontal scanning)*\n \n#### Implementation\n\n<div>'class Solution:\\n\tdef longestCommonPrefix(self, strs: List[str]) -> str:\\n\t\tif len(strs) == 0:\\n\t\t\treturn \"\"\\n\t\tprefix = strs[0]\\n\t\tfor i in range(1, len(strs)):\\n\t\t\twhile strs[i].find(prefix) != 0:\\n\t\t\t\tprefix = prefix[0 : len(prefix) - 1]\\n\t\t\t\tif prefix == \"\":\\n\t\t\t\t\treturn \"\"\\n\t\treturn prefix</div>\n\n#### Complexity Analysis\n\n* Time complexity : $$O(S)$$ , where S is the sum of all characters in all strings.\n\n    In the worst case all $$n$$ strings are the same. The algorithm compares the string $$S1$$ with the other strings $$[S_2 \\ldots S_n]$$ There are $$S$$ character comparisons, where $$S$$ is the sum of all characters in the input array.\n\n* Space complexity : $$O(1)$$. We only used constant extra space.\n\n---\n\n### Approach 2: Vertical scanning\n\n#### Algorithm\n\nImagine a very short string is the common prefix at the end of the array. The above approach will still do $$S$$ comparisons. One way to optimize this case is to do vertical scanning. We compare characters from top to bottom on the same column (same character index of  the strings) before moving on to the next column.\n\n#### Implementation\n\n<div>'class Solution:\\n\tdef longestCommonPrefix(self, strs: List[str]) -> str:\\n\t\tif strs == None or len(strs) == 0:\\n\t\t\treturn \"\"\\n\t\tfor i in range(len(strs[0])):\\n\t\t\tc = strs[0][i]\\n\t\t\tfor j in range(1, len(strs)):\\n\t\t\t\tif i == len(strs[j]) or strs[j][i] != c:\\n\t\t\t\t\treturn strs[0][0:i]\\n\t\treturn strs[0]'</div>\n\n#### Complexity Analysis\n\n* Time complexity : $$O(S)$$ , where S is the sum of all characters in all strings.\nIn the worst case there will be $$n$$ equal strings with length $$m$$ and the algorithm performs  $$S = m \\cdot n$$ character comparisons.\nEven though the worst case is still the same as [Approach 1](#approach-1-horizontal-scanning), in the best case there are at most $$n \\cdot minLen$$ comparisons where $$minLen$$ is the length of the shortest string in the array.\n* Space complexity : $$O(1)$$. We only used constant extra space.\n\n---\n\n### Approach 3: Divide and conquer\n\n#### Intuition\n\nThe idea of the algorithm comes from the associative property of LCP operation. We notice that :\n$$LCP(S_1 \\ldots S_n) = LCP(LCP(S_1 \\ldots S_k), LCP (S_{k+1} \\ldots S_n))$$\n, where $$LCP(S_1 \\ldots S_n)$$ is the longest common prefix in set of strings $$[S_1 \\ldots S_n]$$ , $$1 < k < n$$\n\n#### Algorithm\n\nTo apply the observation above, we use divide and conquer technique, where we split the $$LCP(S_i \\ldots S_j)$$ problem into two subproblems $$LCP(S_i \\ldots S_{mid})$$   and $$LCP(S_{mid+1} \\ldots S_j)$$, where `mid` is $$\\frac{i + j}{2}$$. We use their solutions `lcpLeft` and `lcpRight` to construct the solution of the main problem $$LCP(S_i \\ldots S_j)$$. To accomplish this we compare one by one the characters of `lcpLeft` and `lcpRight` till there is no character match. The found common prefix of `lcpLeft` and `lcpRight` is the solution of the  $$LCP(S_i \\ldots S_j)$$.\n\n![Finding the longest common prefix](https://leetcode.com/media/original_images/14_lcp_diviso_et_lmpera.png){:width=\"539px\"}\n\n\n*Figure 2. Finding the longest common prefix of strings using divide and conquer technique*\n\n#### Implementation\n\n<div>class Solution:\\n\tdef longestCommonPrefix(self, strs: List[str]) -> str:\\n\t\tif strs == None or len(strs) == 0:\\n\t\t\treturn \"\"\\n\t\tfor i in range(len(strs[0])):\\n\t\t\tc = strs[0][i]\\n\t\t\tfor j in range(1, len(strs)):\\n\t\t\t\tif i == len(strs[j]) or strs[j][i] != c:\\n\t\t\t\t\treturn strs[0][0:i]\\n\t\treturn strs[0]</div>\n\n#### Complexity Analysis\n\nIn the worst case we have $$n$$ equal strings with length $$m$$\n\n* Time complexity : $$O(S)$$, where $$S$$ is the number of all characters in the array, $$S = m \\cdot n$$\n Time complexity is $$2 \\cdot T\\left ( \\frac{n}{2} \\right ) + O(m)$$. Therefore time complexity is $$O(S)$$.\n  In the best case this algorithm performs  $$O(minLen \\cdot n)$$ comparisons, where  $$minLen$$ is the shortest string of the array\n\n* Space complexity : $$O(m \\cdot \\log n)$$\n\n    There is a memory overhead since we store recursive calls in the execution stack. There are $$\\log n$$ recursive calls, each store need $$m$$ space to store the result,  so space complexity is $$O(m \\cdot \\log n)$$\n\n\n---\n\n### Approach 4: Binary search\n\n#### Intuition\n\nThe idea is to apply binary search method to find the string with maximum value `L`, which is common prefix of all of the strings. The algorithm searches space is the interval $$(0 \\ldots minLen)$$, where `minLen` is minimum string length and the maximum possible common prefix. Each time search space is divided in two equal parts, one of them is discarded, because it is sure that it doesn't contain the solution. There are two possible cases:\n* `S[1...mid]` is not a common string. This means that for each `j > i S[1..j]` is not a common string and we discard the second half of the  search space.\n* `S[1...mid]` is common string. This means that for each `i < j S[1..i]` is a common string and we discard the first half of the search space, because we try to find longer common prefix.\n\n![Finding the longest common prefix](https://leetcode.com/media/original_images/14_lcp_binary_search.png){:width=\"539px\"}\n\n\n*Figure 3. Finding the longest common prefix of strings using binary search technique*\n\n#### Implementation\n\n<div>class Solution:\\n\tdef longestCommonPrefix(self, strs: List[str]) -> str:\\n\t\tif not strs:\\n\t\t\treturn \"\"\\n\t\tminLen = min(len(x) for x in strs)\\n\t\tlow, high = 1, minLen\\n\t\twhile low <= high:\\n\t\t\tmiddle = (low + high) // 2\\n\t\t\tif self.isCommonPrefix(strs, middle):\\n\t\t\t\tlow = middle + 1\\n\t\t\telse:\\n\t\t\t\thigh = middle - 1\\n\t\treturn strs[0][: (low + high) // 2]\\n\\n\tdef isCommonPrefix(self, strs, l):\\n\t\tstr1 = strs[0][:l]\\n\t\tfor i in range(1, len(strs)):\\n\t\t\tif not strs[i].startswith(str1):\\n\t\t\t\treturn False\\n\t\treturn True<div>\n\n#### Complexity Analysis\n\nIn the worst case we have $$n$$ equal strings with length $$m$$\n\n* Time complexity : $$O(S \\cdot \\log m)$$, where $$S$$ is the sum of all characters in all strings.\n\n    The algorithm makes $$\\log m$$ iterations, for each of them there are $$S = m \\cdot n$$ comparisons, which gives in total $$O(S \\cdot \\log m)$$ time complexity.\n\n* Space complexity : $$O(1)$$. We only used constant extra space.\n\n---\n\n### Further Thoughts / Follow up\n\nLet's take a look at a slightly different problem:\n\n> Given a set of keys S = $$[S_1,S_2 \\ldots S_n]$$, find the longest common prefix among a string `q` and S. This LCP query will be called frequently.\n\nWe could optimize LCP queries by storing the set of keys S in a Trie. For more information about Trie, please see this article [Implement a trie (Prefix trie)](https://leetcode.com/articles/implement-trie-prefix-tree/). In a Trie, each node descending from the root represents a common prefix of some keys. But we need to find the longest common prefix of a string `q` and all key strings. This means that we have to find the deepest path from the root, which satisfies the following conditions:\n* it is prefix of query string `q`\n* each node along the path must contain only one child element. Otherwise the found path will not be a common prefix among all strings.\n* the path doesn't comprise of nodes which are marked as end of key. Otherwise the path couldn't be a prefix a of key which is shorter than itself.\n\n#### Algorithm\n\nThe only question left, is how to find the deepest path in the Trie, that fulfills the requirements above. The most effective way is to build a trie from $$[S_1 \\ldots   S_n]$$ strings. Then find the prefix of query string `q` in the Trie. We traverse the Trie from the root, till it is impossible to continue the path in the Trie because one of the conditions above is not satisfied.\n\n![Finding the longest common prefix using Trie](https://leetcode.com/media/original_images/14_lcp_trie.png){:width=\"539px\"}\n\n\n*Figure 4. Finding the longest common prefix of strings using Trie*\n\n#### Implementation\n\n<div>class Solution:\\n\tdef longestCommonPrefix(self, strs: List[str]) -> str:\\n\t\tif not strs:\\n\t\t\treturn \"\"\\n\t\tminLen = min(len(x) for x in strs)\\n\t\tlow, high = 1, minLen\\n\t\twhile low <= high:\\n\t\t\tmiddle = (low + high) // 2\\n\t\t\tif self.isCommonPrefix(strs, middle):\\n\t\t\t\tlow = middle + 1\\n\t\t\telse:\\n\t\t\t\thigh = middle - 1\\n\t\treturn strs[0][: (low + high) // 2]\\n\\n\tdef isCommonPrefix(self, strs, l):\\n\t\tstr1 = strs[0][:l]\\n\t\tfor i in range(1, len(strs)):\\n\t\t\tif not strs[i].startswith(str1):\\n\t\t\t\treturn False\\n\t\treturn True</div>\n\n#### Complexity Analysis\n\nIn the worst case query $$q$$ has length $$m$$ and it is equal to all $$n$$ strings of the array.\n\n* Time complexity : preprocessing $$O(S)$$, where $$S$$ is the number of all characters in the array, LCP query $$O(m)$$.\n\n    Trie build has $$O(S)$$ time complexity. To find the common prefix of $$q$$ in the Trie takes in the worst case $$O(m)$$.\n\n* Space complexity : $$O(S)$$. We only used additional  $$S$$ extra space for the Trie."
    },
    "solution_md": "\\[TOC]\n\n\\#\\# Video Solution\n\\-\\-\\-\n\n\n\u00a0\n\n\n\\#\\# Solution Article\n\n\\-\\-\\-\n\n\n\\#\\#\\# Approach 1: Horizontal scanning\n\n\\#\\#\\#\\# Intuition\n\nFor a start we will describe a simple way of finding the longest prefix shared by a set of strings $$LCP(S\\_1 \\\\ldots S\\_n)$$.\nWe will use the observation that :\n\n$$LCP(S\\_1 \\\\ldots S\\_n) \\= LCP(LCP(LCP(S\\_1, S\\_2\\),S\\_3\\),\\\\ldots S\\_n)$$\n\n\\#\\#\\#\\# Algorithm\n\n To employ this idea, the algorithm iterates through the strings $$\\[S\\_1 \\\\ldots S\\_n]$$, finding at each iteration $$i$$ the longest common prefix of strings $$LCP(S\\_1 \\\\ldots S\\_i)$$ When $$LCP(S\\_1 \\\\ldots S\\_i)$$ is an empty string, the algorithm ends. Otherwise after $$n$$ iterations, the algorithm returns $$LCP(S\\_1 \\\\ldots S\\_n)$$.\n\n !\\[Finding the longest common prefix](https://leetcode.com/media/original\\_images/14\\_basic.png){:width\\=\"539px\"}\n \n\n \\*Figure 1\\. Finding the longest common prefix (Horizontal scanning)\\*\n \n\\#\\#\\#\\# Implementation\n\n'class Solution:\\\\n def longestCommonPrefix(self, strs: List\\[str]) \\-\\> str:\\\\n if len(strs) \\=\\= 0:\\\\n return \"\"\\\\n prefix \\= strs\\[0]\\\\n for i in range(1, len(strs)):\\\\n while strs\\[i].find(prefix) !\\= 0:\\\\n prefix \\= prefix\\[0 : len(prefix) \\- 1]\\\\n if prefix \\=\\= \"\":\\\\n return \"\"\\\\n return prefix\n\n\\#\\#\\#\\# Complexity Analysis\n\n\\* Time complexity : $$O(S)$$ , where S is the sum of all characters in all strings.\n\n In the worst case all $$n$$ strings are the same. The algorithm compares the string $$S1$$ with the other strings $$\\[S\\_2 \\\\ldots S\\_n]$$ There are $$S$$ character comparisons, where $$S$$ is the sum of all characters in the input array.\n\n\\* Space complexity : $$O(1\\)$$. We only used constant extra space.\n\n\\-\\-\\-\n\n\\#\\#\\# Approach 2: Vertical scanning\n\n\\#\\#\\#\\# Algorithm\n\nImagine a very short string is the common prefix at the end of the array. The above approach will still do $$S$$ comparisons. One way to optimize this case is to do vertical scanning. We compare characters from top to bottom on the same column (same character index of the strings) before moving on to the next column.\n\n\\#\\#\\#\\# Implementation\n\n'class Solution:\\\\n def longestCommonPrefix(self, strs: List\\[str]) \\-\\> str:\\\\n if strs \\=\\= None or len(strs) \\=\\= 0:\\\\n return \"\"\\\\n for i in range(len(strs\\[0])):\\\\n c \\= strs\\[0]\\[i]\\\\n for j in range(1, len(strs)):\\\\n if i \\=\\= len(strs\\[j]) or strs\\[j]\\[i] !\\= c:\\\\n return strs\\[0]\\[0:i]\\\\n return strs\\[0]'\n\n\\#\\#\\#\\# Complexity Analysis\n\n\\* Time complexity : $$O(S)$$ , where S is the sum of all characters in all strings.\nIn the worst case there will be $$n$$ equal strings with length $$m$$ and the algorithm performs $$S \\= m \\\\cdot n$$ character comparisons.\nEven though the worst case is still the same as \\[Approach 1](\\#approach\\-1\\-horizontal\\-scanning), in the best case there are at most $$n \\\\cdot minLen$$ comparisons where $$minLen$$ is the length of the shortest string in the array.\n\\* Space complexity : $$O(1\\)$$. We only used constant extra space.\n\n\\-\\-\\-\n\n\\#\\#\\# Approach 3: Divide and conquer\n\n\\#\\#\\#\\# Intuition\n\nThe idea of the algorithm comes from the associative property of LCP operation. We notice that :\n$$LCP(S\\_1 \\\\ldots S\\_n) \\= LCP(LCP(S\\_1 \\\\ldots S\\_k), LCP (S\\_{k\\+1} \\\\ldots S\\_n))$$\n, where $$LCP(S\\_1 \\\\ldots S\\_n)$$ is the longest common prefix in set of strings $$\\[S\\_1 \\\\ldots S\\_n]$$ , $$1 \\< k \\< n$$\n\n\\#\\#\\#\\# Algorithm\n\nTo apply the observation above, we use divide and conquer technique, where we split the $$LCP(S\\_i \\\\ldots S\\_j)$$ problem into two subproblems $$LCP(S\\_i \\\\ldots S\\_{mid})$$ and $$LCP(S\\_{mid\\+1} \\\\ldots S\\_j)$$, where \\`mid\\` is $$\\\\frac{i \\+ j}{2}$$. We use their solutions \\`lcpLeft\\` and \\`lcpRight\\` to construct the solution of the main problem $$LCP(S\\_i \\\\ldots S\\_j)$$. To accomplish this we compare one by one the characters of \\`lcpLeft\\` and \\`lcpRight\\` till there is no character match. The found common prefix of \\`lcpLeft\\` and \\`lcpRight\\` is the solution of the $$LCP(S\\_i \\\\ldots S\\_j)$$.\n\n!\\[Finding the longest common prefix](https://leetcode.com/media/original\\_images/14\\_lcp\\_diviso\\_et\\_lmpera.png){:width\\=\"539px\"}\n\n\n\\*Figure 2\\. Finding the longest common prefix of strings using divide and conquer technique\\*\n\n\\#\\#\\#\\# Implementation\n\nclass Solution:\\\\n def longestCommonPrefix(self, strs: List\\[str]) \\-\\> str:\\\\n if strs \\=\\= None or len(strs) \\=\\= 0:\\\\n return \"\"\\\\n for i in range(len(strs\\[0])):\\\\n c \\= strs\\[0]\\[i]\\\\n for j in range(1, len(strs)):\\\\n if i \\=\\= len(strs\\[j]) or strs\\[j]\\[i] !\\= c:\\\\n return strs\\[0]\\[0:i]\\\\n return strs\\[0]\n\n\\#\\#\\#\\# Complexity Analysis\n\nIn the worst case we have $$n$$ equal strings with length $$m$$\n\n\\* Time complexity : $$O(S)$$, where $$S$$ is the number of all characters in the array, $$S \\= m \\\\cdot n$$\n Time complexity is $$2 \\\\cdot T\\\\left ( \\\\frac{n}{2} \\\\right ) \\+ O(m)$$. Therefore time complexity is $$O(S)$$.\n In the best case this algorithm performs $$O(minLen \\\\cdot n)$$ comparisons, where $$minLen$$ is the shortest string of the array\n\n\\* Space complexity : $$O(m \\\\cdot \\\\log n)$$\n\n There is a memory overhead since we store recursive calls in the execution stack. There are $$\\\\log n$$ recursive calls, each store need $$m$$ space to store the result, so space complexity is $$O(m \\\\cdot \\\\log n)$$\n\n\n\\-\\-\\-\n\n\\#\\#\\# Approach 4: Binary search\n\n\\#\\#\\#\\# Intuition\n\nThe idea is to apply binary search method to find the string with maximum value \\`L\\`, which is common prefix of all of the strings. The algorithm searches space is the interval $$(0 \\\\ldots minLen)$$, where \\`minLen\\` is minimum string length and the maximum possible common prefix. Each time search space is divided in two equal parts, one of them is discarded, because it is sure that it doesn't contain the solution. There are two possible cases:\n\\* \\`S\\[1\\...mid]\\` is not a common string. This means that for each \\`j \\> i S\\[1\\..j]\\` is not a common string and we discard the second half of the search space.\n\\* \\`S\\[1\\...mid]\\` is common string. This means that for each \\`i \\< j S\\[1\\..i]\\` is a common string and we discard the first half of the search space, because we try to find longer common prefix.\n\n!\\[Finding the longest common prefix](https://leetcode.com/media/original\\_images/14\\_lcp\\_binary\\_search.png){:width\\=\"539px\"}\n\n\n\\*Figure 3\\. Finding the longest common prefix of strings using binary search technique\\*\n\n\\#\\#\\#\\# Implementation\n\nclass Solution:\\\\n def longestCommonPrefix(self, strs: List\\[str]) \\-\\> str:\\\\n if not strs:\\\\n return \"\"\\\\n minLen \\= min(len(x) for x in strs)\\\\n low, high \\= 1, minLen\\\\n while low \\<\\= high:\\\\n middle \\= (low \\+ high) // 2\\\\n if self.isCommonPrefix(strs, middle):\\\\n low \\= middle \\+ 1\\\\n else:\\\\n high \\= middle \\- 1\\\\n return strs\\[0]\\[: (low \\+ high) // 2]\\\\n\\\\n def isCommonPrefix(self, strs, l):\\\\n str1 \\= strs\\[0]\\[:l]\\\\n for i in range(1, len(strs)):\\\\n if not strs\\[i].startswith(str1\\):\\\\n return False\\\\n return True\n\n\\#\\#\\#\\# Complexity Analysis\n\nIn the worst case we have $$n$$ equal strings with length $$m$$\n\n\\* Time complexity : $$O(S \\\\cdot \\\\log m)$$, where $$S$$ is the sum of all characters in all strings.\n\n The algorithm makes $$\\\\log m$$ iterations, for each of them there are $$S \\= m \\\\cdot n$$ comparisons, which gives in total $$O(S \\\\cdot \\\\log m)$$ time complexity.\n\n\\* Space complexity : $$O(1\\)$$. We only used constant extra space.\n\n\\-\\-\\-\n\n\\#\\#\\# Further Thoughts / Follow up\n\nLet's take a look at a slightly different problem:\n\n\\> Given a set of keys S \\= $$\\[S\\_1,S\\_2 \\\\ldots S\\_n]$$, find the longest common prefix among a string \\`q\\` and S. This LCP query will be called frequently.\n\nWe could optimize LCP queries by storing the set of keys S in a Trie. For more information about Trie, please see this article \\[Implement a trie (Prefix trie)](https://leetcode.com/articles/implement\\-trie\\-prefix\\-tree/). In a Trie, each node descending from the root represents a common prefix of some keys. But we need to find the longest common prefix of a string \\`q\\` and all key strings. This means that we have to find the deepest path from the root, which satisfies the following conditions:\n\\* it is prefix of query string \\`q\\`\n\\* each node along the path must contain only one child element. Otherwise the found path will not be a common prefix among all strings.\n\\* the path doesn't comprise of nodes which are marked as end of key. Otherwise the path couldn't be a prefix a of key which is shorter than itself.\n\n\\#\\#\\#\\# Algorithm\n\nThe only question left, is how to find the deepest path in the Trie, that fulfills the requirements above. The most effective way is to build a trie from $$\\[S\\_1 \\\\ldots S\\_n]$$ strings. Then find the prefix of query string \\`q\\` in the Trie. We traverse the Trie from the root, till it is impossible to continue the path in the Trie because one of the conditions above is not satisfied.\n\n!\\[Finding the longest common prefix using Trie](https://leetcode.com/media/original\\_images/14\\_lcp\\_trie.png){:width\\=\"539px\"}\n\n\n\\*Figure 4\\. Finding the longest common prefix of strings using Trie\\*\n\n\\#\\#\\#\\# Implementation\n\nclass Solution:\\\\n def longestCommonPrefix(self, strs: List\\[str]) \\-\\> str:\\\\n if not strs:\\\\n return \"\"\\\\n minLen \\= min(len(x) for x in strs)\\\\n low, high \\= 1, minLen\\\\n while low \\<\\= high:\\\\n middle \\= (low \\+ high) // 2\\\\n if self.isCommonPrefix(strs, middle):\\\\n low \\= middle \\+ 1\\\\n else:\\\\n high \\= middle \\- 1\\\\n return strs\\[0]\\[: (low \\+ high) // 2]\\\\n\\\\n def isCommonPrefix(self, strs, l):\\\\n str1 \\= strs\\[0]\\[:l]\\\\n for i in range(1, len(strs)):\\\\n if not strs\\[i].startswith(str1\\):\\\\n return False\\\\n return True\n\n\\#\\#\\#\\# Complexity Analysis\n\nIn the worst case query $$q$$ has length $$m$$ and it is equal to all $$n$$ strings of the array.\n\n\\* Time complexity : preprocessing $$O(S)$$, where $$S$$ is the number of all characters in the array, LCP query $$O(m)$$.\n\n Trie build has $$O(S)$$ time complexity. To find the common prefix of $$q$$ in the Trie takes in the worst case $$O(m)$$.\n\n\\* Space complexity : $$O(S)$$. We only used additional $$S$$ extra space for the Trie.",
    "content_md": "Write a function to find the longest common prefix string amongst an array of strings.\n\n\nIf there is no common prefix, return an empty string `\"\"`.\n\n**Example 1:**\n\n\n\n```\n\nInput: strs = [\"flower\",\"flow\",\"flight\"]\nOutput: \"fl\"\n\n```\n\n**Example 2:**\n\n\n\n```\n\nInput: strs = [\"dog\",\"racecar\",\"car\"]\nOutput: \"\"\nExplanation: There is no common prefix among the input strings.\n\n```\n**Constraints:**\n\n\n* `1 <= strs.length <= 200`\n* `0 <= strs[i].length <= 200`\n* `strs[i]` consists of only lowercase English letters.\n\n\n",
    "code_snippets": [],
    "approaches": [
        {
            "title": "2: Vertical scanning",
            "approach": "#### Algorithm\n\nImagine a very short string is the common prefix at the end of the array. The above approach will still do $$S$$ comparisons. One way to optimize this case is to do vertical scanning. We compare characters from top to bottom on the same column (same character index of  the strings) before moving on to the next column.\n\n#### Implementation\n\n<div>'class Solution:\\n\tdef longestCommonPrefix(self, strs: List[str]) -> str:\\n\t\tif strs == None or len(strs) == 0:\\n\t\t\treturn \"\"\\n\t\tfor i in range(len(strs[0])):\\n\t\t\tc = strs[0][i]\\n\t\t\tfor j in range(1, len(strs)):\\n\t\t\t\tif i == len(strs[j]) or strs[j][i] != c:\\n\t\t\t\t\treturn strs[0][0:i]\\n\t\treturn strs[0]'</div>\n\n#### Complexity Analysis\n\n* Time complexity : $$O(S)$$ , where S is the sum of all characters in all strings.\nIn the worst case there will be $$n$$ equal strings with length $$m$$ and the algorithm performs  $$S = m \\cdot n$$ character comparisons.\nEven though the worst case is still the same as [Approach 1](#approach-1-horizontal-scanning), in the best case there are at most $$n \\cdot minLen$$ comparisons where $$minLen$$ is the length of the shortest string in the array.\n* Space complexity : $$O(1)$$. We only used constant extra space."
        },
        {
            "title": "3: Divide and conquer",
            "approach": "#### Intuition\n\nThe idea of the algorithm comes from the associative property of LCP operation. We notice that :\n$$LCP(S_1 \\ldots S_n) = LCP(LCP(S_1 \\ldots S_k), LCP (S_{k+1} \\ldots S_n))$$\n, where $$LCP(S_1 \\ldots S_n)$$ is the longest common prefix in set of strings $$[S_1 \\ldots S_n]$$ , $$1 < k < n$$\n\n#### Algorithm\n\nTo apply the observation above, we use divide and conquer technique, where we split the $$LCP(S_i \\ldots S_j)$$ problem into two subproblems $$LCP(S_i \\ldots S_{mid})$$   and $$LCP(S_{mid+1} \\ldots S_j)$$, where `mid` is $$\\frac{i + j}{2}$$. We use their solutions `lcpLeft` and `lcpRight` to construct the solution of the main problem $$LCP(S_i \\ldots S_j)$$. To accomplish this we compare one by one the characters of `lcpLeft` and `lcpRight` till there is no character match. The found common prefix of `lcpLeft` and `lcpRight` is the solution of the  $$LCP(S_i \\ldots S_j)$$.\n\n![Finding the longest common prefix](https://leetcode.com/media/original_images/14_lcp_diviso_et_lmpera.png){:width=\"539px\"}\n\n\n*Figure 2. Finding the longest common prefix of strings using divide and conquer technique*\n\n#### Implementation\n\n<div>class Solution:\\n\tdef longestCommonPrefix(self, strs: List[str]) -> str:\\n\t\tif strs == None or len(strs) == 0:\\n\t\t\treturn \"\"\\n\t\tfor i in range(len(strs[0])):\\n\t\t\tc = strs[0][i]\\n\t\t\tfor j in range(1, len(strs)):\\n\t\t\t\tif i == len(strs[j]) or strs[j][i] != c:\\n\t\t\t\t\treturn strs[0][0:i]\\n\t\treturn strs[0]</div>\n\n#### Complexity Analysis\n\nIn the worst case we have $$n$$ equal strings with length $$m$$\n\n* Time complexity : $$O(S)$$, where $$S$$ is the number of all characters in the array, $$S = m \\cdot n$$\n Time complexity is $$2 \\cdot T\\left ( \\frac{n}{2} \\right ) + O(m)$$. Therefore time complexity is $$O(S)$$.\n  In the best case this algorithm performs  $$O(minLen \\cdot n)$$ comparisons, where  $$minLen$$ is the shortest string of the array\n\n* Space complexity : $$O(m \\cdot \\log n)$$\n\n    There is a memory overhead since we store recursive calls in the execution stack. There are $$\\log n$$ recursive calls, each store need $$m$$ space to store the result,  so space complexity is $$O(m \\cdot \\log n)$$"
        },
        {
            "title": "4: Binary search",
            "approach": "#### Intuition\n\nThe idea is to apply binary search method to find the string with maximum value `L`, which is common prefix of all of the strings. The algorithm searches space is the interval $$(0 \\ldots minLen)$$, where `minLen` is minimum string length and the maximum possible common prefix. Each time search space is divided in two equal parts, one of them is discarded, because it is sure that it doesn't contain the solution. There are two possible cases:\n* `S[1...mid]` is not a common string. This means that for each `j > i S[1..j]` is not a common string and we discard the second half of the  search space.\n* `S[1...mid]` is common string. This means that for each `i < j S[1..i]` is a common string and we discard the first half of the search space, because we try to find longer common prefix.\n\n![Finding the longest common prefix](https://leetcode.com/media/original_images/14_lcp_binary_search.png){:width=\"539px\"}\n\n\n*Figure 3. Finding the longest common prefix of strings using binary search technique*\n\n#### Implementation\n\n<div>class Solution:\\n\tdef longestCommonPrefix(self, strs: List[str]) -> str:\\n\t\tif not strs:\\n\t\t\treturn \"\"\\n\t\tminLen = min(len(x) for x in strs)\\n\t\tlow, high = 1, minLen\\n\t\twhile low <= high:\\n\t\t\tmiddle = (low + high) // 2\\n\t\t\tif self.isCommonPrefix(strs, middle):\\n\t\t\t\tlow = middle + 1\\n\t\t\telse:\\n\t\t\t\thigh = middle - 1\\n\t\treturn strs[0][: (low + high) // 2]\\n\\n\tdef isCommonPrefix(self, strs, l):\\n\t\tstr1 = strs[0][:l]\\n\t\tfor i in range(1, len(strs)):\\n\t\t\tif not strs[i].startswith(str1):\\n\t\t\t\treturn False\\n\t\treturn True<div>\n\n#### Complexity Analysis\n\nIn the worst case we have $$n$$ equal strings with length $$m$$\n\n* Time complexity : $$O(S \\cdot \\log m)$$, where $$S$$ is the sum of all characters in all strings.\n\n    The algorithm makes $$\\log m$$ iterations, for each of them there are $$S = m \\cdot n$$ comparisons, which gives in total $$O(S \\cdot \\log m)$$ time complexity.\n\n* Space complexity : $$O(1)$$. We only used constant extra space.\n\n---\n\n### Further Thoughts / Follow up\n\nLet's take a look at a slightly different problem:\n\n> Given a set of keys S = $$[S_1,S_2 \\ldots S_n]$$, find the longest common prefix among a string `q` and S. This LCP query will be called frequently.\n\nWe could optimize LCP queries by storing the set of keys S in a Trie. For more information about Trie, please see this article [Implement a trie (Prefix trie)](https://leetcode.com/articles/implement-trie-prefix-tree/). In a Trie, each node descending from the root represents a common prefix of some keys. But we need to find the longest common prefix of a string `q` and all key strings. This means that we have to find the deepest path from the root, which satisfies the following conditions:\n* it is prefix of query string `q`\n* each node along the path must contain only one child element. Otherwise the found path will not be a common prefix among all strings.\n* the path doesn't comprise of nodes which are marked as end of key. Otherwise the path couldn't be a prefix a of key which is shorter than itself.\n\n#### Algorithm\n\nThe only question left, is how to find the deepest path in the Trie, that fulfills the requirements above. The most effective way is to build a trie from $$[S_1 \\ldots   S_n]$$ strings. Then find the prefix of query string `q` in the Trie. We traverse the Trie from the root, till it is impossible to continue the path in the Trie because one of the conditions above is not satisfied.\n\n![Finding the longest common prefix using Trie](https://leetcode.com/media/original_images/14_lcp_trie.png){:width=\"539px\"}\n\n\n*Figure 4. Finding the longest common prefix of strings using Trie*\n\n#### Implementation\n\n<div>class Solution:\\n\tdef longestCommonPrefix(self, strs: List[str]) -> str:\\n\t\tif not strs:\\n\t\t\treturn \"\"\\n\t\tminLen = min(len(x) for x in strs)\\n\t\tlow, high = 1, minLen\\n\t\twhile low <= high:\\n\t\t\tmiddle = (low + high) // 2\\n\t\t\tif self.isCommonPrefix(strs, middle):\\n\t\t\t\tlow = middle + 1\\n\t\t\telse:\\n\t\t\t\thigh = middle - 1\\n\t\treturn strs[0][: (low + high) // 2]\\n\\n\tdef isCommonPrefix(self, strs, l):\\n\t\tstr1 = strs[0][:l]\\n\t\tfor i in range(1, len(strs)):\\n\t\t\tif not strs[i].startswith(str1):\\n\t\t\t\treturn False\\n\t\treturn True</div>\n\n#### Complexity Analysis\n\nIn the worst case query $$q$$ has length $$m$$ and it is equal to all $$n$$ strings of the array.\n\n* Time complexity : preprocessing $$O(S)$$, where $$S$$ is the number of all characters in the array, LCP query $$O(m)$$.\n\n    Trie build has $$O(S)$$ time complexity. To find the common prefix of $$q$$ in the Trie takes in the worst case $$O(m)$$.\n\n* Space complexity : $$O(S)$$. We only used additional  $$S$$ extra space for the Trie."
        }
    ],
    "prep_code": "def find_common_prefix(str1: str, str2: str):\n",
    "test_code": "import unittest\n\n\nclass Test(unittest.TestCase):\n    def test_1(self):\n        solution = Solution()\n        self.assertEqual(\n            solution.longestCommonPrefix([\"flower\", \"flow\", \"flight\"]), \"fl\"\n        )\n\n    def test_2(self):\n        solution = Solution()\n        self.assertEqual(solution.longestCommonPrefix([\"dog\", \"racecar\", \"car\"]), \"\")\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n"
}