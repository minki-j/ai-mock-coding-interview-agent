{
    "content": "<p>Given the <code>root</code> of a binary tree, return <em>the inorder traversal of its nodes&#39; values</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">root = [1,null,2,3]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">[1,3,2]</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2024/08/29/screenshot-2024-08-29-202743.png\" style=\"width: 200px; height: 264px;\" /></p>\n</div>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">root = [1,2,3,4,5,null,8,null,null,6,7,9]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">[4,2,6,5,7,1,3,9,8]</span></p>\n\n<p><strong>Explanation:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2024/08/29/tree_2.png\" style=\"width: 350px; height: 286px;\" /></p>\n</div>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">root = []</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">[]</span></p>\n</div>\n\n<p><strong class=\"example\">Example 4:</strong></p>\n\n<div class=\"example-block\">\n<p><strong>Input:</strong> <span class=\"example-io\">root = [1]</span></p>\n\n<p><strong>Output:</strong> <span class=\"example-io\">[1]</span></p>\n</div>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 100]</code>.</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> Recursive solution is trivial, could you do it iteratively?",
    "difficulty": "Easy",
    "title": "Binary Tree Inorder Traversal",
    "topicTags": [
        {
            "name": "Stack"
        },
        {
            "name": "Tree"
        },
        {
            "name": "Depth-First Search"
        },
        {
            "name": "Binary Tree"
        }
    ],
    "solution": {
        "content": "[TOC]\n\n## Solution\n\n---\n### Approach 1: Recursive Approach\n\nThe first method to solve this problem is using recursion. This is the classical method and is straightforward. We can define a helper function to implement recursion.\n\n<iframe src=\"\n```python3\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def inorderTraversal(self, root):\n        res = []\n        self.helper(root, res)\n        return res\n\n    def helper(self, root, res):\n        if root is not None:\n            self.helper(root.left, res)\n            res.append(root.val)\n            self.helper(root.right, res)\n```\n\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"E5pBkUup\"></iframe>\n\n**Complexity Analysis**\n\nTime complexity: $$O(n)$$\n\n  - The time complexity is $$O(n)$$ because the recursive function is $$T(n) = 2 \\cdot T(n/2)+1$$.\n\nSpace complexity: $$O(n)$$\n\n  - The worst case space required is $$O(n)$$, and in the average case it's $$O(\\log n)$$ where $$n$$ is number of nodes.\n  \n<br />\n\n---\n\n### Approach 2: Iterating method using Stack\n\nThe strategy is very similiar to the first method, the different is using stack.\n\nHere is an illustration:\n\n!?!../Documents/94_Binary.json:1000,563!?!\n\n<iframe src=\"\n```python3\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def inorderTraversal(self, root):\n        res = []\n        stack = []\n        curr = root\n        while curr or stack:\n            while curr:\n                stack.append(curr)\n                curr = curr.left\n            curr = stack.pop()\n            res.append(curr.val)\n            curr = curr.right\n        return res\n```\n\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"9k44r9CB\"></iframe>\n\n**Complexity Analysis**\n\nTime complexity: $$O(n)$$\n\nSpace complexity: $$O(n)$$\n\n<br />\n\n---\n\n### Approach 3: Morris Traversal\n\n\nIn this method, we have to use a new data structure - Threaded Binary Tree, and the strategy is as follows:\n\n\n>Step 1: Initialize current as root\n>\n>Step 2: While current is not NULL,\n>\n>     If current does not have left child\n>\n>         a. Add current\u2019s value\n>\n>         b. Go to the right, i.e., current = current.right\n>\n>     Else\n>\n>         a. In current's left subtree, make current the right child of the rightmost node\n>\n>         b. Go to this left child, i.e., current = current.left\n\n\nFor example:\n```\n\n          1\n        /   \\\n       2     3\n      / \\   /\n     4   5 6\n\n```\nFirst, 1 is the root, so initialize 1 as current, 1 has left child which is 2, the current's left subtree is\n\n```\n         2\n        / \\\n       4   5\n```\n So in this subtree, the rightmost node is 5, then make the current(1) as the right child of 5. Set current = current.left (current = 2).\nThe tree now looks like:\n```\n         2\n        / \\\n       4   5\n            \\\n             1\n              \\\n               3\n              /\n             6\n```\nFor current 2, which has left child 4, we can continue with the same process as we did above\n```\n        4\n         \\\n          2\n           \\\n            5\n             \\\n              1\n               \\\n                3\n               /\n              6\n```\n then add 4 because it has no left child, then add 2, 5, 1, 3 one by one, for node 3 which has left child 6, do the same as above.\nFinally, the inorder traversal is [4,2,5,1,6,3].\n\nFor more details, please check\n[Threaded binary tree](https://en.wikipedia.org/wiki/Threaded_binary_tree) and\n[Explanation of Morris Method](https://stackoverflow.com/questions/5502916/explain-morris-inorder-tree-traversal-without-using-stacks-or-recursion)\n\n\n<iframe src=\"\n```python3\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\n        res = []\n        curr = root\n\n        while curr is not None:\n            if curr.left is None:\n                res.append(curr.val)\n                curr = curr.right  # move to next right node\n            else:\n                pre = curr.left\n                while pre.right is not None and pre.right != curr:  # find rightmost\n                    pre = pre.right\n\n                if pre.right is None:\n                    # establish a link back to the current node\n                    pre.right = curr\n                    curr = curr.left\n                else:\n                    # restore the tree structure\n                    pre.right = None\n                    res.append(curr.val)\n                    curr = curr.right\n\n        return res\n```\n\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"fVkds6Bx\"></iframe>\n\n**Complexity Analysis**\n\nTime complexity: $$O(n)$$\n\n  - To prove that the time complexity is $$O(n)$$, the biggest problem lies in finding the time complexity of finding the predecessor nodes of all the nodes in the binary tree. Intuitively, the complexity is $$O(n \\log n)$$, because to find the predecessor node for a single node related to the height of the tree. But in fact, finding the predecessor nodes for all nodes only needs $$O(n)$$ time. Because a binary Tree with $$n$$ nodes has $$n-1$$ edges, the whole processing for each edges up to 2 times, one is to locate a node, and the other is to find the predecessor node. So the complexity is $$O(n)$$.\n\nSpace complexity: $$O(1)$$\n\n  - Extra space is only allocated for the ArrayList of size $$n$$, however the output does not count towards the space complexity."
    },
    "code_snippets": [
        {
            "url": "https://leetcode.com/playground/E5pBkUup/shared",
            "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def inorderTraversal(self, root):\n        res = []\n        self.helper(root, res)\n        return res\n\n    def helper(self, root, res):\n        if root is not None:\n            self.helper(root.left, res)\n            res.append(root.val)\n            self.helper(root.right, res)",
            "langSlug": "python3"
        },
        {
            "url": "https://leetcode.com/playground/9k44r9CB/shared",
            "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def inorderTraversal(self, root):\n        res = []\n        stack = []\n        curr = root\n        while curr or stack:\n            while curr:\n                stack.append(curr)\n                curr = curr.left\n            curr = stack.pop()\n            res.append(curr.val)\n            curr = curr.right\n        return res",
            "langSlug": "python3"
        },
        {
            "url": "https://leetcode.com/playground/fVkds6Bx/shared",
            "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\n        res = []\n        curr = root\n\n        while curr is not None:\n            if curr.left is None:\n                res.append(curr.val)\n                curr = curr.right  # move to next right node\n            else:\n                pre = curr.left\n                while pre.right is not None and pre.right != curr:  # find rightmost\n                    pre = pre.right\n\n                if pre.right is None:\n                    # establish a link back to the current node\n                    pre.right = curr\n                    curr = curr.left\n                else:\n                    # restore the tree structure\n                    pre.right = None\n                    res.append(curr.val)\n                    curr = curr.right\n\n        return res",
            "langSlug": "python3"
        }
    ],
    "content_md": "Given the `root` of a binary tree, return *the inorder traversal of its nodes' values*.\n\n**Example 1:**\n\n\n\n**Input:** root \\= \\[1,null,2,3]\n\n\n**Output:** \\[1,3,2]\n\n\n**Explanation:**\n\n\n![](https://assets.leetcode.com/uploads/2024/08/29/screenshot-2024-08-29-202743.png)\n\n\n\n**Example 2:**\n\n\n\n**Input:** root \\= \\[1,2,3,4,5,null,8,null,null,6,7,9]\n\n\n**Output:** \\[4,2,6,5,7,1,3,9,8]\n\n\n**Explanation:**\n\n\n![](https://assets.leetcode.com/uploads/2024/08/29/tree_2.png)\n\n\n\n**Example 3:**\n\n\n\n**Input:** root \\= \\[]\n\n\n**Output:** \\[]\n\n\n\n**Example 4:**\n\n\n\n**Input:** root \\= \\[1]\n\n\n**Output:** \\[1]\n\n\n**Constraints:**\n\n\n* The number of nodes in the tree is in the range `[0, 100]`.\n* `-100 <= Node.val <= 100`\n\n**Follow up:** Recursive solution is trivial, could you do it iteratively?",
    "solution_md": "\\[TOC]\n\n\\#\\# Solution\n\n\\-\\-\\-\n\\#\\#\\# Approach 1: Recursive Approach\n\nThe first method to solve this problem is using recursion. This is the classical method and is straightforward. We can define a helper function to implement recursion.\n\n\\`\\`\\`python3\n\\# Definition for a binary tree node.\n\\# class TreeNode:\n\\# def \\_\\_init\\_\\_(self, val\\=0, left\\=None, right\\=None):\n\\# self.val \\= val\n\\# self.left \\= left\n\\# self.right \\= right\n\nclass Solution:\n def inorderTraversal(self, root):\n res \\= \\[]\n self.helper(root, res)\n return res\n\n def helper(self, root, res):\n if root is not None:\n self.helper(root.left, res)\n res.append(root.val)\n self.helper(root.right, res)\n\\`\\`\\`\n \n\\*\\*Complexity Analysis\\*\\*\n\nTime complexity: $$O(n)$$\n\n \\- The time complexity is $$O(n)$$ because the recursive function is $$T(n) \\= 2 \\\\cdot T(n/2\\)\\+1$$.\n\nSpace complexity: $$O(n)$$\n\n \\- The worst case space required is $$O(n)$$, and in the average case it's $$O(\\\\log n)$$ where $$n$$ is number of nodes.\n \n  \n\n\n\\-\\-\\-\n\n\\#\\#\\# Approach 2: Iterating method using Stack\n\nThe strategy is very similiar to the first method, the different is using stack.\n\nHere is an illustration:\n\n!?!../Documents/94\\_Binary.json:1000,563!?!\n\n\\`\\`\\`python3\n\\# Definition for a binary tree node.\n\\# class TreeNode:\n\\# def \\_\\_init\\_\\_(self, val\\=0, left\\=None, right\\=None):\n\\# self.val \\= val\n\\# self.left \\= left\n\\# self.right \\= right\n\nclass Solution:\n def inorderTraversal(self, root):\n res \\= \\[]\n stack \\= \\[]\n curr \\= root\n while curr or stack:\n while curr:\n stack.append(curr)\n curr \\= curr.left\n curr \\= stack.pop()\n res.append(curr.val)\n curr \\= curr.right\n return res\n\\`\\`\\`\n \n\\*\\*Complexity Analysis\\*\\*\n\nTime complexity: $$O(n)$$\n\nSpace complexity: $$O(n)$$\n\n  \n\n\n\\-\\-\\-\n\n\\#\\#\\# Approach 3: Morris Traversal\n\n\nIn this method, we have to use a new data structure \\- Threaded Binary Tree, and the strategy is as follows:\n\n\n\\>Step 1: Initialize current as root\n\\>\n\\>Step 2: While current is not NULL,\n\\>\n\\> If current does not have left child\n\\>\n\\> a. Add current\u2019s value\n\\>\n\\> b. Go to the right, i.e., current \\= current.right\n\\>\n\\> Else\n\\>\n\\> a. In current's left subtree, make current the right child of the rightmost node\n\\>\n\\> b. Go to this left child, i.e., current \\= current.left\n\n\nFor example:\n\\`\\`\\`\n\n 1\n / \\\\\n 2 3\n / \\\\ /\n 4 5 6\n\n\\`\\`\\`\nFirst, 1 is the root, so initialize 1 as current, 1 has left child which is 2, the current's left subtree is\n\n\\`\\`\\`\n 2\n / \\\\\n 4 5\n\\`\\`\\`\n So in this subtree, the rightmost node is 5, then make the current(1\\) as the right child of 5\\. Set current \\= current.left (current \\= 2\\).\nThe tree now looks like:\n\\`\\`\\`\n 2\n / \\\\\n 4 5\n \\\\\n 1\n \\\\\n 3\n /\n 6\n\\`\\`\\`\nFor current 2, which has left child 4, we can continue with the same process as we did above\n\\`\\`\\`\n 4\n \\\\\n 2\n \\\\\n 5\n \\\\\n 1\n \\\\\n 3\n /\n 6\n\\`\\`\\`\n then add 4 because it has no left child, then add 2, 5, 1, 3 one by one, for node 3 which has left child 6, do the same as above.\nFinally, the inorder traversal is \\[4,2,5,1,6,3].\n\nFor more details, please check\n\\[Threaded binary tree](https://en.wikipedia.org/wiki/Threaded\\_binary\\_tree) and\n\\[Explanation of Morris Method](https://stackoverflow.com/questions/5502916/explain\\-morris\\-inorder\\-tree\\-traversal\\-without\\-using\\-stacks\\-or\\-recursion)\n\n\n\\`\\`\\`python3\n\\# Definition for a binary tree node.\n\\# class TreeNode:\n\\# def \\_\\_init\\_\\_(self, val\\=0, left\\=None, right\\=None):\n\\# self.val \\= val\n\\# self.left \\= left\n\\# self.right \\= right\n\nclass Solution:\n def inorderTraversal(self, root: TreeNode) \\-\\> List\\[int]:\n res \\= \\[]\n curr \\= root\n\n while curr is not None:\n if curr.left is None:\n res.append(curr.val)\n curr \\= curr.right \\# move to next right node\n else:\n pre \\= curr.left\n while pre.right is not None and pre.right !\\= curr: \\# find rightmost\n pre \\= pre.right\n\n if pre.right is None:\n \\# establish a link back to the current node\n pre.right \\= curr\n curr \\= curr.left\n else:\n \\# restore the tree structure\n pre.right \\= None\n res.append(curr.val)\n curr \\= curr.right\n\n return res\n\\`\\`\\`\n \n\\*\\*Complexity Analysis\\*\\*\n\nTime complexity: $$O(n)$$\n\n \\- To prove that the time complexity is $$O(n)$$, the biggest problem lies in finding the time complexity of finding the predecessor nodes of all the nodes in the binary tree. Intuitively, the complexity is $$O(n \\\\log n)$$, because to find the predecessor node for a single node related to the height of the tree. But in fact, finding the predecessor nodes for all nodes only needs $$O(n)$$ time. Because a binary Tree with $$n$$ nodes has $$n\\-1$$ edges, the whole processing for each edges up to 2 times, one is to locate a node, and the other is to find the predecessor node. So the complexity is $$O(n)$$.\n\nSpace complexity: $$O(1\\)$$\n\n \\- Extra space is only allocated for the ArrayList of size $$n$$, however the output does not count towards the space complexity.",
    "approaches": [
        {
            "title": "2: Iterating method using Stack",
            "approach": "The strategy is very similiar to the first method, the different is using stack.\n\nHere is an illustration:\n\n!?!../Documents/94_Binary.json:1000,563!?!\n\n```python3\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def inorderTraversal(self, root):\n        res = []\n        stack = []\n        curr = root\n        while curr or stack:\n            while curr:\n                stack.append(curr)\n                curr = curr.left\n            curr = stack.pop()\n            res.append(curr.val)\n            curr = curr.right\n        return res\n```\n \n**Complexity Analysis**\n\nTime complexity: $$O(n)$$\n\nSpace complexity: $$O(n)$$\n\n<br />"
        },
        {
            "title": "3: Morris Traversal",
            "approach": "In this method, we have to use a new data structure - Threaded Binary Tree, and the strategy is as follows:\n\n\n>Step 1: Initialize current as root\n>\n>Step 2: While current is not NULL,\n>\n>     If current does not have left child\n>\n>         a. Add current\u2019s value\n>\n>         b. Go to the right, i.e., current = current.right\n>\n>     Else\n>\n>         a. In current's left subtree, make current the right child of the rightmost node\n>\n>         b. Go to this left child, i.e., current = current.left\n\n\nFor example:\n```\n\n          1\n        /   \\\n       2     3\n      / \\   /\n     4   5 6\n\n```\nFirst, 1 is the root, so initialize 1 as current, 1 has left child which is 2, the current's left subtree is\n\n```\n         2\n        / \\\n       4   5\n```\n So in this subtree, the rightmost node is 5, then make the current(1) as the right child of 5. Set current = current.left (current = 2).\nThe tree now looks like:\n```\n         2\n        / \\\n       4   5\n            \\\n             1\n              \\\n               3\n              /\n             6\n```\nFor current 2, which has left child 4, we can continue with the same process as we did above\n```\n        4\n         \\\n          2\n           \\\n            5\n             \\\n              1\n               \\\n                3\n               /\n              6\n```\n then add 4 because it has no left child, then add 2, 5, 1, 3 one by one, for node 3 which has left child 6, do the same as above.\nFinally, the inorder traversal is [4,2,5,1,6,3].\n\nFor more details, please check\n[Threaded binary tree](https://en.wikipedia.org/wiki/Threaded_binary_tree) and\n[Explanation of Morris Method](https://stackoverflow.com/questions/5502916/explain-morris-inorder-tree-traversal-without-using-stacks-or-recursion)\n\n\n```python3\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\n        res = []\n        curr = root\n\n        while curr is not None:\n            if curr.left is None:\n                res.append(curr.val)\n                curr = curr.right  # move to next right node\n            else:\n                pre = curr.left\n                while pre.right is not None and pre.right != curr:  # find rightmost\n                    pre = pre.right\n\n                if pre.right is None:\n                    # establish a link back to the current node\n                    pre.right = curr\n                    curr = curr.left\n                else:\n                    # restore the tree structure\n                    pre.right = None\n                    res.append(curr.val)\n                    curr = curr.right\n\n        return res\n```\n \n**Complexity Analysis**\n\nTime complexity: $$O(n)$$\n\n  - To prove that the time complexity is $$O(n)$$, the biggest problem lies in finding the time complexity of finding the predecessor nodes of all the nodes in the binary tree. Intuitively, the complexity is $$O(n \\log n)$$, because to find the predecessor node for a single node related to the height of the tree. But in fact, finding the predecessor nodes for all nodes only needs $$O(n)$$ time. Because a binary Tree with $$n$$ nodes has $$n-1$$ edges, the whole processing for each edges up to 2 times, one is to locate a node, and the other is to find the predecessor node. So the complexity is $$O(n)$$.\n\nSpace complexity: $$O(1)$$\n\n  - Extra space is only allocated for the ArrayList of size $$n$$, however the output does not count towards the space complexity."
        }
    ],
    "prep_code": "from typing import List\n\n\nfrom utils.tree import TreeNode\n\n\nclass Solution:\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\n",
    "test_code": "import unittest\n\nfrom utils.tree import make_tree\n\n\nclass Test(unittest.TestCase):\n    def test_1(self):\n        values = [1, None, 2, 3]\n        root = make_tree(values)\n        solution = Solution()\n        self.assertEqual(solution.inorderTraversal(root), [1, 3, 2])\n\n    def test_2(self):\n        solution = Solution()\n        self.assertEqual(solution.inorderTraversal(None), [])\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n"
}